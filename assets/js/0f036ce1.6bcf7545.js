"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[19114],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var i=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var p=i.createContext({}),l=function(e){var n=i.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=l(e.components);return i.createElement(p.Provider,{value:n},e.children)},d="mdxType",f={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=l(t),u=o,m=d["".concat(p,".").concat(u)]||d[u]||f[u]||a;return t?i.createElement(m,r(r({ref:n},c),{},{components:t})):i.createElement(m,r({ref:n},c))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,r=new Array(a);r[0]=u;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s[d]="string"==typeof e?e:o,r[1]=s;for(var l=2;l<a;l++)r[l]=t[l];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},83653:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>r,default:()=>f,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var i=t(87462),o=(t(67294),t(3905));const a={id:"index",title:"Introduction to Configuration in ZIO"},r=void 0,s={unversionedId:"reference/configuration/index",id:"reference/configuration/index",title:"Introduction to Configuration in ZIO",description:"Configuration is a core concern for any cloud-native application. So ZIO ships with built-in support for configuration by providing a front-end for configuration providers as well as metrics and logging.",source:"@site/docs/reference/configuration/index.md",sourceDirName:"reference/configuration",slug:"/reference/configuration/",permalink:"/reference/configuration/",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/configuration/index.md",tags:[],version:"current",frontMatter:{id:"index",title:"Introduction to Configuration in ZIO"},sidebar:"reference-sidebar",previous:{title:"Supervisor",permalink:"/reference/observability/supervisor"},next:{title:"Introduction to ZIO Test",permalink:"/reference/test/"}},p={},l=[{value:"Getting Started",id:"getting-started",level:2},{value:"Primitive Configs",id:"primitive-configs",level:2},{value:"Custom Configs",id:"custom-configs",level:2},{value:"Example 1",id:"example-1",level:3},{value:"Example 2",id:"example-2",level:3},{value:"Top-level and Nested Configs",id:"top-level-and-nested-configs",level:2},{value:"Built-in Config Providers",id:"built-in-config-providers",level:2},{value:"Custom Config Provider",id:"custom-config-provider",level:2},{value:"Testing Services",id:"testing-services",level:2}],c={toc:l},d="wrapper";function f(e){let{components:n,...t}=e;return(0,o.kt)(d,(0,i.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Configuration is a core concern for any cloud-native application. So ZIO ships with built-in support for configuration by providing a front-end for configuration providers as well as metrics and logging."),(0,o.kt)("p",null,"So, ZIO provides a unified way to configure our applications, while still enabling customizability, flexibility, and significant integrations with configuration backends via ecosystem projects, most notably ",(0,o.kt)("a",{parentName:"p",href:"https://zio.dev/zio-config"},"ZIO Config"),"."),(0,o.kt)("p",null,"This configuration front-end allows ecosystem libraries and applications to declaratively describe their configuration needs and delegates the heavy lifting to a ConfigProvider, which may be supplied by third-party libraries such as ZIO Config."),(0,o.kt)("p",null,"The ZIO Core ships with a simple default config provider, which reads configuration data from environment variables and if not found, from system properties. This can be used for development purposes or to bootstrap applications toward more sophisticated config providers."),(0,o.kt)("h2",{id:"getting-started"},"Getting Started"),(0,o.kt)("p",null,"To make our application configurable, we should know about three essential elements:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Config Description"),"\u2014 To describe configuration data of type ",(0,o.kt)("inlineCode",{parentName:"p"},"A"),", we should create an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"Config[A]"),". If the configuration data is simple (such as ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"boolean"),"), we can use built-in configs inside companion object of ",(0,o.kt)("inlineCode",{parentName:"p"},"Config")," data type. By combining primitive configs, we can model custom data types such as ",(0,o.kt)("inlineCode",{parentName:"p"},"HostPort"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Config Front-end"),"\u2014 By using ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO.config")," we can load configuration data described by ",(0,o.kt)("inlineCode",{parentName:"p"},"Config"),". It takes a ",(0,o.kt)("inlineCode",{parentName:"p"},"Config[A]")," instance and loads the config using the current ",(0,o.kt)("inlineCode",{parentName:"p"},"ConfigProvider"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Config Backend"),"\u2014 ",(0,o.kt)("inlineCode",{parentName:"p"},"ConfigProvider")," is the underlying engine that ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO.config")," uses to load configs. ZIO has a default config provider inside its default services. The default config provider reads configuration data from environment variables and if not found, from system properties. To change the default config provider, we can use ",(0,o.kt)("inlineCode",{parentName:"p"},"Runtime.setConfigProvider")," layer to configure the ZIO runtime to use a custom config provider."))),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"By introducing built-in config front-end in ZIO Core, the old way of reading configuration data using ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," is deprecated, and we don't recommend using layers for configuration anymore.")),(0,o.kt)("h2",{id:"primitive-configs"},"Primitive Configs"),(0,o.kt)("p",null,"ZIO provides a set of primitive configs for the most common types like ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"long"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"boolean"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"double"),", etc. All of these configs are available inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"Config")," object."),(0,o.kt)("p",null,"Let's start with a simple example of how to read configuration from environment variables and system properties:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = {\n    for {\n      host <- ZIO.config(Config.string("host"))\n      port <- ZIO.config(Config.int("port"))\n      _    <- Console.printLine(s"Application started: $host:$port")\n    } yield ()\n  }\n}\n')),(0,o.kt)("p",null,"If we run this application we will get the following output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'timestamp=2023-02-14T09:45:27.074151Z level=ERROR thread=#zio-fiber-0 message="" cause="Exception in thread "zio-fiber-4" zio.Config$Error$Or: ((Missing data at host: Expected HOST to be set in the environment) or (Missing data at host: Expected host to be set in properties))\n')),(0,o.kt)("p",null,"This is because we have not provided any configuration. Let's try to run it with the following environment variables:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'HOST=localhost PORT=8080 sbt "runMain MainApp"\n')),(0,o.kt)("p",null,"Now we get the following output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"Application started: localhost:8080\n")),(0,o.kt)("p",null,"We can also run it by setting system properties:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'sbt -Dhost=localhost -Dport=8080 "runMain MainApp"\n')),(0,o.kt)("h2",{id:"custom-configs"},"Custom Configs"),(0,o.kt)("p",null,"Other than primitive types, we can also define a configuration for custom types. To do so, we need to use primitive configs and combine them together using ",(0,o.kt)("inlineCode",{parentName:"p"},"Config")," operators (",(0,o.kt)("inlineCode",{parentName:"p"},"++"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"||"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),", etc) and constructors (",(0,o.kt)("inlineCode",{parentName:"p"},"listOf"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"chunkOf"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"setOf"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"vectorOf"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"table"),", etc)."),(0,o.kt)("h3",{id:"example-1"},"Example 1"),(0,o.kt)("p",null,"Let's say we have the ",(0,o.kt)("inlineCode",{parentName:"p"},"HostPort")," data type, which consists of two fields: ",(0,o.kt)("inlineCode",{parentName:"p"},"host")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"port"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class HostPort(host: String, port: Int)\n")),(0,o.kt)("p",null,"We can define a config for this data type by combining primitive ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"int")," configs:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject HostPort {\n  val config: Config[HostPort] =\n    (Config.string("host") ++ Config.int("port")).map { case (host, port) =>\n      HostPort(host, port)\n    }\n}\n')),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"The best practice is to put the ",(0,o.kt)("inlineCode",{parentName:"p"},"Config")," value in the companion object of the configuration data type and call it ",(0,o.kt)("inlineCode",{parentName:"p"},"config"),".")),(0,o.kt)("p",null,"If we use this customized config in our application, it tries to read corresponding values from environment variables (",(0,o.kt)("inlineCode",{parentName:"p"},"HOST")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"PORT"),") and system properties (",(0,o.kt)("inlineCode",{parentName:"p"},"host")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"port"),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  config <- ZIO.config(HostPort.config)\n  _      <- Console.printLine(s"Application started: $config")\n} yield ()\n')),(0,o.kt)("h3",{id:"example-2"},"Example 2"),(0,o.kt)("p",null,"Now let's assume we want to have multiple ",(0,o.kt)("inlineCode",{parentName:"p"},"HostPort")," configurations. We can define a config for a list of ",(0,o.kt)("inlineCode",{parentName:"p"},"HostPort")," like bellow using the ",(0,o.kt)("inlineCode",{parentName:"p"},"listOf")," constructor:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class HostPorts(hostPorts: List[HostPort])\n\nobject HostPorts {\n  val config: Config[HostPorts] =\n    Config.listOf(HostPort.config).map(HostPorts(_))\n}\n")),(0,o.kt)("p",null,"Then we can use this config in our application:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  config <- ZIO.config(HostPorts.config)\n  _      <- Console.printLine(s"Application started with:")\n  _      <- ZIO.foreachDiscard(config.hostPorts)(e => Console.printLine(s"  - http://${e.host}:${e.port}"))\n} yield ()\n')),(0,o.kt)("p",null,"With the default config provider, we can run the application with the following environment variables:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'HOST=host1,host2,host3 PORT=8080,8081,8082 sbt "runMain MainApp"\n')),(0,o.kt)("p",null,"The output will be:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"Application started with:\n  - http://host1:8081\n  - http://host2:8082\n  - http://host3:8083\n")),(0,o.kt)("h2",{id:"top-level-and-nested-configs"},"Top-level and Nested Configs"),(0,o.kt)("p",null,"So far we have seen how to define configuration in a top-level manner, whether it is a primitive or a custom type. But we can also define a nested configuration."),(0,o.kt)("p",null,"Assume we have a ",(0,o.kt)("inlineCode",{parentName:"p"},"SerivceConfig")," data type that consists of two fields: ",(0,o.kt)("inlineCode",{parentName:"p"},"hostPort")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"timeout"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class ServiceConfig(hostPort: HostPort, timeout: Int)\n")),(0,o.kt)("p",null,"Let's define a config for this type in its companion object:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject ServiceConfig {\n  val config: Config[ServiceConfig] =\n    (HostPort.config ++ Config.int("timeout")).map {\n      case (a, b) => ServiceConfig(a, b)\n    }\n}\n')),(0,o.kt)("p",null,"If we use this customized config in our application, it tries to read corresponding values from environment variables (",(0,o.kt)("inlineCode",{parentName:"p"},"HOST"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"PORT"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"TIMEOUT"),") and, if not found from system properties (",(0,o.kt)("inlineCode",{parentName:"p"},"host"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"port"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"timeout"),")."),(0,o.kt)("p",null,"But in most circumstances, we don't want to read all the configurations from the top-level namespace. Instead, we want to nest them under a common namespace. In this case, we want to read both ",(0,o.kt)("inlineCode",{parentName:"p"},"HOST")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"PORT")," from the ",(0,o.kt)("inlineCode",{parentName:"p"},"HOSTPORT")," namespace, and ",(0,o.kt)("inlineCode",{parentName:"p"},"TIMEOUT")," from the root namespace. In order to do that, we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"nested")," combinator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-diff"},'object ServiceConfig {\n  val config: Config[ServiceConfig] =\n-    (HostPort.config ++ Config.int("timeout")).map {\n+    (HostPort.config.nested("hostport") ++ Config.int("timeout")).map {\n      case (a, b) => ServiceConfig(a, b)\n    }\n}\n')),(0,o.kt)("p",null,"Now, if we run our application, it tries to read corresponding values from environment variables (",(0,o.kt)("inlineCode",{parentName:"p"},"HOSTPORT_HOST"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"HOSTPORT_PORT")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"TIMEOUT"),") and, if not found it tries to read from system properties (",(0,o.kt)("inlineCode",{parentName:"p"},"hostport.host"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"hostport.port")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"timeout"),")."),(0,o.kt)("h2",{id:"built-in-config-providers"},"Built-in Config Providers"),(0,o.kt)("p",null,"ZIO has some built-in config providers:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ConfigProvider.defaultProvider")," - reads configuration from environment variables and if not found, from system properties"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ConfigProvider.envProvider")," - reads configuration from environment variables"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ConfigProvider.propsProvider")," - reads configuration from system properties"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ConfigProvider.consoleProvider")," - reads configuration from interactive console prompts")),(0,o.kt)("p",null,"Other than these built-in providers, we can also use third-party providers in ZIO ecosystem libraries, such as ZIO Config which provides a rich set of backends for reading configuration from different sources such as HOCON, JSON, YAML, etc."),(0,o.kt)("h2",{id:"custom-config-provider"},"Custom Config Provider"),(0,o.kt)("p",null,"We can also define our own custom config providers."),(0,o.kt)("p",null,"The default config provider is used by default, but we can also override it by using ",(0,o.kt)("inlineCode",{parentName:"p"},"Runtime#setConfigProvider"),"."),(0,o.kt)("p",null,"In the following example, we set the default config provider to ",(0,o.kt)("inlineCode",{parentName:"p"},"consoleProvider")," which reads configuration from the console:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainAppScoped extends ZIOAppDefault {\n  override val bootstrap: ZLayer[Any, Nothing, Unit] =\n    Runtime.setConfigProvider(ConfigProvider.consoleProvider)\n\n  def run =\n    for {\n      host <- ZIO.config(Config.string("host"))\n      port <- ZIO.config(Config.int("port"))\n      _ <- Console.printLine(s"Application started: http://$host:$port")\n    } yield ()\n}\n')),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"The console provider is stored inside a ",(0,o.kt)("inlineCode",{parentName:"p"},"FiberRef"),", so we can override it in a scoped manner. This is useful for changing the config provider for a specific part of the application.")),(0,o.kt)("h2",{id:"testing-services"},"Testing Services"),(0,o.kt)("p",null,"When testing services, we sometimes need to provide some configuration to them. So we should be able to mock any backend that we use for reading configuration data."),(0,o.kt)("p",null,"In order to do that, we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"ConfigProvider.fromMap")," constructor, which takes a map of configuration data and returns a config provider that reads configuration from that map. Then we can pass that to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Runtime.setConfigProvider"),", which returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayer")," that we can use to override the default config provider for our test specs using ",(0,o.kt)("inlineCode",{parentName:"p"},"Spec#provideLayer")," operator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test._\n\nobject MyServiceTest extends ZIOSpecDefault {\n\n  val mockConfigProvider: ZLayer[Any, Nothing, Unit] =\n    Runtime.setConfigProvider(ConfigProvider.fromMap(Map("timeout" -> "5s")))\n\n  // This service reads configuration data (host and port) inside its implementation\n  def myService: ZIO[Any, Config.Error, Double] = ???\n\n  override def spec = {\n    val expected: Double = ??? // expected value\n    test("test myService") {\n      for {\n        result <- myService\n      } yield assertTrue(result == expected)\n    }\n  }.provideLayer(mockConfigProvider)\n  \n}\n')))}f.isMDXComponent=!0}}]);