"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[59030],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},f="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),f=p(n),m=i,h=f["".concat(s,".").concat(m)]||f[m]||u[m]||r;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[f]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},70260:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={id:"basic-operations",title:"Basic Operations"},o=void 0,l={unversionedId:"overview/basic-operations",id:"overview/basic-operations",title:"Basic Operations",description:"Like the String data type, as well as the collection data types in Scala (such as List, Map, and Set), ZIO effects are immutable, and cannot be changed.",source:"@site/docs/overview/basic-operations.md",sourceDirName:"overview",slug:"/overview/basic-operations",permalink:"/overview/basic-operations",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/overview/basic-operations.md",tags:[],version:"current",frontMatter:{id:"basic-operations",title:"Basic Operations"},sidebar:"overview_sidebar",previous:{title:"Creating Effects",permalink:"/overview/creating-effects"},next:{title:"Handling Errors",permalink:"/overview/handling-errors"}},s={},p=[{value:"Mapping",id:"mapping",level:2},{value:"Chaining",id:"chaining",level:2},{value:"For Comprehensions",id:"for-comprehensions",level:2},{value:"Zipping",id:"zipping",level:2},{value:"Next Steps",id:"next-steps",level:2}],c={toc:p},f="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(f,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Like the ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," data type, as well as the collection data types in Scala (such as ",(0,i.kt)("inlineCode",{parentName:"p"},"List"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Map"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Set"),"), ZIO effects are ",(0,i.kt)("em",{parentName:"p"},"immutable"),", and cannot be changed. "),(0,i.kt)("p",null,"In order to transform or combine ZIO effects, you can use the methods on the ZIO data type, which return ",(0,i.kt)("em",{parentName:"p"},"new effects"),", with the specified transformations or combinations applied to them."),(0,i.kt)("p",null,"There are two categories of methods on the ZIO data type:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Transformations"),". Transformation functions alter an effect in some well-defined way, allowing you to customize runtime behavior. For example, calling ",(0,i.kt)("inlineCode",{parentName:"li"},"effect.timeout(60.seconds)")," on an effect returns a new effect, which, when executed, will apply a timeout to the original effect."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Combinations"),". Combination functions combine two or more effects together in a single effect. For example, calling ",(0,i.kt)("inlineCode",{parentName:"li"},"effect1.orElse(effect2)")," combines two effects in such a fashion that the returned effect, when executed, will first execute the left hand side, and if that fails, it will then execute the right hand side. This lets you specify a fallback effect in case a primary effect fails.")),(0,i.kt)("h2",{id:"mapping"},"Mapping"),(0,i.kt)("p",null,"If you have an effect that succeeds with some value, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#map")," to obtain a new effect, which will transform the value using the function you provide."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval succeeded: ZIO[Any, Nothing, Int] = ZIO.succeed(21).map(_ * 2)\n")),(0,i.kt)("p",null,"In a similar fashion, you can transform an effect that has one error to an effect with a different error using the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#mapError")," method, which requires you supply a function to do the conversion:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val failed: ZIO[Any, Exception, Unit] = \n  ZIO.fail("No no!").mapError(msg => new Exception(msg))\n')),(0,i.kt)("p",null,"Note that mapping the error or success value of an effect does not change ",(0,i.kt)("em",{parentName:"p"},"whether or not")," the effect fails or succeeds. This is similar to how mapping over Scala's ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," data type does not change whether the ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Left")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Right"),"."),(0,i.kt)("h2",{id:"chaining"},"Chaining"),(0,i.kt)("p",null,"You can execute two effects sequentially with the ",(0,i.kt)("inlineCode",{parentName:"p"},"flatMap")," method. The ",(0,i.kt)("inlineCode",{parentName:"p"},"flatMap")," method requires that you pass a callback, which will receive the success value of the first effect, and must return a second effect, which depends on this value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val sequenced: ZIO[Any, IOException, Unit] =\n  Console.readLine.flatMap(input => Console.printLine(s"You entered: $input"))\n')),(0,i.kt)("p",null,"If the first effect fails, the callback passed to ",(0,i.kt)("inlineCode",{parentName:"p"},"flatMap")," will never be invoked, and the effect returned by ",(0,i.kt)("inlineCode",{parentName:"p"},"flatMap")," will also fail."),(0,i.kt)("p",null,"In ",(0,i.kt)("em",{parentName:"p"},"any")," chain of effects created with ",(0,i.kt)("inlineCode",{parentName:"p"},"flatMap"),", the first failure will short-circuit the whole chain, just like throwing an exception will prematurely exit a sequence of statements."),(0,i.kt)("h2",{id:"for-comprehensions"},"For Comprehensions"),(0,i.kt)("p",null,"Because the ZIO data type supports both ",(0,i.kt)("inlineCode",{parentName:"p"},"flatMap")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),", you can use Scala's ",(0,i.kt)("em",{parentName:"p"},"for comprehensions")," to build imperative effects:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val program: ZIO[Any, IOException, Unit] =\n  for {\n    _    <- Console.printLine("Hello! What is your name?")\n    name <- Console.readLine\n    _    <- Console.printLine(s"Hello, ${name}, welcome to ZIO!")\n  } yield ()\n')),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"For comprehensions")," provide a procedural syntax for creating chains of effects, and are the fastest way for most programmers to get up to speed using ZIO."),(0,i.kt)("h2",{id:"zipping"},"Zipping"),(0,i.kt)("p",null,"You can combine two effects into a single effect with the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#zip")," method. "),(0,i.kt)("p",null,"The method returns an effect that will execute the left effect first, followed by the right effect, and which will place both success values into a tuple:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val zipped: ZIO[Any, Nothing, (String, Int)] = \n  ZIO.succeed("4").zip(ZIO.succeed(2))\n')),(0,i.kt)("p",null,"In any ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," operation, if either the left or right-hand side fails, the composed effect will fail, because ",(0,i.kt)("em",{parentName:"p"},"both")," values are required to construct the tuple. If the left side fails, the right side will not be executed at all."),(0,i.kt)("p",null,"Sometimes, when the success value of an effect is not useful (for example, if it is ",(0,i.kt)("inlineCode",{parentName:"p"},"Unit"),"), it can be more convenient to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#zipLeft")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#zipRight")," functions, which first perform a ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," and then map over the tuple to discard one side or the other:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val zipRight1: ZIO[Any, IOException, String] =\n  Console.printLine("What is your name?").zipRight(Console.readLine)\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"zipRight")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"zipLeft")," functions have symbolic aliases, known as ",(0,i.kt)("inlineCode",{parentName:"p"},"*>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<*"),", respectively. Some developers find these operators easier to read:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val zipRight2: ZIO[Any, IOException, String] =\n  Console.printLine("What is your name?") *>\n    Console.readLine\n')),(0,i.kt)("h2",{id:"next-steps"},"Next Steps"),(0,i.kt)("p",null,"If you are comfortable with the basic operations on ZIO effects, the next step is to learn about ",(0,i.kt)("a",{parentName:"p",href:"/overview/handling-errors"},"error handling"),"."))}u.isMDXComponent=!0}}]);