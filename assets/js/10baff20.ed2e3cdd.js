"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[82131],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),c=i,h=u["".concat(s,".").concat(c)]||u[c]||m[c]||o;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4508:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const o={id:"execution",title:"Execution"},r="Execution",l={unversionedId:"zio-flow/execution",id:"zio-flow/execution",title:"Execution",description:"The data structures and operators in the zio-flow library only describe a ZIO Flow program. To execute them we need",source:"@site/docs/zio-flow/execution.md",sourceDirName:"zio-flow",slug:"/zio-flow/execution",permalink:"/zio-flow/execution",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-flow/execution.md",tags:[],version:"current",frontMatter:{id:"execution",title:"Execution"},sidebar:"ecosystem-sidebar",previous:{title:"Activities",permalink:"/zio-flow/activities"},next:{title:"Backends",permalink:"/zio-flow/backends"}},s={},p=[{value:"Embedding the persistent executor",id:"embedding-the-persistent-executor",level:2},{value:"<code>run</code>",id:"run",level:3},{value:"<code>start</code> and <code>poll</code>",id:"start-and-poll",level:3},{value:"<code>restartAll</code>",id:"restartall",level:3},{value:"<code>delete</code>",id:"delete",level:3},{value:"<code>pause</code>, <code>resume</code> and <code>abort</code>",id:"pause-resume-and-abort",level:3},{value:"<code>getAll</code>",id:"getall",level:3},{value:"<code>forceGarbageCollection</code>",id:"forcegarbagecollection",level:3},{value:"Dependencies",id:"dependencies",level:3},{value:"<code>DurableLog</code>",id:"durablelog",level:4},{value:"<code>KeyValueStore</code>",id:"keyvaluestore",level:4},{value:"<code>Configuration</code>",id:"configuration",level:4},{value:"<code>OperationExecutor</code>",id:"operationexecutor",level:4},{value:"<code>Serializer</code> and <code>Deserializer</code>",id:"serializer-and-deserializer",level:4},{value:"ZIO Flow Server",id:"zio-flow-server",level:2},{value:"Running the server",id:"running-the-server",level:3},{value:"Configuration",id:"configuration-1",level:3},{value:"HTTP retry policies",id:"http-retry-policies",level:4},{value:"REST API",id:"rest-api",level:3},{value:"<code>GET /healthcheck</code>",id:"get-healthcheck",level:4},{value:"<code>GET /metrics</code>",id:"get-metrics",level:4},{value:"<code>GET /templates</code>",id:"get-templates",level:4},{value:"<code>GET /templates/&lt;templateId&gt;</code>",id:"get-templatestemplateid",level:4},{value:"<code>PUT /templates/&lt;templateId&gt;</code>",id:"put-templatestemplateid",level:4},{value:"<code>DELETE /templates/&lt;templateId&gt;</code>",id:"delete-templatestemplateid",level:4},{value:"<code>POST /flows</code>",id:"post-flows",level:4},{value:"<code>GET /flows</code>",id:"get-flows",level:4},{value:"<code>GET /flows/&lt;flowId&gt;</code>",id:"get-flowsflowid",level:4},{value:"<code>DELETE /flows/&lt;flowId&gt;</code>",id:"delete-flowsflowid",level:4},{value:"<code>POST /flows/&lt;flowId&gt;/pause</code>",id:"post-flowsflowidpause",level:4},{value:"<code>POST /flows/&lt;flowId&gt;/resume</code>",id:"post-flowsflowidresume",level:4},{value:"<code>POST /flows/&lt;flowId&gt;/abort</code>",id:"post-flowsflowidabort",level:4},{value:"Metrics",id:"metrics",level:2},{value:"Custom operation executor",id:"custom-operation-executor",level:2}],d={toc:p},u="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"execution"},"Execution"),(0,i.kt)("p",null,"The data structures and operators in the ",(0,i.kt)("inlineCode",{parentName:"p"},"zio-flow")," library only ",(0,i.kt)("em",{parentName:"p"},"describe")," a ZIO Flow program. To execute them we need\na persistent executor configured with a chosen set of dependencies. Most of the executor implementation is in\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"zio-flow-runtime")," module, with some backend-specific extra modules discussed in the ",(0,i.kt)("a",{parentName:"p",href:"backends"},"backends")," section."),(0,i.kt)("p",null,"There are two main ways to execute a ZIO Flow program:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Embedding ",(0,i.kt)("inlineCode",{parentName:"li"},"zio-flow-runtime")," in your own application, using the ",(0,i.kt)("inlineCode",{parentName:"li"},"PersistentExecutor")," service"),(0,i.kt)("li",{parentName:"ul"},"Use the default ",(0,i.kt)("em",{parentName:"li"},"ZIO Flow Server")," which is an executable service application built on top of ",(0,i.kt)("inlineCode",{parentName:"li"},"zio-flow-runtime"))),(0,i.kt)("h2",{id:"embedding-the-persistent-executor"},"Embedding the persistent executor"),(0,i.kt)("p",null,"To embed the ZIO Flow executor in your own application, you need to add the following dependency:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio-flow-runtime" % "1.0.0-RC4"\n')),(0,i.kt)("p",null,"Then you can initialize the ",(0,i.kt)("inlineCode",{parentName:"p"},"PersistentExecutor")," service with the following method on its companion object:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def make(gcPeriod: Duration = 5.minutes): ZLayer[\n  DurableLog with\n    KeyValueStore with\n    Configuration with\n    OperationExecutor with\n    Serializer with\n    Deserializer, Nothing, ZFlowExecutor]\n")),(0,i.kt)("p",null,"This is a ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer")," creating a ",(0,i.kt)("inlineCode",{parentName:"p"},"ZFlowExecutor"),". Let's see first what this interface is capable of, then we'll see how to\ncreate the required dependencies."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ZFlowExecutor")," interface has the following methods:"),(0,i.kt)("h3",{id:"run"},(0,i.kt)("inlineCode",{parentName:"h3"},"run")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"run")," submits a flow to the executor, and waits until it completes. The failure/success of the flow is represented as\nthe failure/result of this ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," effect."),(0,i.kt)("p",null,"To make this work ZIO Flow needs a ",(0,i.kt)("inlineCode",{parentName:"p"},"Schema")," for both the error type and the result type. This is how the executor's\nresult can be converted to the expected type."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," method expects that the provided ",(0,i.kt)("inlineCode",{parentName:"p"},"ZFlow")," has no input requirements (it's ",(0,i.kt)("inlineCode",{parentName:"p"},"R")," parameter is ",(0,i.kt)("inlineCode",{parentName:"p"},"Any"),"). If you need\nto run a flow that requires an input, you can first use ",(0,i.kt)("inlineCode",{parentName:"p"},".provide")," on it to provide the input, and then run it."),(0,i.kt)("p",null,"Let's see an example, assuming that we have ",(0,i.kt)("inlineCode",{parentName:"p"},"ZFlowExecutor")," in the environment of our ZIO program:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.flow._\nimport zio.flow.runtime._\n\nval flow: ZFlow[Int, String, Int] = ZFlow.input[Int].flatMap { n =>\n  ZFlow.ifThenElse(n > 10)(ifTrue = ZFlow.succeed(1), ifFalse = ZFlow.fail("input is too low"))\n}\n\ndef program: ZIO[ZFlowExecutor, String, Int] =\n  ZFlowExecutor.run(FlowId("test1"), flow.provide(5))\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"FlowId")," is a unique identifier for ",(0,i.kt)("em",{parentName:"p"},"an execution")," of the flow. It is the caller's responsibility to generate a\nfresh identifier in case the flow has to be started from scratch. If a flow with the given identifier is already\nrunning, or it's persisted state is available, the execution of that flow will continue and the method will wait for the\nresult of that execution."),(0,i.kt)("h3",{id:"start-and-poll"},(0,i.kt)("inlineCode",{parentName:"h3"},"start")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"poll")),(0,i.kt)("p",null,"An alternative to ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," is to just ",(0,i.kt)("em",{parentName:"p"},"start")," the execution of a flow with the ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," method, without waiting for its\ncompletion. The running workflow's state can be later queries with ",(0,i.kt)("inlineCode",{parentName:"p"},"poll"),". The start method actually returns with\na ",(0,i.kt)("inlineCode",{parentName:"p"},"DurablePromise")," that can be directly used to wait for the result of the flow, but it is much simpler to use\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"poll")," method instead."),(0,i.kt)("p",null,"Another difference is that ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"poll")," does not use the flow's error and result types. The polled result\nrepresents both failures and errors as ",(0,i.kt)("inlineCode",{parentName:"p"},"DynamicValue")," values. This is a generic data type from the ",(0,i.kt)("inlineCode",{parentName:"p"},"zio-schema")," library\nthat can represent any value that has a ",(0,i.kt)("inlineCode",{parentName:"p"},"Schema"),". By owning such a ",(0,i.kt)("inlineCode",{parentName:"p"},"Schema")," you can convert back the dynamic value to\nits original type. You can learn more about how ",(0,i.kt)("inlineCode",{parentName:"p"},"DynamicValue")," is used in the internals of ZIO Flow in\nthe ",(0,i.kt)("a",{parentName:"p",href:"internals"},"internals")," page."),(0,i.kt)("h3",{id:"restartall"},(0,i.kt)("inlineCode",{parentName:"h3"},"restartAll")),(0,i.kt)("p",null,"When the executor is initialized, it is not running any flows, even if there were previously running flows persisted\nthat could be resumed. To start running these persisted flows, you can call the ",(0,i.kt)("inlineCode",{parentName:"p"},"restartAll")," method. This will load and\nimmediately resume every persisted ZIO Flow program that was previously running."),(0,i.kt)("p",null,"If you don't want this, you can resume the flows one by one if you know their ",(0,i.kt)("inlineCode",{parentName:"p"},"FlowId")," by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"start"),"."),(0,i.kt)("h3",{id:"delete"},(0,i.kt)("inlineCode",{parentName:"h3"},"delete")),(0,i.kt)("p",null,"Once a flow is completed, it's last persisted state, as well as it's results is still stored in the database, so\ncalling ",(0,i.kt)("inlineCode",{parentName:"p"},"poll")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"getAll")," can return information about it. The ",(0,i.kt)("inlineCode",{parentName:"p"},"delete")," method completely removes a ",(0,i.kt)("em",{parentName:"p"},"completed flow"),"\nfrom the executor's persisted state."),(0,i.kt)("h3",{id:"pause-resume-and-abort"},(0,i.kt)("inlineCode",{parentName:"h3"},"pause"),", ",(0,i.kt)("inlineCode",{parentName:"h3"},"resume")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"abort")),(0,i.kt)("p",null,"A running flow can be ",(0,i.kt)("em",{parentName:"p"},"paused")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"pause")," and resumed any time with ",(0,i.kt)("inlineCode",{parentName:"p"},"resume"),". A paused flow remains paused in case the\nexecutor is restarted and ",(0,i.kt)("inlineCode",{parentName:"p"},"restartAll")," is called."),(0,i.kt)("p",null,"A running (or paused) flow can be ",(0,i.kt)("em",{parentName:"p"},"aborted")," with the ",(0,i.kt)("inlineCode",{parentName:"p"},"abort")," method. An aborted flow's result is\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"ExecutorError.Interrupted")," error."),(0,i.kt)("h3",{id:"getall"},(0,i.kt)("inlineCode",{parentName:"h3"},"getAll")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"getAll")," method returns a ",(0,i.kt)("em",{parentName:"p"},"ZIO stream")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"FlowId")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"FlowStatus")," pairs, listing all the ZIO Flow programs the\nexecutor knows about. The ",(0,i.kt)("inlineCode",{parentName:"p"},"FlowStatus")," is an enumeration with the following values:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Running")," - the flow is currently running"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Paused")," - the flow is currently paused"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Suspended")," - the flow is currently suspended in a transaction, waiting for a variable to change"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Done")," - the flow finished running either with an error or with a success")),(0,i.kt)("h3",{id:"forcegarbagecollection"},(0,i.kt)("inlineCode",{parentName:"h3"},"forceGarbageCollection")),(0,i.kt)("p",null,"Garbage collection in the context of a persistent executor is not about releasing items from the ",(0,i.kt)("em",{parentName:"p"},"memory"),", but deleting\nold persistent state from the database backend. This is executed periodically by the executor, but you can also trigger\nit manually with the ",(0,i.kt)("inlineCode",{parentName:"p"},"forceGarbageCollection")," method."),(0,i.kt)("h3",{id:"dependencies"},"Dependencies"),(0,i.kt)("p",null,"The persistent executor layer depends on the following other ZIO ",(0,i.kt)("em",{parentName:"p"},"services"),":"),(0,i.kt)("h4",{id:"durablelog"},(0,i.kt)("inlineCode",{parentName:"h4"},"DurableLog")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"DurableLog")," is a persistent event log used for waiting for variables to change or promises to be completed. Currently\nthe only implementation is defined by the ",(0,i.kt)("inlineCode",{parentName:"p"},"DurableLog.layer")," layer and it depends on an ",(0,i.kt)("inlineCode",{parentName:"p"},"IndexedStore"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"IndexedStore"),"\nis provided by the ",(0,i.kt)("a",{parentName:"p",href:"backends"},"backend modules")," similar to",(0,i.kt)("inlineCode",{parentName:"p"},"KeyValueStore"),"."),(0,i.kt)("h4",{id:"keyvaluestore"},(0,i.kt)("inlineCode",{parentName:"h4"},"KeyValueStore")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"KeyValueStore")," is an interface for storing and retrieving information based on keys from a persistency solution. There\nare multiple implementations available in the ",(0,i.kt)("a",{parentName:"p",href:"backends"},"backend modules"),"."),(0,i.kt)("h4",{id:"configuration"},(0,i.kt)("inlineCode",{parentName:"h4"},"Configuration")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Configuration")," service stores the user defined configuration values, indexed by a ",(0,i.kt)("inlineCode",{parentName:"p"},"ConfigKey"),", that can be accessed\nby the ZIO Flow programs using ",(0,i.kt)("inlineCode",{parentName:"p"},"Remote.config"),". The following implementations are available:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Configuration.inMemory")," - stores the configuration in memory, useful mostly for testing. The initial state is empty."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Configuration.fromEnvironment")," - by providing a mapping from ",(0,i.kt)("inlineCode",{parentName:"li"},"ConfigKey")," to ",(0,i.kt)("em",{parentName:"li"},"system environment variable names"),", this\nimplementation provides configuration values for ZIO Flow programs directly from environment variables"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Configuration.fromConfig")," - uses ZIO's native configuration API to read configuration values from a given subsection\nof the provided configuration")),(0,i.kt)("h4",{id:"operationexecutor"},(0,i.kt)("inlineCode",{parentName:"h4"},"OperationExecutor")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"OperationExecutor")," service is responsible for executing ",(0,i.kt)("inlineCode",{parentName:"p"},"Operatotion"),"s, described on the ",(0,i.kt)("a",{parentName:"p",href:"activities"},"activities"),"\npage."),(0,i.kt)("p",null,"There are two built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"OperatorExecutor")," implementations in ZIO Flow:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DefaultOperationExecutor.layer")," constructs an executor that supports the ",(0,i.kt)("inlineCode",{parentName:"li"},"Operation.HTTP")," operations, implemented\nusing the ",(0,i.kt)("inlineCode",{parentName:"li"},"zio-http")," library"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MockedOperationExecutor")," is useful for testing flow, more information about it can be found on\nthe ",(0,i.kt)("a",{parentName:"li",href:"testing#mocking-operations"},"testing")," page")),(0,i.kt)("p",null,"The default operation executor requires you to provide HTTP retry policy configuration, that describes how each HTTP\nrequests are handling errors. More information about these policies can be found in the server configuration section\nbelow."),(0,i.kt)("h4",{id:"serializer-and-deserializer"},(0,i.kt)("inlineCode",{parentName:"h4"},"Serializer")," and ",(0,i.kt)("inlineCode",{parentName:"h4"},"Deserializer")),(0,i.kt)("p",null,"These two services define how the persisted data (both variables and flow state) is serialized and deserialized.\nSerialization is based on ",(0,i.kt)("em",{parentName:"p"},"codecs")," provided by the ",(0,i.kt)("inlineCode",{parentName:"p"},"zio-schema")," library."),(0,i.kt)("p",null,"Currently we provide two implementations for these services:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Serializer.json")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"Deserializer.json")," - uses JSON serialization"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Serializer.protobuf")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"Deserializer.protobuf")," - uses Protobuf serialization")),(0,i.kt)("h2",{id:"zio-flow-server"},"ZIO Flow Server"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"ZIO Flow Server")," is a ready to use executable server application that wraps the persistent executor and provides a (\nHOCON) file based configuration to set it up, and a REST API for running and querying flows."),(0,i.kt)("h3",{id:"running-the-server"},"Running the server"),(0,i.kt)("p",null,"There is no packaged executable of the server at the moment, but later we are planning to provide a ready to use docker\ncontainer."),(0,i.kt)("p",null,"Today to run the server the easiest way is to clone the repository and run:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"export ZIO_FLOW_SERVER_CONFIG=custom-config.conf\nsbt zioFlowServer/run\n")),(0,i.kt)("h3",{id:"configuration-1"},"Configuration"),(0,i.kt)("p",null,"The configuration file pointed by ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO_FLOW_SERVER_CONFIG")," is a ",(0,i.kt)("em",{parentName:"p"},"HOCON file"),"."),(0,i.kt)("p",null,"The file has the following sections and values:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Section"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"port")),(0,i.kt)("td",{parentName:"tr",align:null},"the port the server will listen on")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"key-value-store")),(0,i.kt)("td",{parentName:"tr",align:null},"selects the backend to use for ",(0,i.kt)("em",{parentName:"td"},"key value store"),", can be either ",(0,i.kt)("inlineCode",{parentName:"td"},"rocksdb"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"cassandra"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"dynamodb")," or ",(0,i.kt)("inlineCode",{parentName:"td"},"in-memory"),". See the ",(0,i.kt)("a",{parentName:"td",href:"backends"},"backends")," page for more information. Currently the ",(0,i.kt)("inlineCode",{parentName:"td"},"key-value-store")," is also used to store the ",(0,i.kt)("em",{parentName:"td"},"flow templates")," (discussed below). This is expected to move to its own configuration key in next versions.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"indexed-store")),(0,i.kt)("td",{parentName:"tr",align:null},"selects the backend to use for ",(0,i.kt)("em",{parentName:"td"},"indexed store"),", most of the time it should be the same as ",(0,i.kt)("inlineCode",{parentName:"td"},"key-value-store"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"metrics.interval")),(0,i.kt)("td",{parentName:"tr",align:null},"defines the interval for collecting internal metrics")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"serialization-format")),(0,i.kt)("td",{parentName:"tr",align:null},"can be either ",(0,i.kt)("inlineCode",{parentName:"td"},"json")," or ",(0,i.kt)("inlineCode",{parentName:"td"},"protobuf"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"gc-period")),(0,i.kt)("td",{parentName:"tr",align:null},"the interval")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"flow-configuration")),(0,i.kt)("td",{parentName:"tr",align:null},"a list of key-value pairs of user-defined configuration provided to flows via ",(0,i.kt)("inlineCode",{parentName:"td"},"Remote.config"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"policies")),(0,i.kt)("td",{parentName:"tr",align:null},"definition of HTTP retry policies, explained in details below")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"rocksdb-key-value-store")),(0,i.kt)("td",{parentName:"tr",align:null},"configuration for the RocksDB key value store, if it was selected by ",(0,i.kt)("inlineCode",{parentName:"td"},"key-value-store"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"rocksdb-indexed-store")),(0,i.kt)("td",{parentName:"tr",align:null},"configuration for the RocksDB indexed store, if it was selected by ",(0,i.kt)("inlineCode",{parentName:"td"},"indexed-store"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"cassandra-key-value-store")),(0,i.kt)("td",{parentName:"tr",align:null},"configuration for the Cassandra key value store, if it was selected by ",(0,i.kt)("inlineCode",{parentName:"td"},"key-value-store"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"cassandra-indexed-store")),(0,i.kt)("td",{parentName:"tr",align:null},"configuration for the Cassandra indexed store, if it was selected by ",(0,i.kt)("inlineCode",{parentName:"td"},"indexed-store"))))),(0,i.kt)("p",null,"For configuration of the ",(0,i.kt)("em",{parentName:"p"},"DynamoDb store"),", check the documentation of\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://zio.dev/zio-aws/configuration"},"zio-aws library"),"."),(0,i.kt)("h4",{id:"http-retry-policies"},"HTTP retry policies"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"policies.http")," node contains two sub nodes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"default")," is the default policy for all HTTP requests that are not customized by the ",(0,i.kt)("inlineCode",{parentName:"li"},"per-host")," settings"),(0,i.kt)("li",{parentName:"ul"},"Items in ",(0,i.kt)("inlineCode",{parentName:"li"},"per-host")," can override the default settings based on the request's host name")),(0,i.kt)("p",null,"For each host (and the default settings) you can define the following settings:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max-parallel-request-count")," is the maximum number of parallel requests that can be sent to the host"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"host-override")," should only be used in the ",(0,i.kt)("inlineCode",{parentName:"li"},"per-host")," configurations and it allows you to change the host name of the\nrequests"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"retry-policies")," is a list of retry policies, described below"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"circuit-breaker-policy")," is an optional node describing how to reset the ",(0,i.kt)("em",{parentName:"li"},"circuit breaker")," for the host after it gets\nopened"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"timeout")," is the maximum duration a request can take before get cancelled")),(0,i.kt)("p",null,"Each element in ",(0,i.kt)("inlineCode",{parentName:"p"},"retry-policies")," is a configuration object with the following properties:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"condition")," specifies the condition when this specific retry policy should be used. The following condition types are\nsupported:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"always")," defines a retry policy that is going to match ",(0,i.kt)("em",{parentName:"li"},"all")," requests"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"for-specific-status")," selects a single specific HTTP status code"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"for-4xx")," defines a retry policy for cases when the server responded with any HTTP status code between 400-499"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"for-5xx")," defines a retry policy for cases when the server responded with any HTTP status code between 500-599"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"open-circuit-breaker")," defines a retry policy for the case when a request is blocked by an open ",(0,i.kt)("em",{parentName:"li"},"circuit breaker")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"or")," combines two conditions, defined in the ",(0,i.kt)("inlineCode",{parentName:"li"},"first")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"second")," sub nodes")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"retry-policy")," defines how to retry the request; it is the same configuration structure as the one used\nfor ",(0,i.kt)("inlineCode",{parentName:"p"},"circuit-breaker-policy"),", and we are going to define it later."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"break-circuit")," is a boolean option. If it is ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", when the condition of this retry policy is triggered, it will not\nonly retry the request but also report this as a failure for the ",(0,i.kt)("em",{parentName:"p"},"circuit breaker"),". The circuit breaker will open the\ncircuit, making all further requests fail (with the condition ",(0,i.kt)("inlineCode",{parentName:"p"},"open-circuit-breaker"),") for a given period."),(0,i.kt)("p",null,"For both the ",(0,i.kt)("inlineCode",{parentName:"p"},"retry-polcy")," of each retry policy and for the ",(0,i.kt)("inlineCode",{parentName:"p"},"circuit-breaker-policy")," describing the resetting behavior\nof the circuit breaker the configuration structure looks the same:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fail-after")," defines the maximum number of retries, or the maximum elapsed time spent for retries"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"repetition")," defines how much time elapses between retries. it can be either a ",(0,i.kt)("inlineCode",{parentName:"li"},"fixed")," time interval, or\nan ",(0,i.kt)("inlineCode",{parentName:"li"},"exponential")," one"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"jitter")," is a boolean configuration enabling some jittering for these configured intervals")),(0,i.kt)("h3",{id:"rest-api"},"REST API"),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"ZIO Flow Server")," provides a HTTP REST API for working with ZIO Flow programs. This section defines all the\navailable endpoints."),(0,i.kt)("h4",{id:"get-healthcheck"},(0,i.kt)("inlineCode",{parentName:"h4"},"GET /healthcheck")),(0,i.kt)("p",null,"Simple healthcheck endpoint to check that ZIO Flow server is running."),(0,i.kt)("h4",{id:"get-metrics"},(0,i.kt)("inlineCode",{parentName:"h4"},"GET /metrics")),(0,i.kt)("p",null,"Prometheus metrics. The list of available metrics is defined in the ",(0,i.kt)("a",{parentName:"p",href:"#metrics"},"metrics section")),(0,i.kt)("h4",{id:"get-templates"},(0,i.kt)("inlineCode",{parentName:"h4"},"GET /templates")),(0,i.kt)("p",null,"Get all the available ",(0,i.kt)("em",{parentName:"p"},"templates")," registered in the server. A ",(0,i.kt)("em",{parentName:"p"},"template")," in ZIO Flow server is a stored ZIO Flow program\nthat optionally can have an ",(0,i.kt)("em",{parentName:"p"},"input parameter")," as well. By storing these on the server they get an associated ",(0,i.kt)("em",{parentName:"p"},"template\nID")," and you can refer to this ID when starting a new flow instead of sending the whole serialized ZIO Flow program every\ntime."),(0,i.kt)("p",null,"The response JSON has the following structure:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "entries": [\n    {\n      "templateId": "xyz",\n      "template": {\n        "flow": {\n          ...\n        }\n        "inputSchema": {\n          ...\n        }\n      }\n    },\n    ...\n  ]\n}\n')),(0,i.kt)("h4",{id:"get-templatestemplateid"},(0,i.kt)("inlineCode",{parentName:"h4"},"GET /templates/<templateId>")),(0,i.kt)("p",null,"Gets a single stored ",(0,i.kt)("em",{parentName:"p"},"flow template")," by its identifier."),(0,i.kt)("h4",{id:"put-templatestemplateid"},(0,i.kt)("inlineCode",{parentName:"h4"},"PUT /templates/<templateId>")),(0,i.kt)("p",null,"Stores a new ",(0,i.kt)("em",{parentName:"p"},"flow template")," by providing an identifier and posting the flow and input schema in the request's body."),(0,i.kt)("h4",{id:"delete-templatestemplateid"},(0,i.kt)("inlineCode",{parentName:"h4"},"DELETE /templates/<templateId>")),(0,i.kt)("p",null,"Deletes a ",(0,i.kt)("em",{parentName:"p"},"flow template")," that was previously stored by the above defined ",(0,i.kt)("inlineCode",{parentName:"p"},"PUT")," by its identifier."),(0,i.kt)("h4",{id:"post-flows"},(0,i.kt)("inlineCode",{parentName:"h4"},"POST /flows")),(0,i.kt)("p",null,"Start executing a new ",(0,i.kt)("em",{parentName:"p"},"ZIO Flow program"),"."),(0,i.kt)("p",null,"The following JSON examples show the possibilities of this endpoint:"),(0,i.kt)("p",null,"Starting execution of a ZIO Flow that has no parameters (",(0,i.kt)("inlineCode",{parentName:"p"},"ZFlow.succeed(1)"),") :"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "Flow": {\n    "flow": {\n      "Return": {\n        "Literal": {\n          "Int": 1\n        }\n      }\n    }\n  }\n}\n')),(0,i.kt)("p",null,"Starting execution of a ZIO Flow that has a ",(0,i.kt)("em",{parentName:"p"},"required input parameter")," by providing this parameter's type (schema) and\nthe value as well (",(0,i.kt)("inlineCode",{parentName:"p"},"ZFlow.input[Int]"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "FlowWithParameter": {\n    "flow": {\n      "Input": {}\n    },\n    "schema": {\n      "Other": {\n        "toAst": {\n          "Value": {\n            "valueType": "int",\n            "path": [],\n            "optional": false\n          }\n        }\n      }\n    },\n    "value": 1\n  }\n}\n')),(0,i.kt)("p",null,"Starting a ZIO Flow program that is stored as a ",(0,i.kt)("em",{parentName:"p"},"flow template")," and does not require any parameters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "Template": {\n    "templateId": "template1"\n  }\n}\n')),(0,i.kt)("p",null,"Starting a ZIO Flow program that is stored as a ",(0,i.kt)("em",{parentName:"p"},"flow template")," and requires a parameter as well:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "TemplateWithParameter": {\n    "templateId": "template2",\n    "value": 1\n  }\n}\n')),(0,i.kt)("p",null,"The response JSON contains a field called ",(0,i.kt)("inlineCode",{parentName:"p"},"flowId")," containing the started flow's identifier. It can be used to poll\nfor the result of the running flow, as well as pausing, resuming or aborting it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "flowId": "xyz"\n}\n')),(0,i.kt)("h4",{id:"get-flows"},(0,i.kt)("inlineCode",{parentName:"h4"},"GET /flows")),(0,i.kt)("p",null,"Gets a list of all the flows handled by the server's executor, together with their current status."),(0,i.kt)("p",null,"The response is a mapping from ",(0,i.kt)("em",{parentName:"p"},"flow ID")," to ",(0,i.kt)("em",{parentName:"p"},"status"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "flow1": "Running",\n  "flow2": "Paused",\n  "flow3": "Done",\n  "flow4": "Suspended"\n}\n')),(0,i.kt)("p",null,"(in reality the flow IDs are UUIDs)"),(0,i.kt)("h4",{id:"get-flowsflowid"},(0,i.kt)("inlineCode",{parentName:"h4"},"GET /flows/<flowId>")),(0,i.kt)("p",null,"Polls the status of a given flow. The following examples demonstrate the possible response JSONs for this request:"),(0,i.kt)("p",null,"When the flow is still running:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "Running": {}\n}\n')),(0,i.kt)("p",null,"If the flow died with an internal error, or was ",(0,i.kt)("em",{parentName:"p"},"aborted")," (could be any other ",(0,i.kt)("inlineCode",{parentName:"p"},"ExecutionError"),", not just ",(0,i.kt)("inlineCode",{parentName:"p"},"Interrupted"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "Died": {\n    "value": {\n      "Interrupted": {}\n    }\n  }\n}\n')),(0,i.kt)("p",null,"If the flow finished running and succeeded with a value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "Succeeded": {\n    "value": 1\n  }\n}\n')),(0,i.kt)("p",null,"If the flow finished running and failed with a value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "Failed": {\n    "value": "flow failed!"\n  }\n}\n')),(0,i.kt)("h4",{id:"delete-flowsflowid"},(0,i.kt)("inlineCode",{parentName:"h4"},"DELETE /flows/<flowId>")),(0,i.kt)("p",null,"Deletes an already completed ",(0,i.kt)("em",{parentName:"p"},"flow")," from the executor."),(0,i.kt)("h4",{id:"post-flowsflowidpause"},(0,i.kt)("inlineCode",{parentName:"h4"},"POST /flows/<flowId>/pause")),(0,i.kt)("p",null,"Pauses a running ",(0,i.kt)("em",{parentName:"p"},"flow"),"."),(0,i.kt)("h4",{id:"post-flowsflowidresume"},(0,i.kt)("inlineCode",{parentName:"h4"},"POST /flows/<flowId>/resume")),(0,i.kt)("p",null,"Resumes a previously paused ",(0,i.kt)("em",{parentName:"p"},"flow"),"."),(0,i.kt)("h4",{id:"post-flowsflowidabort"},(0,i.kt)("inlineCode",{parentName:"h4"},"POST /flows/<flowId>/abort")),(0,i.kt)("p",null,"Aborts a running flow."),(0,i.kt)("h2",{id:"metrics"},"Metrics"),(0,i.kt)("p",null,"Many components of ZIO Flow report ",(0,i.kt)("em",{parentName:"p"},"metrics")," using ZIO's built-in metrics API. ",(0,i.kt)("em",{parentName:"p"},"ZIO Flow Server")," exposes these metrics\nfor Prometheus via the ",(0,i.kt)("inlineCode",{parentName:"p"},"/metrics")," endpoint. In case of using the executor embedded in your own application, the metrics\ncan be sent to any metrics backend that supports the ZIO metrics API."),(0,i.kt)("p",null,"The following list contains all the metrics reported by various components of the ZIO Flow runtime:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_remote_evals")," is a counter for (",(0,i.kt)("em",{parentName:"li"},"tracked Remotes"),")","[remote#metrics]"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_remote_eval_time_ms")," is a histogram for ",(0,i.kt)("em",{parentName:"li"},"tracked Remotes")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_started_total")," is a counter incremented every time a flow is started executing (either new or restarted)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_active_flows")," is a gauge containing the actual number of running or suspended flows"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_operations_total")," is a counter for each primitive ",(0,i.kt)("inlineCode",{parentName:"li"},"ZFlow")," operation that was executed"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_transactions_total")," is a counter for the number of committed, failed or retried transactions"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_finished_flows_total")," is a counter increased when a flow finishes with either success, failure or death"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_executor_error_total")," is a counter for different executor errors"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_state_size_bytes")," is a histogram for the serialized workflow state snapshots in bytes"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_variable_access_total")," is a counter increased when a remote variable is accessed (read, write or delete)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_variable_size_bytes")," is a histogram of the serialized size of remote variables in bytes"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_finished_flow_age_ms")," is a histogram of the duration between submitting the workflow and completing it"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_total_execution_time_ms")," is a histogram of the total time a workflow was in either running or suspended state\nduring its life"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_suspended_time_ms")," is a histogram of time fragments a workflow spends in suspended state"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_gc_time_ms")," is a histogram of the time a full persistent garbage collection run takes"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_gc_deletion")," is a counter for the number of remote variables deleted by the garbage collector"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_gc")," is a counter for the number of persistent garbage collector runs"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_http_responses_total")," is a counter for the number of HTTP operations performed"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_http_response_time_ms")," is a histogram of the HTTP operation response times"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_http_failed_requests_total")," is a counter for the number of failed HTTP requests"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zioflow_http_retried_requests_total")," is a counter for the number of retried HTTP requests per host- ``")),(0,i.kt)("p",null,"The ZIO Flow Server also reports the ",(0,i.kt)("em",{parentName:"p"},"default JVM metrics")," provided by ZIO Core."),(0,i.kt)("h2",{id:"custom-operation-executor"},"Custom operation executor"),(0,i.kt)("p",null,"Writing a custom implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"OperationExecutor")," is the intended way to extend ZIO Flow with custom ways to\ninteract with the outside world. An ",(0,i.kt)("inlineCode",{parentName:"p"},"OperationExecutor")," gets an input value and an ",(0,i.kt)("inlineCode",{parentName:"p"},"Operation[Input, Output]")," value, and\nit has to provide a ",(0,i.kt)("em",{parentName:"p"},"ZIO effect")," that produces a ",(0,i.kt)("inlineCode",{parentName:"p"},"Result")," or fails with an ",(0,i.kt)("inlineCode",{parentName:"p"},"ActivityError"),"."),(0,i.kt)("p",null,"As ",(0,i.kt)("inlineCode",{parentName:"p"},"Operation")," is a sealed trait, custom operations are encoded by ",(0,i.kt)("inlineCode",{parentName:"p"},"Operation.Custom")," with a payload represented by\na ",(0,i.kt)("inlineCode",{parentName:"p"},"DynamicValue"),". The payload can be converted to ",(0,i.kt)("inlineCode",{parentName:"p"},"DynamicValue")," using a ",(0,i.kt)("inlineCode",{parentName:"p"},"Schema"),"."),(0,i.kt)("p",null,"The following example shows how to implement a custom operation that gets a static string (serialized as part of the\noperation) and a dynamic string from the operation's input, and pushes a concatenated string to a queue provided for the\noperation executor:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.schema.{DeriveSchema, DynamicValue, Schema, TypeId}\n\nfinal case class CustomOp(prefix: String)\n\nobject CustomOp {\n  val typeId: TypeId = TypeId.parse("zio.flow.runtime.internal.executor.CustomOperationExecutorSpec.CustomOp")\n  implicit val schema: Schema[CustomOp] = DeriveSchema.gen[CustomOp]\n}\n\n/** Helper for constructing the custom operation */\ndef customOp(prefix: String): Operation[String, Unit] =\n  Operation.Custom(CustomOp.typeId, DynamicValue(CustomOp(prefix)), Schema[String], Schema[Unit])\n\n/** Example usage of the custom operation in an activity */\ndef customActivity(prefix: String): Activity[String, Unit] =\n  Activity(\n    "custom1",\n    "test activity using custom operation",\n    customOp(prefix),\n    Activity.checkNotSupported,\n    Activity.compensateNotSupported\n  )\n\n/** Example implementation of the custom operation executor */\nfinal class CustomOperationExecutor(queue: Queue[String]) extends OperationExecutor {\n  override def execute[Input, Result](\n    input: Input,\n    operation: Operation[Input, Result]\n  ): ZIO[RemoteContext, ActivityError, Result] =\n    operation match {\n      case Operation.Custom(typeId, operation, _, _) if typeId == CustomOp.typeId =>\n        for {\n          op <-\n            ZIO.fromEither(operation.toTypedValue(CustomOp.schema)).mapError(failure => ActivityError(failure, None))\n          _ <- queue.offer(op.prefix + input.asInstanceOf[String])\n        } yield ().asInstanceOf[Result]\n      case _ =>\n        ZIO.fail(ActivityError("Unsupported operation", None))\n    }\n}\n')))}m.isMDXComponent=!0}}]);