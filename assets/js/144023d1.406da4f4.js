"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[19423],{3905:(e,n,a)=>{a.d(n,{Zo:()=>d,kt:()=>h});var t=a(67294);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function i(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=t.createContext({}),c=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},d=function(e){var n=c(e.components);return t.createElement(s.Provider,{value:n},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=c(a),m=r,h=p["".concat(s,".").concat(m)]||p[m]||u[m]||o;return a?t.createElement(h,l(l({ref:n},d),{},{components:a})):t.createElement(h,l({ref:n},d))}));function h(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=a.length,l=new Array(o);l[0]=m;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[p]="string"==typeof e?e:r,l[1]=i;for(var c=2;c<o;c++)l[c]=a[c];return t.createElement.apply(null,l)}return t.createElement.apply(null,a)}m.displayName="MDXCreateElement"},50302:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var t=a(87462),r=(a(67294),a(3905));const o={id:"reloadable-services",title:"Introduction to Reloadable Services",sidebar_label:"Reloadable Services"},l=void 0,i={unversionedId:"reference/service-pattern/reloadable-services",id:"reference/service-pattern/reloadable-services",title:"Introduction to Reloadable Services",description:"Reloadable services are a feature in ZIO that allow us to reload services when necessary. With ZIO When we reload a service, it will automatically deallocate any resources that the service was using. This includes any open files, network connections, or database connections. ZIO will then reallocate new resources for the new service. This process of deallocation and reallocation is handled automatically by ZIO, so you don't need to worry about it.",source:"@site/docs/reference/service-pattern/reloadable-services.md",sourceDirName:"reference/service-pattern",slug:"/reference/service-pattern/reloadable-services",permalink:"/reference/service-pattern/reloadable-services",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/service-pattern/reloadable-services.md",tags:[],version:"current",frontMatter:{id:"reloadable-services",title:"Introduction to Reloadable Services",sidebar_label:"Reloadable Services"},sidebar:"reference-sidebar",previous:{title:"Three Laws of ZIO Environment",permalink:"/reference/service-pattern/the-three-laws-of-zio-environment"},next:{title:"Introduction to Dependency Injection in ZIO",permalink:"/reference/di/"}},s={},c=[{value:"1. The <code>Reloadable</code> Service",id:"1-the-reloadable-service",level:2},{value:"Reloadable Operations",id:"reloadable-operations",level:3},{value:"Creating Reloadable Services",id:"creating-reloadable-services",level:3},{value:"2. The <code>ServiceReloader</code> Service",id:"2-the-servicereloader-service",level:2},{value:"Conclusion",id:"conclusion",level:2}],d={toc:c},p="wrapper";function u(e){let{components:n,...a}=e;return(0,r.kt)(p,(0,t.Z)({},d,a,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reloadable services are a feature in ZIO that allow us to reload services when necessary. With ZIO When we reload a service, it will automatically deallocate any resources that the service was using. This includes any open files, network connections, or database connections. ZIO will then reallocate new resources for the new service. This process of deallocation and reallocation is handled automatically by ZIO, so you don't need to worry about it. "),(0,r.kt)("p",null,"Here are some examples of how we might use reloadable services:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Config changes"),": If we make a change to the configuration of a service, we might want to reload the service so that it can pick up the new configuration."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Scheduled reloads"),": We might want to reload a service on a regular interval, such as every n minutes. This can be useful for services that need to be refreshed on a regular basis."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Reload on change on Schema"),": Assume we have a service that reads data from a database. If we make a change to the database schema, we might want to reload the service so that it can pick up the new schema. ")),(0,r.kt)("p",null,"This article explores two methods for implementing reloadable services in ZIO:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The first method is a non-trivial method that uses the ",(0,r.kt)("inlineCode",{parentName:"li"},"Reloadable")," service, which requires some boilerplate code."),(0,r.kt)("li",{parentName:"ol"},"The second method is a simpler method introduced by ",(0,r.kt)("inlineCode",{parentName:"li"},"zio-macros")," that uses the ",(0,r.kt)("inlineCode",{parentName:"li"},"ServiceReloader")," service.")),(0,r.kt)("p",null,"Before going into further detail, through this article whenever we use ",(0,r.kt)("inlineCode",{parentName:"p"},"Counter")," class, we refere to this source code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nimport java.util.UUID\n\ntrait Counter {\n  def increment: UIO[Unit]\n  def get: UIO[Int]\n}\n\nobject Counter {\n  val increment: ZIO[Counter, Nothing, Unit] =\n    ZIO.serviceWithZIO[Counter](_.increment)\n\n  val get: ZIO[Counter, Nothing, RuntimeFlags] =\n    ZIO.serviceWithZIO[Counter](_.get)\n\n  val live: ZLayer[Any, Nothing, Counter] = ZLayer.scoped {\n    for {\n      id <- Ref.make(UUID.randomUUID())\n      ref <- Ref.make(0)\n      service = CounterLive(id, ref)\n      _ <- service.acquire\n      _ <- ZIO.addFinalizer(service.release)\n    } yield service\n  }\n}\n\nfinal case class CounterLive(id: Ref[UUID], ref: Ref[Int]) extends Counter {\n  def acquire: UIO[Unit] = {\n    Random.nextUUID\n      .flatMap(n => id.set(n) *> ZIO.debug(s"Acquired counter $n"))\n  }\n\n  def increment: UIO[Unit] =\n    ref.update(_ + 1)\n\n  def get: UIO[Int] =\n    ref.get\n\n  def release: UIO[Unit] =\n    id.get.flatMap(id => ZIO.debug(s"Released counter $id"))\n}\n')),(0,r.kt)("h2",{id:"1-the-reloadable-service"},"1. The ",(0,r.kt)("inlineCode",{parentName:"h2"},"Reloadable")," Service"),(0,r.kt)("p",null,"In line with the principles of typical ZIO services, reloadable services are specifically crafted to operate seamlessly within the ZIO environment. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable[Service]")," data type serves as a wrapper around any reloadable service. This data type encompasses two fundamental methods: ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"reload"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," method facilitates the retrieval of the underlying service managed by the ",(0,r.kt)("inlineCode",{parentName:"p"},"ScopedRef"),", while the ",(0,r.kt)("inlineCode",{parentName:"p"},"reload")," method enables the reloading of the service."),(0,r.kt)("h3",{id:"reloadable-operations"},"Reloadable Operations"),(0,r.kt)("p",null,"Before diving into further details, let's begin by examining the definition of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable")," class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Reloadable[Service](scopedRef: ScopedRef[Service], reload: IO[Any, Unit]) {\n  def get: UIO[Service] = scopedRef.get\n  def reloadFork: UIO[Unit] = reload.ignoreLogged.forkDaemon.unit\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable")," service encapsulates a ",(0,r.kt)("a",{parentName:"p",href:"/reference/resource/scopedref"},"scoped reference")," to a service and provides methods to retrieve the service value (",(0,r.kt)("inlineCode",{parentName:"p"},"get"),") and trigger service reloading (",(0,r.kt)("inlineCode",{parentName:"p"},"reload")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"reloadFork"),")."),(0,r.kt)("p",null,"The two fundamental operations of ",(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable")," are as follows:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable#get")," - By calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," method, we can retrieve the underlying service and interact with it directly."),(0,r.kt)("p",{parentName:"li"},"For example, let's consider that we have acquired the ",(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable[Counter]")," service from the ZIO environment using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.service[Reloadable[Counter]]")," accessor. We can then use the ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," method to obtain the Counter instance and directly perform operations on it:"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval app: ZIO[Reloadable[Counter], Nothing, Unit] =\n  for {\n    reloadable <- ZIO.service[Reloadable[Counter]]\n    counter    <- reloadable.get \n  } yield ()\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"Reloadable#reload")),"\u2014 This operation involves acquiring a new service and releasing the old one, thereby enabling the reloading of the service:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval app: ZIO[Reloadable[Counter], Any, Unit] =\n  for {\n    reloadable <- ZIO.service[Reloadable[Counter]]\n    counter    <- reloadable.get\n    _          <- counter.increment\n    _          <- counter.increment\n    _          <- counter.increment\n    _          <- counter.get.debug("Counter value is")\n    _          <- reloadable.reload\n    counter    <- reloadable.get\n    _          <- counter.increment\n    _          <- counter.increment\n    _          <- counter.get.debug("Counter value is")\n  } yield ()\n')),(0,r.kt)("h3",{id:"creating-reloadable-services"},"Creating Reloadable Services"),(0,r.kt)("p",null,"Up to this point, we have explored the process of acquiring reloadable services from the ZIO environment and interacting with them. However, these workflows cannot be executed without fulfilling their requirements. For instance, in the previous example, the type of our workflow is ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO[Reloadable[Counter], Any, Unit]"),". This implies that we need to provide a layer of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable[Counter]"),". It is necessary to create reloadable services and ",(0,r.kt)("inlineCode",{parentName:"p"},"provide")," them as a ",(0,r.kt)("inlineCode",{parentName:"p"},"ZLayer"),". In this section, we will delve into the creation of such services."),(0,r.kt)("p",null,"First, let's explore the definition of the two primary constructors for Reloadable:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"object Reloadable {\n  def manual[In, E, Out](\n      layer: ZLayer[In, E, Out]\n    ): ZLayer[In, E, Reloadable[Out]] = ???\n    \n  def auto[In, E, Out](\n      layer: ZLayer[In, E, Out],\n      schedule: Schedule[In, Any, Any]\n    ): ZLayer[In, E, Reloadable[Out]] = ???\n}\n")),(0,r.kt)("p",null,"There are two fundamental approaches to creating reloadable services:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"Reloadable.manual"))," - Using the manual constructor, we can create a reloadable service and subsequently reload it whenever needed by explicitly invoking the ",(0,r.kt)("inlineCode",{parentName:"li"},"Reloadable#reload")," method. This method accepts a layer of type ",(0,r.kt)("inlineCode",{parentName:"li"},"ZLayer[In, E, Out]")," and returns a layer of type ",(0,r.kt)("inlineCode",{parentName:"li"},"ZLayer[In, E, Reloadable[Out]]"),".")),(0,r.kt)("p",null,"Continuing the previous example, assume we have written the ",(0,r.kt)("inlineCode",{parentName:"p"},"Counter.live")," as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject Counter {\n  val live: ZLayer[Any, Nothing, Counter] = ZLayer.scoped {\n    for {\n      id <- Ref.make(UUID.randomUUID())\n      ref <- Ref.make(0)\n      service = CounterLive(id, ref)\n      _ <- service.acquire\n      _ <- ZIO.addFinalizer(service.release)\n    } yield service\n  }\n}\n")),(0,r.kt)("p",null,"We can easily convert that to reloadable layer using ",(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable.manual"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"object Counter {\n  val live: ZLayer[Any, Nothing, Counter] = ???\n  \n  val reloadable: ZLayer[Any, Nothing, Reloadable[Counter]] = \n    Reloadable.manual(live)\n}\n")),(0,r.kt)("p",null,"Alternatively, we can directly utilize the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZLayer#reloadableManual")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"object Counter {\n  val live: ZLayer[Any, Nothing, Counter] = ???\n\n  val reloadable: ZLayer[Any, Nothing, Reloadable[Counter]] =\n    live.reloadableManual\n}\n")),(0,r.kt)("p",null,"Now we can ",(0,r.kt)("inlineCode",{parentName:"p"},"provide")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"Counter.reloadable")," layer to the app workflow and execute the application:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nimport java.util.UUID\n\nobject ReloadableExample extends ZIOAppDefault {\n  val app: ZIO[Reloadable[Counter], Any, Unit] =\n    for {\n      reloadable <- ZIO.service[Reloadable[Counter]]\n      counter <- reloadable.get\n      _ <- counter.increment\n      _ <- counter.increment\n      _ <- counter.increment\n      _ <- counter.get.debug("Counter value is")\n      _ <- reloadable.reload *> ZIO.sleep(1.second)\n      counter <- reloadable.get\n      _ <- counter.increment\n      _ <- counter.increment\n      _ <- counter.get.debug("Counter value is")\n    } yield ()\n\n  def run = app.provide(Counter.reloadable)\n}\n')),(0,r.kt)("p",null,"This program defines an application that operates on a reloadable counter service (",(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable[Counter]"),"). It obtains the ",(0,r.kt)("inlineCode",{parentName:"p"},"Counter")," service from the reloadable service, performs three ",(0,r.kt)("inlineCode",{parentName:"p"},"increment")," operations, displays its current value, proceeds to ",(0,r.kt)("inlineCode",{parentName:"p"},"reload")," the counter service, performs two additional increment operations, and finally displays its value once again. Therefore, the expected output would be as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"Acquired counter d04519a3-7332-43ca-bc86-f61fbaf2e3d6\nCounter value: 3\nReleased counter d04519a3-7332-43ca-bc86-f61fbaf2e3d6\nAcquired counter bc66ba00-0b50-4e6e-9f60-c38b6e140a82\nCounter value: 2\nReleased counter bc66ba00-0b50-4e6e-9f60-c38b6e140a82\n")),(0,r.kt)("p",null,"Observing the behavior, we notice that the service undergoes reloading, causing the counter to reset and begin incrementing from zero once more."),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"Reloadable.auto"))," - By utilizing this constructor, we can provide a schedule alongside a layer of type ",(0,r.kt)("inlineCode",{parentName:"li"},"ZLayer[In, E, Out]"),", resulting in a layer of reloadable service that will be automatically reloaded based on the specified schedule. Additionally, there is another constructor called ",(0,r.kt)("inlineCode",{parentName:"li"},"Reloadable.autoFromConfig")," which can be used to extract the schedule from the ZIO environment.")),(0,r.kt)("p",null,"Let's change the previous example to reload the Counter service automatically every 5 second. First we need to create auto reloadable service:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject Counter {\n  val live: ZLayer[Any, Nothing, Counter] = ???\n  \n  val autoReloadable: ZLayer[Any, Nothing, Reloadable[Counter]] =\n    Reloadable.auto(live, Schedule.fixed(5.seconds))\n}\n")),(0,r.kt)("p",null,"Or we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"ZLayer#reloadableAuto")," to convert a layer to auto reloadable service:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject Counter {\n  val live: ZLayer[Any, Nothing, Counter] = ???\n  \n  val autoReloadable: ZLayer[Any, Nothing, Reloadable[Counter]] =\n    live.reloadableAuto(Schedule.fixed(5.seconds))\n}\n")),(0,r.kt)("p",null,"Finally, we don't require to manually execute ",(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable#reload")," and the service will be reloaded every 5 second:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport java.util.UUID\n\nobject AutoReloadableExample extends ZIOAppDefault {\n  val app: ZIO[Reloadable[Counter], Any, Unit] =\n    for {\n      reloadable <- ZIO.service[Reloadable[Counter]]\n      counter <- reloadable.get\n      _ <- counter.increment\n      _ <- counter.increment\n      _ <- counter.increment\n      _ <- counter.get.debug("Counter value is")\n      _ <- ZIO.sleep(6.second)\n      counter <- reloadable.get // getting reloadable service from environment\n      _ <- counter.increment\n      _ <- counter.increment\n      _ <- counter.get.debug("Counter value is")\n    } yield ()\n\n  def run = app.provide(Counter.autoReloadable)\n}\n')),(0,r.kt)("h2",{id:"2-the-servicereloader-service"},"2. The ",(0,r.kt)("inlineCode",{parentName:"h2"},"ServiceReloader")," Service"),(0,r.kt)("p",null,"Please note that in the previous example, there was no need for manual service reloading. However, we still had to manually retrieve the reloadable service from the environment using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.service[Reloadable[Counter]]")," and then access the ",(0,r.kt)("inlineCode",{parentName:"p"},"Counter")," service from the reloadable counter service. This approach involves some boilerplate code and indirection. We aim to adopt an approach that eliminates the necessity of ",(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable[Service]")," from the environment and instead directly requires the ",(0,r.kt)("inlineCode",{parentName:"p"},"Service")," from the environment."),(0,r.kt)("p",null,"To address this issue, the ",(0,r.kt)("inlineCode",{parentName:"p"},"ServiceReloader")," has been developed as a solution. It is part of the ",(0,r.kt)("inlineCode",{parentName:"p"},"zio-macros")," package. To utilize it, we need to include the following line in our ",(0,r.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies ++= Seq("dev.zio" %% "zio-macros" % "<version>")\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ServiceReloader")," serves as a registry for services, enabling dynamic reloading of services. By applying the ",(0,r.kt)("inlineCode",{parentName:"p"},"reloadable")," operator on ",(0,r.kt)("inlineCode",{parentName:"p"},"ZLayer"),", we can create a reloadable version of our service. Subsequently, we can simply invoke ",(0,r.kt)("inlineCode",{parentName:"p"},"ServiceLoader.reload")," to initiate the reloading of the service. Let's explore the definition of the ServiceLoader trait:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait ServiceReloader {\n  def register[A: Tag: IsReloadable](serviceLayer: ZLayer[Any, Any, A]): IO[ServiceReloader.Error, A]\n  def reload[A: Tag]: IO[ServiceReloader.Error, Unit]\n}\n")),(0,r.kt)("p",null,"For example, if we require a reloadable ",(0,r.kt)("inlineCode",{parentName:"p"},"Counter")," service, we can simply invoke ",(0,r.kt)("inlineCode",{parentName:"p"},"ServiceReloader.reload[Counter]"),". The resulting type will be ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO[ServiceReloader, ServiceReloader.Error, Unit]"),". Consequently, instead of providing a ZLayer of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable[Counter]"),", we now need to provide a layer of type ",(0,r.kt)("inlineCode",{parentName:"p"},"ServiceReloader"),". "),(0,r.kt)("p",null,"With this approach, there is no longer a need to retrieve ",(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable[Counter]")," from the ZIO environment, eliminating the requirement to access ",(0,r.kt)("inlineCode",{parentName:"p"},"Counter")," from an instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable[Counter]")," class. Instead, we can work with services in a manner consistent with the idiomatic approach used for regular services. Thus, rather than calling ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.serviceWithZIO[Reloadable[Counter]](_.get)"),", we can conveniently use ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.service[Counter]")," to obtain the ",(0,r.kt)("inlineCode",{parentName:"p"},"Counter")," service directly from the ZIO environment."),(0,r.kt)("p",null,"Let's see how we can rewrite the ",(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable.manual")," example with this approach:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.macros._\n\nimport java.util.UUID\n\nobject ServiceReloaderExample extends ZIOAppDefault {\n\n  def app: ZIO[Counter with ServiceReloader, ServiceReloader.Error, Unit] =\n    for {\n      _ <- Counter.increment\n      _ <- Counter.increment\n      _ <- Counter.increment\n      _ <- Counter.get.debug("Counter value")\n\n      _ <- ServiceReloader.reload[Counter]\n      _ <- ZIO.sleep(1.seconds)\n\n      _ <- Counter.increment\n      _ <- Counter.increment\n      _ <- Counter.get.debug("Counter value")\n    } yield ()\n\n  def run = app.provide(Counter.reloadable, ServiceReloader.live)\n}\n')),(0,r.kt)("p",null,"To create a reloadable layer, we need to import ",(0,r.kt)("inlineCode",{parentName:"p"},"zio.macros._"),". Subsequently, by invoking the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZLayer#reloadable")," method, we can transform the ",(0,r.kt)("inlineCode",{parentName:"p"},"live")," layer into a layer that depends on ",(0,r.kt)("inlineCode",{parentName:"p"},"ServiceReloader")," and provides ",(0,r.kt)("inlineCode",{parentName:"p"},"Counter")," services:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.macros._\n\nobject Counter {\n\n  val live: ZLayer[Any, Nothing, Counter] = ???\n\n  val reloadable: ZLayer[ServiceReloader, ServiceReloader.Error, Counter] =\n    live.reloadable\n}\n")),(0,r.kt)("p",null,"We can further enhance this application by decoupling the reload process from the application logic. In doing so, each time the service is reloaded, subsequent calls to the service will be served with the freshly reloaded services:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject ServiceReloaderParallelWorkflowExample extends ZIOAppDefault {\n  def reloadWorkflow =\n    ServiceReloader.reload[Counter].delay(5.seconds)\n\n  def app: ZIO[Counter with ServiceReloader, ServiceReloader.Error, Unit] =\n    for {\n      _ <- Counter.increment\n      _ <- Counter.increment\n      _ <- Counter.increment\n      _ <- Counter.get.debug("Counter value")\n\n      _ <- ZIO.sleep(6.seconds)\n\n      _ <- Counter.increment\n      _ <- Counter.increment\n      _ <- Counter.increment\n      _ <- Counter.get.debug("Counter value")\n    } yield ()\n\n  def run = (app <&> reloadWorkflow).provide(Counter.reloadable, ServiceReloader.live)\n}\n')),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"Int this article we introduced two methods for implementing reloadable services in ZIO. The first method involves using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Reloadable")," service, which requires some boilerplate code. With this approach, services can be manually reloaded using the reload method. The second method, introduced by ",(0,r.kt)("inlineCode",{parentName:"p"},"zio-macros"),", simplifies the process by utilizing the ",(0,r.kt)("inlineCode",{parentName:"p"},"ServiceReloader")," service. This approach eliminates the need for retrieving the reloadable service from the environment and allows direct access to the service."),(0,r.kt)("p",null,"Overall, reloadable services in ZIO offer a powerful tool for managing services that require reloading, enabling seamless integration within the ZIO environment and simplifying service management in complex applications."),(0,r.kt)("p",null,"All the source code associated with this article is available on the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zio/zio-quickstarts/tree/master/zio-quickstart-reloadable-services"},"ZIO Quickstart")," on Github."))}u.isMDXComponent=!0}}]);