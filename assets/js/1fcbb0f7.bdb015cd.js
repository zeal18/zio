"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[93040],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=s(t),m=i,h=c["".concat(p,".").concat(m)]||c[m]||d[m]||r;return t?a.createElement(h,l(l({ref:n},u),{},{components:t})):a.createElement(h,l({ref:n},u))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=m;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[c]="string"==typeof e?e:i,l[1]=o;for(var s=2;s<r;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},60662:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var a=t(87462),i=(t(67294),t(3905));const r={id:"equivalence",title:"Equivalence"},l=void 0,o={unversionedId:"zio-prelude/functional-data-types/equivalence",id:"zio-prelude/functional-data-types/equivalence",title:"Equivalence",description:"An Equivalence[A, B] describes an equivalence relationship between two types A and B.",source:"@site/docs/zio-prelude/functional-data-types/equivalence.md",sourceDirName:"zio-prelude/functional-data-types",slug:"/zio-prelude/functional-data-types/equivalence",permalink:"/zio-prelude/functional-data-types/equivalence",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-data-types/equivalence.md",tags:[],version:"current",frontMatter:{id:"equivalence",title:"Equivalence"},sidebar:"ecosystem-sidebar",previous:{title:"Functional Data Types",permalink:"/zio-prelude/functional-data-types/"},next:{title:"NonEmptyList",permalink:"/zio-prelude/functional-data-types/nonemptylist"}},p={},s=[],u={toc:s},c="wrapper";function d(e){let{components:n,...t}=e;return(0,i.kt)(c,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"Equivalence[A, B]")," describes an equivalence relationship between two types ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),"."),(0,i.kt)("p",null,"An equivalence relationship is defined in terms of two functions ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," that convert a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," to a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," and vice versa."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Equivalence[A, B](to: A => B, from: B => A)\n")),(0,i.kt)("p",null,"To be a valid ",(0,i.kt)("inlineCode",{parentName:"p"},"Equivalence")," the functions ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," must satisfy an identity law, which says that for any value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),", if we transform it to a ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," using ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," and then back using ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," we get the same value. The same property must also apply for the reverse."),(0,i.kt)("p",null,"Simple examples of an equivalence relationship would be between an ",(0,i.kt)("inlineCode",{parentName:"p"},"List[A]")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk[A]"),". We can transform any ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," into a ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk")," using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk.fromIterable")," operator, and we can transform any ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk")," into a ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," using the ",(0,i.kt)("inlineCode",{parentName:"p"},"toList")," operator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.Chunk\nimport zio.prelude.Equivalence\n\ndef listChunkEquivalence[A]: Equivalence[List[A], Chunk[A]] =\n  Equivalence(Chunk.fromIterable, _.toList)\n")),(0,i.kt)("p",null,"This essentially represents the fact that ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk")," contain the same information. They represent it in different ways internally and have different performance characteristics but both of them model zero or more values of some type ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),"."),(0,i.kt)("p",null,"We can see from the example above that the order of describing ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk")," in the equivalence relationship was somewhat arbitrary. We could just as well have described this as an equivalence between ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk[A]")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"List[A]"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Equivalence")," data type lets us express that through the ",(0,i.kt)("inlineCode",{parentName:"p"},"flip")," operator."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def chunkListEquivalence[A]: Equivalence[Chunk[A], List[A]] =\n  listChunkEquivalence.flip\n")),(0,i.kt)("p",null,"In addition to being able to reverse equivalence relationships we can also compose them. If ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," then ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"C"),"."),(0,i.kt)("p",null,"We can express this using the ",(0,i.kt)("inlineCode",{parentName:"p"},"andThen")," operator on ",(0,i.kt)("inlineCode",{parentName:"p"},"Equivalence")," or its symbolic alias ",(0,i.kt)("inlineCode",{parentName:"p"},">>>"),"."),(0,i.kt)("p",null,"To demonstrate this let's define another equivalence relationship ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector[A]")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"List[A]"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def vectorListEquivalence[A]: Equivalence[Vector[A], List[A]] =\n  Equivalence(_.toList, _.toVector)\n")),(0,i.kt)("p",null,"Given these two equivalence relationships we can then define an equivalence relationship between a ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector[A]")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk[A]"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def vectorChunkEquivalence[A]: Equivalence[Vector[A], Chunk[A]] =\n  vectorListEquivalence.andThen(listChunkEquivalence)\n")),(0,i.kt)("p",null,"This is not a particularly interesting example because we could have easily converted directly from ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk")," in a more performant way without going through ",(0,i.kt)("inlineCode",{parentName:"p"},"List"),". But we can imagine that if ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," were equivalent but different representations of some more complex data type, being able to build up these conversions incrementally could be quite useful."),(0,i.kt)("p",null,"Beyond this there are not a lot of operators on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Equivalence")," data type itself. The main power of this data type is the ability to express the fact that two types are equivalent and capture this as a data type that we can test and reuse."),(0,i.kt)("p",null,"In particular, if we have what we believe to be an equivalence relationship between two types ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," ZIO Prelude makes it easy for us to test this."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.prelude.laws._\nimport zio.test._\nimport zio.test.laws._\n\nobject EquivalenceSpec extends ZIOSpecDefault {\n\n  def spec = suite("EquivalenceSpec") {\n    test("chunkListEquivalence") {\n      implicit val equivalence = listChunkEquivalence[Int]\n      val listGen = Gen.listOf(Gen.int)\n      val chunkGen = Gen.chunkOf(Gen.int)\n      checkAllLaws(EquivalenceLaws)(listGen, chunkGen)\n    }\n  }\n}\n')),(0,i.kt)("p",null,"ZIO Test will generate a large number of ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," values and check that the identity law holds. This can be helpful to catch corner cases where we think two things are equivalent, but they are really not."),(0,i.kt)("p",null,"With these equivalence relationships in hand we can then convert between different representations of our data in a straightforward and principled way. This is helpful when we need to implement higher level logic that needs to rely on this equivalence relationship existing between certain data types."))}d.isMDXComponent=!0}}]);