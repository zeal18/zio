"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[81114],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>k});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(n),d=a,k=m["".concat(l,".").concat(d)]||m[d]||u[d]||i;return n?o.createElement(k,r(r({ref:t},c),{},{components:n})):o.createElement(k,r({ref:t},c))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:a,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},83737:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var o=n(87462),a=(n(67294),n(3905));const i={id:"expectation",title:"Expectation"},r=void 0,s={unversionedId:"zio-mock/expectation",id:"zio-mock/expectation",title:"Expectation",description:"An Expectation[R] is an immutable tree structure that represents expectations on environment R.",source:"@site/docs/zio-mock/expectation.md",sourceDirName:"zio-mock",slug:"/zio-mock/expectation",permalink:"/zio-mock/expectation",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-mock/expectation.md",tags:[],version:"current",frontMatter:{id:"expectation",title:"Expectation"},sidebar:"ecosystem-sidebar",previous:{title:"Mock",permalink:"/zio-mock/mock"},next:{title:"ZIO NIO",permalink:"/zio-nio/"}},l={},p=[{value:"Defining Expectations",id:"defining-expectations",level:2},{value:"Providing Mocked Environment",id:"providing-mocked-environment",level:3},{value:"Mocking Unused Collaborators",id:"mocking-unused-collaborators",level:3},{value:"Mocking Multiple Collaborators",id:"mocking-multiple-collaborators",level:3},{value:"Expectations",id:"expectations",level:2},{value:"<code>value</code>",id:"value",level:3},{value:"<code>valueF</code>",id:"valuef",level:3},{value:"<code>valueZIO</code>",id:"valuezio",level:3},{value:"<code>unit</code>",id:"unit",level:3},{value:"<code>failure</code>",id:"failure",level:3},{value:"<code>never</code>",id:"never",level:3},{value:"Composing Expectations",id:"composing-expectations",level:2},{value:"<code>and</code>",id:"and",level:3},{value:"<code>or</code>",id:"or",level:3},{value:"<code>andThen</code>",id:"andthen",level:3},{value:"Exact Repetition",id:"exact-repetition",level:3},{value:"Range of Repetitions",id:"range-of-repetitions",level:3}],c={toc:p},m="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"An ",(0,a.kt)("inlineCode",{parentName:"p"},"Expectation[R]")," is an immutable tree structure that represents expectations on environment ",(0,a.kt)("inlineCode",{parentName:"p"},"R"),"."),(0,a.kt)("h2",{id:"defining-expectations"},"Defining Expectations"),(0,a.kt)("p",null,"ZIO Test has a variety of expectations, such as ",(0,a.kt)("inlineCode",{parentName:"p"},"value"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"unit"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"failure"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"never"),". In this section we are going to learn each of these expectations and their variant, by mocking the ",(0,a.kt)("inlineCode",{parentName:"p"},"UserService")," service. So let's assume we have the following service:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.mock._\nimport zio.test._\n\ncase class User(id: String, name: String)\n\ntrait UserService {\n  def insert(user: User): IO[String, Unit]\n  def remove(id: String): IO[String, Unit]\n  def totalUsers: IO[String, Int]\n  def recentUsers(n: Int): IO[String, List[User]]\n  def removeAll: IO[String, Unit]\n}\n\nobject UserService {\n  def totalUsers: ZIO[UserService, String, Int] =\n    ZIO.serviceWithZIO(_.totalUsers)\n\n  def insert(user: User): ZIO[UserService, String, Unit] =\n    ZIO.serviceWithZIO(_.insert(user))\n\n  def recentUsers(n: Int): ZIO[UserService, String, List[User]] =\n    ZIO.serviceWithZIO(_.recentUsers(n))\n\n  def remove(id: String): ZIO[UserService, String, Unit] =\n    ZIO.serviceWithZIO(_.remove(id))\n   \n  def removeAll: ZIO[UserService, String, Unit] = \n    ZIO.serviceWithZIO(_.removeAll) \n}\n")),(0,a.kt)("p",null,"We can write the mock version of this class as below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"\nobject MockUserService extends Mock[UserService] {\n\n  object Insert      extends Effect[User, String, Unit]\n  object Remove      extends Effect[String, String, Unit]\n  object RecentUsers extends Effect[Int, String, List[User]]\n  object TotalUsers  extends Effect[Unit, String, Int]\n  object RemoveAll   extends Effect[Unit, String, Unit]\n\n  val compose: URLayer[mock.Proxy, UserService] =\n    ZLayer {\n      for {\n        proxy <- ZIO.service[mock.Proxy]\n      } yield new UserService {\n        override def insert(user: User):  IO[String, Unit]       = proxy(Insert, user)\n        override def remove(id: String):  IO[String, Unit]       = proxy(Remove, id)\n        override def recentUsers(n: Int): IO[String, List[User]] = proxy(RecentUsers, n)\n        override def totalUsers:          IO[String, Int]        = proxy(TotalUsers)\n        override def removeAll:           IO[String, Unit]       = proxy(RemoveAll)\n      }\n\n    }\n}\n")),(0,a.kt)("p",null,"To create expectations we use the previously defined ",(0,a.kt)("em",{parentName:"p"},"capability tags"),"."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"For methods that take input, the first argument will be an assertion on input, and the second the predefined result.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.mock._\nimport zio.test._\n\nval exp01 = MockUserService.RecentUsers( // capability to build an expectation for\n  Assertion.equalTo(5), // assertion of the expected input argument\n  Expectation.value(List(User("1", "Jane Doe"), User("2", "John Doe"))) // result, that will be returned\n)\n')),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},"For methods that take no input, we only define the expected output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val exp02 = MockUserService.TotalUsers(Expectation.value(42))\n")),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},"For methods that may return ",(0,a.kt)("inlineCode",{parentName:"li"},"Unit"),", we may skip the predefined result (it will default to successful value) or use ",(0,a.kt)("inlineCode",{parentName:"li"},"unit")," helper:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'val exp03 = MockUserService.Remove(\n  Assertion.equalTo("1"),\n  Expectation.unit\n)\n')),(0,a.kt)("ol",{start:4},(0,a.kt)("li",{parentName:"ol"},"For methods that may return ",(0,a.kt)("inlineCode",{parentName:"li"},"Unit")," and take no input we can skip both:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val exp04 = MockUserService.RemoveAll()\n")),(0,a.kt)("h3",{id:"providing-mocked-environment"},"Providing Mocked Environment"),(0,a.kt)("p",null,"Each expectation can be taught of a mocked environment. They can be converted to a ",(0,a.kt)("inlineCode",{parentName:"p"},"ZLayer")," implicitly. Therefore, we can compose them together and provide them to the environment of the SUT (System Under Test)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\nimport zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("expecting simple value on call to nextInt") {\n  val sut     = Random.nextInt\n  val mockEnv = MockRandom.NextInt(Expectation.value(5))\n  for {\n    total <- sut.provideLayer(mockEnv)\n  } yield assertTrue(total == 5)\n} \n')),(0,a.kt)("h3",{id:"mocking-unused-collaborators"},"Mocking Unused Collaborators"),(0,a.kt)("p",null,"Often the dependency on a collaborator is only in some branches of the code. To test the correct behaviour of branches without dependencies, we still have to provide it to the environment, but we would like to assert it was never called. With the ",(0,a.kt)("inlineCode",{parentName:"p"},"Mock.empty")," method we can obtain a ",(0,a.kt)("inlineCode",{parentName:"p"},"ZLayer")," with an empty service (no calls expected):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.mock._\nimport zio.test._\n\nobject MaybeConsoleSpec extends MockSpecDefault {\n  def spec = suite("processEvent")(\n    test("expect no call") {\n      def maybeConsole(invokeConsole: Boolean) =\n        ZIO.when(invokeConsole)(Console.printLine("foo"))\n\n      val sut1     = maybeConsole(false).unit\n      val mockEnv1 = MockConsole.empty\n\n      val sut2     = maybeConsole(true).unit\n      val mockEnv2 = MockConsole.PrintLine(\n        Assertion.equalTo("foo"),\n        Expectation.unit\n      )\n\n      for {\n        _ <- sut1.provideLayer(mockEnv1)\n        _ <- sut2.provideLayer(mockEnv2)\n      } yield assertTrue(true)\n    }\n  )\n}\n')),(0,a.kt)("h3",{id:"mocking-multiple-collaborators"},"Mocking Multiple Collaborators"),(0,a.kt)("p",null,"In some cases we have more than one collaborating service being called. We can create mocks for rich environments and as you enrich the environment by using ",(0,a.kt)("em",{parentName:"p"},"capability tags")," from another service, the underlying mocked layer will be updated."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("mocking multiple collaborators") {\n  val sut =\n    for {\n      _ <- Console.printLine("What is your name?")\n      name <- Console.readLine.orDie\n      num <- Random.nextInt\n      _ <- Console.printLine(s"$name, your lucky number today is $num!")\n    } yield ()\n\n  val mockEnv: ULayer[Console with Random] = MockConsole.PrintLine(\n    Assertion.equalTo("What is your name?"),\n    Expectation.unit\n  ) ++ MockConsole.ReadLine(Expectation.value("Mike")) ++\n    MockRandom.NextInt(Expectation.value(42)) ++\n    MockConsole.PrintLine(\n      Assertion.equalTo("Mike, your lucky number today is 42!"),\n      Expectation.unit\n    )\n    \n  for {\n    _ <- sut.provideLayer(mockEnv)\n  } yield assertTrue(true)\n} \n')),(0,a.kt)("h2",{id:"expectations"},"Expectations"),(0,a.kt)("p",null,"In the most robust example, the result can be either a successful value or a failure. In this section we are going to introduce all these cases, by using the proper expectation from ",(0,a.kt)("inlineCode",{parentName:"p"},"zio.mock.Expectation")," companion object:"),(0,a.kt)("h3",{id:"value"},(0,a.kt)("inlineCode",{parentName:"h3"},"value")),(0,a.kt)("p",null,"Expecting a simple value:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("expecting simple value") {\n  val sut     = UserService.totalUsers\n  val mockEnv = MockUserService.TotalUsers(Expectation.value(14))\n  for {\n    total <- sut.provideLayer(mockEnv)\n  } yield assertTrue(total == 14)\n} \n')),(0,a.kt)("h3",{id:"valuef"},(0,a.kt)("inlineCode",{parentName:"h3"},"valueF")),(0,a.kt)("p",null,"Expecting a value based on input arguments:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("an expectation based on input arguments") {\n  val sut     = UserService.recentUsers(3)\n  val mockEnv = MockUserService.RecentUsers(\n    Assertion.isPositive,\n    Expectation.valueF(n =>\n      (1 to n).map(id => User(id.toString, "name")).toList\n    )\n  )\n\n  for {\n    users <- sut.provideLayer(mockEnv)\n  } yield assertTrue(users.map(_.id) == List("1", "2", "3"))\n}\n')),(0,a.kt)("h3",{id:"valuezio"},(0,a.kt)("inlineCode",{parentName:"h3"},"valueZIO")),(0,a.kt)("p",null,"Expecting a value based on the input arguments and also the result of an effectful operation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("effectful expectation") {\n  val sut     = UserService.recentUsers(3)\n  val mockEnv = MockUserService.RecentUsers(\n    Assertion.isPositive,\n    Expectation.valueZIO(n =>\n      ZIO.foreach(1 to n) { n =>\n        Random\n          .nextUUID\n          .map(id => User(id.toString, s"name-$n"))\n      }.map(_.toList)\n    )\n  )\n\n  for {\n    users <- sut.provideLayer(mockEnv)\n  } yield assertTrue(List("name-1", "name-2", "name-3") == users.map(_.name))\n}\n')),(0,a.kt)("h3",{id:"unit"},(0,a.kt)("inlineCode",{parentName:"h3"},"unit")),(0,a.kt)("p",null,"Expecting simple unit value:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("expecting unit") {\n  val sut     = UserService.remove("1")\n  val mockEnv = MockUserService.Remove(\n    Assertion.isNonEmptyString,\n    Expectation.unit\n  )\n  \n  for {\n    res <- sut.provideLayer(mockEnv).exit\n  } yield assertTrue(\n    res match {\n      case Exit.Success(()) => true\n      case _ => false\n    }\n  )\n}\n')),(0,a.kt)("h3",{id:"failure"},(0,a.kt)("inlineCode",{parentName:"h3"},"failure")),(0,a.kt)("p",null,"Expecting a failure:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("failure expectation") {\n  val sut = UserService.totalUsers\n  val mockEnv = MockUserService.TotalUsers(Expectation.failure("connection failed"))\n  \n  for {\n    total <- sut.provideLayer(mockEnv).exit\n  } yield assertTrue(\n    total match {\n      case Exit.Success(_) =>\n        false\n      case Exit.Failure(cause) =>\n        cause.contains(Cause.fail("connection failed"))\n    }\n  )\n}\n')),(0,a.kt)("p",null,"There are also ",(0,a.kt)("inlineCode",{parentName:"p"},"failureF")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"failureZIO")," variants like what we described for ",(0,a.kt)("inlineCode",{parentName:"p"},"value")," expectation."),(0,a.kt)("h3",{id:"never"},(0,a.kt)("inlineCode",{parentName:"h3"},"never")),(0,a.kt)("p",null,"This expectation simulates a never-ending loop:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("never ending expectation") {\n  val sut     = UserService.totalUsers\n  val mockEnv = MockUserService.TotalUsers(\n    Expectation.never\n  )\n\n  for {\n    r <- Live.live(\n      sut.provideLayer(mockEnv).timeout(500.millis)\n    )\n  } yield assertTrue(r.isEmpty)\n}\n')),(0,a.kt)("h2",{id:"composing-expectations"},"Composing Expectations"),(0,a.kt)("p",null,"We can combine our expectation to build complex scenarios using combinators defined in ",(0,a.kt)("inlineCode",{parentName:"p"},"zio.mock.Expectation"),"."),(0,a.kt)("h3",{id:"and"},(0,a.kt)("inlineCode",{parentName:"h3"},"and")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"and")," (alias ",(0,a.kt)("inlineCode",{parentName:"p"},"&&"),") operator composes two expectations, producing a new expectation to ",(0,a.kt)("strong",{parentName:"p"},"satisfy both in any order"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("satisfy both expectations with a logical `and` operator") {\n  val sut     = UserService.recentUsers(5) *> UserService.totalUsers\n  val mockEnv = MockUserService.TotalUsers(Expectation.value(1)).and(\n    MockUserService.RecentUsers(\n      Assertion.isPositive,\n      Expectation.value(List(User("1", "user"))))\n  )\n\n  for {\n    total <- sut.provideLayer(mockEnv)\n  } yield assertTrue(total == 1)\n}\n')),(0,a.kt)("h3",{id:"or"},(0,a.kt)("inlineCode",{parentName:"h3"},"or")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"or")," (alias ",(0,a.kt)("inlineCode",{parentName:"p"},"||"),") operator composes two expectations, producing a new expectation to ",(0,a.kt)("strong",{parentName:"p"},"satisfy only one of them"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("satisfy one of expectations with a logical `or` operator") {\n  val sut     = UserService.totalUsers\n  val mockEnv = MockUserService.TotalUsers(Expectation.value(1)).or(\n    MockUserService.RecentUsers(\n      Assertion.isPositive,\n      Expectation.value(List(User("1", "user"))))\n  )\n\n  for {\n    total <- sut.provideLayer(mockEnv)\n  } yield assertTrue(total == 1)\n}\n')),(0,a.kt)("h3",{id:"andthen"},(0,a.kt)("inlineCode",{parentName:"h3"},"andThen")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"andThen")," (alias ",(0,a.kt)("inlineCode",{parentName:"p"},"++"),") operator composes two expectations, producing a new expectation to ",(0,a.kt)("strong",{parentName:"p"},"satisfy both sequentially"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("satisfy sequence of two expectations with `andThen` operator") {\n  val sut     = UserService.recentUsers(5) *> UserService.totalUsers\n  val mockEnv = MockUserService.RecentUsers(\n    Assertion.isPositive,\n    Expectation.value(List(User("1", "user")))\n  ) andThen MockUserService.TotalUsers(Expectation.value(1))\n\n  for {\n    total <- sut.provideLayer(mockEnv)\n  } yield assertTrue(total == 1)\n}\n')),(0,a.kt)("p",null,"In the example above, changing the SUT to ",(0,a.kt)("inlineCode",{parentName:"p"},"UserService.totalUsers *> UserService.remove(1)")," will fail the test."),(0,a.kt)("h3",{id:"exact-repetition"},"Exact Repetition"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"exactly"))," \u2014 Produces a new expectation to satisfy itself exactly the given number of times:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("satisfying exact repetition of a method call") {\n  val sut     = ZIO.foreach(List("1", "2", "3", "4"))(id => UserService.remove(id))\n  val mockEnv = MockUserService.Remove(\n    Assertion.isNonEmptyString\n  ).exactly(4)\n\n  for {\n    _ <- sut.provideLayer(mockEnv)\n  } yield assertTrue(true)\n}\n')),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"twice"))," and ",(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"thrice"))," \u2014 Aliases for ",(0,a.kt)("inlineCode",{parentName:"li"},"exactly(2)")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"exactly(3)"),".")),(0,a.kt)("h3",{id:"range-of-repetitions"},"Range of Repetitions"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"Expectation#repeats(range: Range)"))," \u2014 Repeats this expectation within given bounds, producing a new expectation to ",(0,a.kt)("strong",{parentName:"li"},"satisfy itself sequentially given number of times"),":")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("expect repeated calls") {\n  val sut     = Random.nextInt *> Random.nextInt\n  val mockEnv = MockRandom.NextInt(Expectation.value(42)).repeats(2 to 4)\n\n  for {\n    _ <- sut.provideLayer(mockEnv)\n  } yield assertTrue(true)\n}\n')),(0,a.kt)("p",null,"In the example above, if we repeat ",(0,a.kt)("inlineCode",{parentName:"p"},"nextInt")," less than 2 or over 4 times, the test will fail."),(0,a.kt)("p",null,"Another note on repetitions is that, if we compose expectations with ",(0,a.kt)("inlineCode",{parentName:"p"},"andThen"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"++"),", once another repetition starts executing, it must be completed in order to satisfy the composite expectation. For example ",(0,a.kt)("inlineCode",{parentName:"p"},"(A ++ B).repeats(1, 2)")," will be satisfied by either ",(0,a.kt)("inlineCode",{parentName:"p"},"A->B")," (one repetition) or ",(0,a.kt)("inlineCode",{parentName:"p"},"A->B->A->B")," (two repetitions), but will fail on ",(0,a.kt)("inlineCode",{parentName:"p"},"A->B->A")," (incomplete second repetition):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.mock.Expectation._\nimport zio.test.{test, _}\n\ntest("if another repetition starts executing, it must be completed") {\n  val sut     = Random.nextInt *> Random.nextBoolean *> Random.nextInt\n  val mockEnv = (MockRandom.NextInt(value(42)) ++ MockRandom.NextBoolean(value(true)))\n    .repeats(1 to 2)\n  for {\n    _ <- sut.provideLayer(mockEnv)\n  } yield assertTrue(true)\n} @@ TestAspect.failing\n')),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"atLeast(min: Int)")),", ",(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"atMost(max: Int)")),", and ",(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"optional"))," expectations are other variants for ",(0,a.kt)("inlineCode",{parentName:"li"},"repeats")," expectation.")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"atLeast")," operator is a lower-bounded variant of ",(0,a.kt)("inlineCode",{parentName:"li"},"repeated"),", produces a new expectation to satisfy ",(0,a.kt)("strong",{parentName:"li"},"itself sequentially at least given number of times"),"."),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"atMost")," operator is an upper-bounded variant of ",(0,a.kt)("inlineCode",{parentName:"li"},"repeated"),", produces a new expectation to satisfy ",(0,a.kt)("strong",{parentName:"li"},"itself sequentially at most given number of times"),"."),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"optional")," operator is an alias for ",(0,a.kt)("inlineCode",{parentName:"li"},"atMost(1)"),", produces a new expectation to satisfy ",(0,a.kt)("strong",{parentName:"li"},"itself at most once"),".")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"MockClock")," is a built-in mock version of the ","[",(0,a.kt)("inlineCode",{parentName:"p"},"Clock"),"]"," service."),(0,a.kt)("p",null,"Here is an example of mocking ",(0,a.kt)("inlineCode",{parentName:"p"},"Clock.nanoTime")," capability:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.mock.Expectation._\nimport zio.test.{test, _}\n\ntest("calling mocked nanoTime should return expected time") {\n  val app = Clock.nanoTime\n  val env = MockClock.NanoTime(value(1000L))\n  val out = app.provideLayer(env)\n  out.map(r => assertTrue(r == 1000L))\n}\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"MockConsole")," is a built-in mock version of the ","[",(0,a.kt)("inlineCode",{parentName:"p"},"Console"),"]"," service."),(0,a.kt)("p",null,"Here is an example of mocking ",(0,a.kt)("inlineCode",{parentName:"p"},"Console.readLine")," capability:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("calling mocked readline should return expected value") {\n  for {\n    line <- Console.readLine.provideLayer(\n      MockConsole.ReadLine(Expectation.value("foo"))\n    )\n  } yield assertTrue(line == "foo")\n}\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"MockRandom")," is a built-in mock version of the ","[",(0,a.kt)("inlineCode",{parentName:"p"},"Random"),"]"," service. It mocks all the random service capabilities."),(0,a.kt)("p",null,"Here's how we can mock the ",(0,a.kt)("inlineCode",{parentName:"p"},"MockRandom.nextIntBounded")," capability:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("expect call with input satisfying assertion and transforming it into output") {\n  for {\n    out <- Random.nextIntBounded(1).provideLayer(\n      MockRandom.NextIntBounded(\n        Assertion.equalTo(1),\n        Expectation.valueF(_ + 41)\n      )\n    )\n  } yield assertTrue(out == 42)\n}\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"MockSystem")," is a built-in mock version of the ","[",(0,a.kt)("inlineCode",{parentName:"p"},"System"),"]"," service. It mocks all the system service capabilities."),(0,a.kt)("p",null,"Here's how we can mock the ",(0,a.kt)("inlineCode",{parentName:"p"},"MockSystem.property")," capability:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.mock._\nimport zio.test.{test, _}\n\ntest("calling mocked property should return expected property") {\n  for {\n    property <- System.property("java.vm.name").provideLayer(\n      MockSystem.Property(\n        Assertion.equalTo("java.vm.name"),\n        Expectation.value(Some("OpenJDK 64-Bit Server VM"))\n      )\n    )\n  } yield assertTrue(property.get.contains("OpenJDK"))\n}\n')))}u.isMDXComponent=!0}}]);