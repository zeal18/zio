"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[82690],{3905:(e,n,t)=>{t.d(n,{Zo:()=>g,kt:()=>f});var i=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=i.createContext({}),c=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},g=function(e){var n=c(e.components);return i.createElement(l.Provider,{value:n},e.children)},s="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},d=i.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,g=p(e,["components","mdxType","originalType","parentName"]),s=c(t),d=o,f=s["".concat(l,".").concat(d)]||s[d]||m[d]||r;return t?i.createElement(f,a(a({ref:n},g),{},{components:t})):i.createElement(f,a({ref:n},g))}));function f(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,a=new Array(r);a[0]=d;var p={};for(var l in n)hasOwnProperty.call(n,l)&&(p[l]=n[l]);p.originalType=e,p[s]="string"==typeof e?e:o,a[1]=p;for(var c=2;c<r;c++)a[c]=t[c];return i.createElement.apply(null,a)}return i.createElement.apply(null,t)}d.displayName="MDXCreateElement"},31946:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>p,toc:()=>c});var i=t(87462),o=(t(67294),t(3905));const r={id:"providing-different-implementation-of-a-service",title:"Providing Different Implementation of a Service",sidebar_label:"Multiple Implementations"},a=void 0,p={unversionedId:"reference/di/providing-different-implementation-of-a-service",id:"reference/di/providing-different-implementation-of-a-service",title:"Providing Different Implementation of a Service",description:"One of the benefits of using dependency injection is that, we can write our application in a way that without modifying the application logic, we can provide different implementations of services to our application.",source:"@site/docs/reference/di/providing-different-implementation-of-a-service.md",sourceDirName:"reference/di",slug:"/reference/di/providing-different-implementation-of-a-service",permalink:"/reference/di/providing-different-implementation-of-a-service",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/di/providing-different-implementation-of-a-service.md",tags:[],version:"current",frontMatter:{id:"providing-different-implementation-of-a-service",title:"Providing Different Implementation of a Service",sidebar_label:"Multiple Implementations"},sidebar:"reference-sidebar",previous:{title:"Dependency Propagation",permalink:"/reference/di/dependency-propagation"},next:{title:"Dependency Memoization",permalink:"/reference/di/dependency-memoization"}},l={},c=[{value:"Example 1: Config Service",id:"example-1-config-service",level:2},{value:"Example 2: Logging Service",id:"example-2-logging-service",level:2}],g={toc:c},s="wrapper";function m(e){let{components:n,...t}=e;return(0,o.kt)(s,(0,i.Z)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"One of the benefits of using dependency injection is that, we can write our application in a way that without modifying the application logic, we can provide different implementations of services to our application."),(0,o.kt)("h2",{id:"example-1-config-service"},"Example 1: Config Service"),(0,o.kt)("p",null,"In the next example, we have a ZIO application that uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"AppConfig")," service:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ncase class AppConfig(poolSize: Int)\n\nobject AppConfig {\n  def poolSize: ZIO[AppConfig, Nothing, Int] =\n    ZIO.serviceWith[AppConfig](_.poolSize)\n\n  val appArgsLayer: ZLayer[ZIOAppArgs, Nothing, AppConfig] =\n    ZLayer {\n      ZIOAppArgs.getArgs\n        .map(_.headOption.map(_.toInt).getOrElse(8))\n        .map(poolSize => AppConfig(poolSize))\n    }\n\n  val systemEnvLayer: ZLayer[Any, SecurityException, AppConfig] =\n    ZLayer.fromZIO(\n      System\n        .env("POOL_SIZE")\n        .map(_.headOption.map(_.toInt).getOrElse(8))\n        .map(poolSize => AppConfig(poolSize))\n    )\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[AppConfig, Nothing, Unit] =\n    for {\n      poolSize <- AppConfig.poolSize\n      _        <- ZIO.debug(s"Application started with $poolSize pool size.")\n    } yield ()\n\n  def run = myApp.provideSome[ZIOAppArgs](AppConfig.appArgsLayer)\n}\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"AppConfig")," has two layers, ",(0,o.kt)("inlineCode",{parentName:"p"},"appArgsLayer")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"systemEnvLayer"),". The first one uses command-line arguments to create the ",(0,o.kt)("inlineCode",{parentName:"p"},"AppConfig")," and the second one uses environment variables. As we can see, without changing the core logic of our application, we can easily change the way we get the configuration:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-diff"},'object MainApp extends ZIOAppDefault {\n  val myApp: ZIO[AppConfig, Nothing, Unit] =\n    for {\n      poolSize <- AppConfig.poolSize\n      _        <- ZIO.debug(s"Application started with $poolSize pool size.")\n    } yield ()\n\n-  def run = myApp.provideSome[ZIOAppArgs](AppConfig.appArgsLayer)\n+  def run = myApp.provide(AppConfig.systemEnvLayer)\n}\n')),(0,o.kt)("h2",{id:"example-2-logging-service"},"Example 2: Logging Service"),(0,o.kt)("p",null,"In this example, we have a ZIO application that uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"Logging")," service. And we provided two implementations of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Logging")," service: ",(0,o.kt)("inlineCode",{parentName:"p"},"SimpleLogger")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"DateTimeLogger"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nimport java.io.IOException\n\ntrait Logging {\n  def log(msg: String): ZIO[Any, IOException, Unit]\n}\n\nobject Logging {\n  def log(msg: String): ZIO[Logging, IOException, Unit] =\n    ZIO.serviceWithZIO[Logging](_.log(msg))\n}\n\ncase class DateTimeLogger() extends Logging {\n  override def log(msg: String): ZIO[Any, IOException, Unit] =\n    for {\n      dt <- Clock.currentDateTime\n      _  <- Console.printLine(s"$dt: $msg")\n    } yield ()\n}\n\nobject DateTimeLogger {\n  val live: ULayer[DateTimeLogger] =\n    ZLayer.succeed(DateTimeLogger())\n}\n\ncase class SimpleLogger() extends Logging {\n  override def log(msg: String): ZIO[Any, IOException, Unit] =\n    Console.printLine(msg)\n}\nobject SimpleLogger {\n  val live: ULayer[SimpleLogger] =\n    ZLayer.succeed(SimpleLogger())\n}\n')),(0,o.kt)("p",null,"Now, let's write a ZIO application that uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"Logging")," service:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval myApp: ZIO[Logging, IOException, Unit] =\n  for {\n    _ <- Logging.log("Application started.")\n    _ <- Logging.log("Application ended.")\n  } yield ()\n')),(0,o.kt)("p",null,"Now, we can run our application, just by providing one of the implementations of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Logging")," service. Let's run it with the ",(0,o.kt)("inlineCode",{parentName:"p"},"SimpleLogger")," implementation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"object MainApp extends ZIOAppDefault {\n  def run = myApp.provide(SimpleLogger.live)\n}\n")),(0,o.kt)("p",null,"Now, we can see that, without changing the core logic of our application, we can easily change the logger implementation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"object MainApp extends ZIOAppDefault {\n  def run = myApp.provide(DateTimeLogger.live)\n}\n")))}m.isMDXComponent=!0}}]);