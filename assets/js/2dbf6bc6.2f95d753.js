"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[59037],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>g});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(t),u=r,g=m["".concat(s,".").concat(u)]||m[u]||d[u]||o;return t?a.createElement(g,i(i({ref:n},p),{},{components:t})):a.createElement(g,i({ref:n},p))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[m]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},47347:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=t(87462),r=(t(67294),t(3905));const o={id:"code-generation",title:"Code Generation"},i=void 0,l={unversionedId:"zio-quill/code-generation",id:"zio-quill/code-generation",title:"Code Generation",description:"Quill now has a highly customizable code generator. Currently, it only supports JDBC but it will soon be extended to other contexts. With a minimal amount of configuration, the code generator takes schemas like this:",source:"@site/docs/zio-quill/code-generation.md",sourceDirName:"zio-quill",slug:"/zio-quill/code-generation",permalink:"/zio-quill/code-generation",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-quill/code-generation.md",tags:[],version:"current",frontMatter:{id:"code-generation",title:"Code Generation"},sidebar:"ecosystem-sidebar",previous:{title:"Contexts",permalink:"/zio-quill/contexts"},next:{title:"Logging",permalink:"/zio-quill/logging"}},s={},c=[{value:"Quill Code Generator",id:"quill-code-generator",level:2},{value:"SimpleJdbcCodegen",id:"simplejdbccodegen",level:2},{value:"Composeable Traits Codegen",id:"composeable-traits-codegen",level:2},{value:"Stereotyping",id:"stereotyping",level:2}],p={toc:c},m="wrapper";function d(e){let{components:n,...t}=e;return(0,r.kt)(m,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Quill now has a highly customizable code generator. Currently, it only supports JDBC but it will soon be extended to other contexts. With a minimal amount of configuration, the code generator takes schemas like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- Using schema 'public'\n\ncreate table public.Person (\n  id int primary key auto_increment,\n  first_name varchar(255),\n  last_name varchar(255),\n  age int not null\n);\n\ncreate table public.Address (\n  person_fk int not null,\n  street varchar(255),\n  zip int\n);\n")),(0,r.kt)("p",null,"Producing objects like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"// src/main/scala/com/my/project/public/Person.scala\npackage com.my.project.public\n\ncase class Person(id: Int, firstName: Option[String], lastName: Option[String], age: Int)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"// src/main/scala/com/my/project/public/Address.scala\npackage com.my.project.public\n\ncase class Address(personFk: Int, street: Option[String], zip: Option[Int])\n")),(0,r.kt)("h2",{id:"quill-code-generator"},"Quill Code Generator"),(0,r.kt)("p",null,"This library gives you a few options as to what kind of\nschema to generate from JDBC metadata for Quill. You can choose to generate\nsimple case classes that are controlled entirely but a Quill Naming Strategy,\nor a combination of case classes and ",(0,r.kt)("inlineCode",{parentName:"p"},"querySchema"),"s.\nYou can also choose whether they should written to one file, multiple files, or\njust a list of strings (useful for executing directly into a repl).\nThanks to the Slick code generator creators for providing inspiration for this library!"),(0,r.kt)("p",null,"Currently the code generator is only available for JDBC databases but it will\nbe extended in the future for Cassandra as well as others."),(0,r.kt)("p",null,"You can import the Code Generator using maven:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},"<dependency>\n  <groupId>io.getquill</groupId>\n  <artifactId>quill-codegen-jdbc_2.13</artifactId>\n  <version>3.10.0</version>\n</dependency>\n")),(0,r.kt)("p",null,"Or using sbt:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "io.getquill" %% "quill-codegen-jdbc" % "4.6.1"\n')),(0,r.kt)("h2",{id:"simplejdbccodegen"},"SimpleJdbcCodegen"),(0,r.kt)("p",null,"This code generator generates simple case classes, each representing a table\nin a database. It does not generate Quill ",(0,r.kt)("inlineCode",{parentName:"p"},"querySchema")," objects.\nCreate one or multiple CodeGeneratorConfig objects\nand call the ",(0,r.kt)("inlineCode",{parentName:"p"},".writeFiles")," or ",(0,r.kt)("inlineCode",{parentName:"p"},".writeStrings")," methods\non the code generator to generate the code."),(0,r.kt)("p",null,"Given the following schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- Using schema 'public'\n\ncreate table public.Person (\n  id int primary key auto_increment,\n  first_name varchar(255),\n  last_name varchar(255),\n  age int not null\n);\n\ncreate table public.Address (\n  person_fk int not null,\n  street varchar(255),\n  zip int\n);\n")),(0,r.kt)("p",null,"You can invoke the SimpleJdbcCodegen like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'// provide DB credentials with a com.typesafe.config.Config object\n// (under the hood the credentials are used to create a HikariPool DataSource)\nimport io.getquill.codegen.jdbc.SimpleJdbcCodegen\nimport io.getquill.util.LoadConfig\n\nval snakecaseConfig = LoadConfig(configPrefix: String)\nval gen = new SimpleJdbcCodegen(snakecaseConfig, "com.my.project") {\n    override def nameParser = SnakeCaseNames\n}\ngen.writeFiles("src/main/scala/com/my/project")\n\n// or, provide an initialized DataSource\nimport io.getquill.codegen.jdbc.SimpleJdbcCodegen\nimport org.postgresql.ds.PGSimpleDataSource\n\nval pgDataSource = new PGSimpleDataSource()\npgDataSource.setURL(\n  "jdbc:postgresql://127.0.0.1:5432/quill_codegen_example?ssl=false",\n)\npgDataSource.setUser("my_user")\npgDataSource.setPassword("my_password")\nval gen = new SimpleJdbcCodegen(pgDataSource, "com.my.project") {\n    override def nameParser = SnakeCaseNames\n}\ngen.writeFiles("src/main/scala/com/my/project")\n')),(0,r.kt)("p",null,"You can parse column and table names using either the ",(0,r.kt)("inlineCode",{parentName:"p"},"SnakeCaseNames")," or the and the ",(0,r.kt)("inlineCode",{parentName:"p"},"LiteralNames")," parser\nwhich are used with the respective Quill Naming Strategies. They cannot be customized further with this code generator."),(0,r.kt)("p",null,"The following case case classes will be generated"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"// src/main/scala/com/my/project/public/Person.scala\npackage com.my.project.public\n  \ncase class Person(id: Int, firstName: Option[String], lastName: Option[String], age: Int)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"// src/main/scala/com/my/project/public/Address.scala\npackage com.my.project.public\n  \ncase class Address(personFk: Int, street: Option[String], zip: Option[Int])\n")),(0,r.kt)("p",null,"If you wish to generate schemas with custom table or column names, you need to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ComposeableTraitsJdbcCodegen"),"\nin order to generate your schemas with ",(0,r.kt)("inlineCode",{parentName:"p"},"querySchema")," objects."),(0,r.kt)("h2",{id:"composeable-traits-codegen"},"Composeable Traits Codegen"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ComposeableTraitsJdbcCodegen")," enables more customized code generation.\nIt allows you to determine the tables to generate entity classes for,\ntheir naming stragety, the types for columns in Scala,\nand generates the necessary ",(0,r.kt)("inlineCode",{parentName:"p"},"querySchema")," object in order to map the fields.\nAdditionally, it generates a database-independent query schema trait which can be composed\nwith a ",(0,r.kt)("inlineCode",{parentName:"p"},"Context")," object of your choice."),(0,r.kt)("p",null,"Given the following schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"create table public.Person (\n  id int primary key auto_increment,\n  first_name varchar(255),\n  last_name varchar(255),\n  age int not null\n);\n\ncreate table public.Address (\n  person_fk int not null,\n  street varchar(255),\n  zip int\n);\n")),(0,r.kt)("p",null,"Here is a example of how you could use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ComposeableTraitsJdbcCodegen")," in order to replace the\n",(0,r.kt)("inlineCode",{parentName:"p"},"first_name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"last_name")," properties with ",(0,r.kt)("inlineCode",{parentName:"p"},"first")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"last"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val gen = new ComposeableTraitsJdbcCodegen(\n  configOrDataSource,\n  packagePrefix = "com.my.project",\n  nestedTrait = true) {\n\n  override def nameParser: NameParser = CustomNames(\n    columnParser = col => col.columnName.toLowerCase.replace("_name", "")\n  )\n\n\n  override def packagingStrategy: PackagingStrategy = PackagingStrategy.ByPackageHeader.TablePerSchema(packagePrefix)\n}\ngen.writeFiles("src/main/scala/com/my/project")\n')),(0,r.kt)("p",null,"The following schema should be generated as a result."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'package com.my.project.public\n\ncase class Person(id: Int, first: Option[String], last: Option[String], age: Int)\n\ncase class Address(person_fk: Int, street: Option[String], zip: Option[Int])\n\n// Note that by default this is formatted as "${namespace}Extensions"\ntrait PublicExtensions[Idiom <: io.getquill.idiom.Idiom, Naming <: io.getquill.NamingStrategy] {\n  this:io.getquill.context.Context[Idiom, Naming] =>\n\n  object PublicSchema {\n    object PersonDao {\n        def query = quote {\n            querySchema[Person](\n              "public.person",\n              _.id -> "id",\n              _.first -> "first_name",\n              _.last -> "last_name",\n              _.age -> "age"\n            )\n\n          }\n\n      }\n\n      object AddressDao {\n        def query = quote {\n            querySchema[Address](\n              "public.address",\n              _.person_fk -> "person_fk",\n              _.street -> "street",\n              _.zip -> "zip"\n            )\n\n          }\n\n      }\n  }\n}\n')),(0,r.kt)("p",null,"Later when declaring your Quill database context you can compose the context with\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"PublicExtensions")," like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"object MyCustomContext extends SqlMirrorContext[H2Dialect, Literal](H2Dialect, Literal)\n  with PublicExtensions[H2Dialect, Literal]\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ComposeableTraitsJdbcCodegen")," is designed to be customizable via composition. This is a longer list of customizable strategies:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import io.getquill.codegen.jdbc.ComposeableTraitsJdbcCodegen\nimport io.getquill.codegen.model._\n\nnew ComposeableTraitsJdbcCodegen(...) {\n\n  // whether to generate Scala code for a table\n  override def filter(tc: RawSchema[JdbcTableMeta, JdbcColumnMeta]): Boolean = ???\n\n  // how to name table / columns in Scala\n  override def nameParser: NameParser = ???\n\n  // how to organize generated code into files / packages\n  override def packagingStrategy: PackagingStrategy = ???\n\n  // what JVM types (classes) to use for DB column\n  // e.g. one may want to translate Postgres `timestamptz` to java.time.OffsetDateTime\n  override def typer: Typer = ???\n\n  // what to do when `typer` above cannot find an appropriate type and returned None\n  override def unrecognizedTypeStrategy: UnrecognizedTypeStrategy = ???\n}\n\n\n")),(0,r.kt)("h2",{id:"stereotyping"},"Stereotyping"),(0,r.kt)("p",null,"Frequently in corporate databases, the same kind of table is duplicated across multiple schemas, databases, etc...\nfor different business units. Typically, all the duplicates of the table will have nearly the same columns\nwith just minor differences. Stereotyped code-generation aims to take the 'lowest common denominator' of all these schemas\nin order to produce a case class that can be used across all of them."),(0,r.kt)("p",null,"Examine the following H2 DDL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"create table Alpha.Person (\n  id int primary key auto_increment,\n  first_name varchar(255),\n  last_name varchar(255),\n  age int not null,\n  foo varchar(255),\n  num_trinkets int,\n  trinket_type varchar(255) not null\n);\n\ncreate table Bravo.Person (\n  id int primary key auto_increment,\n  first_name varchar(255),\n  bar varchar(255),\n  last_name varchar(255),\n  age int not null,\n  num_trinkets bigint not null,\n  trinket_type int not null\n);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Firstly, note that ",(0,r.kt)("inlineCode",{parentName:"li"},"Alpha.Person")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Bravo.Person")," have the exact same columns except for ",(0,r.kt)("inlineCode",{parentName:"li"},"foo")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"bar")," respectively.\nIf a common table definition ",(0,r.kt)("inlineCode",{parentName:"li"},"Person")," is desired, these columns must be omitted."),(0,r.kt)("li",{parentName:"ul"},"Secondly, note that their columns ",(0,r.kt)("inlineCode",{parentName:"li"},"num_trinkets")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"trinket_type")," have different types.\nIf a common table definition ",(0,r.kt)("inlineCode",{parentName:"li"},"Person")," is desired, these columns must be expanded to the widest\ndatatype of the two which is this case ",(0,r.kt)("inlineCode",{parentName:"li"},"bigint")," for ",(0,r.kt)("inlineCode",{parentName:"li"},"num_trinkets")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"varchar(255)")," for ",(0,r.kt)("inlineCode",{parentName:"li"},"trinket_type"),".")),(0,r.kt)("p",null,"Both of the above actions are automatically performed by the ",(0,r.kt)("inlineCode",{parentName:"p"},"ComposeableTraitsJdbcCodegen"),"\n(and ",(0,r.kt)("inlineCode",{parentName:"p"},"SimpleJdbcCodegen"),") automatically when multiple tables with the same name are detected or if you\nrename them using a custom ",(0,r.kt)("inlineCode",{parentName:"p"},"namingStrategy")," causing this to happen.\nHere is an example of how that is done:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val gen = new ComposeableTraitsJdbcCodegen(twoSchemaConfig, "com.my.project") {\n  override def namingStrategy: EntityNamingStrategy = CustomStrategy()\n  override val namespacer: Namespacer =\n    ts => if (ts.tableSchem.toLowerCase == "alpha" || ts.tableSchem.toLowerCase == "bravo") "common" else ts.tableSchem.toLowerCase\n    \n  // Be sure to set the querySchemaNaming correctly so that the different\n  // querySchemas generated won\'t all be called \'.query\' in the common object (which would\n  // case an un-compile-able schema to be generated).\n  override def querySchemaNaming: QuerySchemaNaming = `[namespace][Table]`\n}\n\ngen.writeFiles("src/main/scala/com/my/project")\n')),(0,r.kt)("p",null,"The following will then be generated. Note how ",(0,r.kt)("inlineCode",{parentName:"p"},"numTrinkets")," is a ",(0,r.kt)("inlineCode",{parentName:"p"},"Long")," (i.e. an SQL ",(0,r.kt)("inlineCode",{parentName:"p"},"bigint"),") type and ",(0,r.kt)("inlineCode",{parentName:"p"},"trinketType")," is a ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"\n(i.e. an SQL varchar),"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'package com.my.project.common\n  \ncase class Person(id: Int, firstName: Option[String], lastName: Option[String], age: Int, numTrinkets: Option[Long], trinketType: String)\n  \ntrait CommonExtensions[Idiom <: io.getquill.idiom.Idiom, Naming <: io.getquill.NamingStrategy] {\n  this:io.getquill.context.Context[Idiom, Naming] =>\n  \n  object PersonDao {\n      def alphaPerson = quote {\n          querySchema[Person](\n            "ALPHA.PERSON",\n            _.id -> "ID",\n            _.firstName -> "FIRST_NAME",\n            _.lastName -> "LAST_NAME",\n            _.age -> "AGE",\n            _.numTrinkets -> "NUM_TRINKETS",\n            _.trinketType -> "TRINKET_TYPE"\n          )\n        }\n  \n      def bravoPerson = quote {\n          querySchema[Person](\n            "BRAVO.PERSON",\n            _.id -> "ID",\n            _.firstName -> "FIRST_NAME",\n            _.lastName -> "LAST_NAME",\n            _.age -> "AGE",\n            _.numTrinkets -> "NUM_TRINKETS",\n            _.trinketType -> "TRINKET_TYPE"\n          )\n        }\n    }\n}\n')),(0,r.kt)("p",null,"Later when declaring your quill database context you can compose the context with\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"CommonExtensions")," like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"object MyCustomContext extends SqlMirrorContext[H2Dialect, Literal](H2Dialect, Literal)\n  with CommonExtensions[H2Dialect, Literal]\n")))}d.isMDXComponent=!0}}]);