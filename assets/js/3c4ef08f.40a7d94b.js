"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[32692],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>g});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=d(a),m=r,g=c["".concat(s,".").concat(m)]||c[m]||u[m]||l;return a?n.createElement(g,i(i({ref:t},p),{},{components:a})):n.createElement(g,i({ref:t},p))}));function g(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[c]="string"==typeof e?e:r,i[1]=o;for(var d=2;d<l;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},82414:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var n=a(87462),r=(a(67294),a(3905));const l={id:"index",title:"Introduction to ZIO SQL",sidebar_label:"ZIO SQL"},i=void 0,o={unversionedId:"zio-sql/index",id:"zio-sql/index",title:"Introduction to ZIO SQL",description:"ZIO SQL lets you write type-safe, type-inferred, and composable SQL queries in ordinary Scala, helping you prevent persistence bugs before they happen, and leverage your IDE to make writing SQL productive, safe, and fun.",source:"@site/docs/zio-sql/index.md",sourceDirName:"zio-sql",slug:"/zio-sql/",permalink:"/zio-sql/",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-sql/index.md",tags:[],version:"current",frontMatter:{id:"index",title:"Introduction to ZIO SQL",sidebar_label:"ZIO SQL"},sidebar:"ecosystem-sidebar",previous:{title:"ZIO SBT",permalink:"/zio-sbt/"},next:{title:"Deep dive",permalink:"/zio-sql/deep-dive"}},s={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Current status: Non-production release",id:"current-status-non-production-release",level:2},{value:"Progress report towards 0.1",id:"progress-report-towards-01",level:3},{value:"General features:",id:"general-features",level:4},{value:"Db-specific features:",id:"db-specific-features",level:4},{value:"Installation",id:"installation",level:2},{value:"Imports and modules",id:"imports-and-modules",level:2},{value:"Table schema",id:"table-schema",level:2},{value:"Table schema decomposition",id:"table-schema-decomposition",level:2},{value:"Selects",id:"selects",level:2},{value:"Inserts",id:"inserts",level:2},{value:"Updates",id:"updates",level:2},{value:"Deletes",id:"deletes",level:2},{value:"Transactions",id:"transactions",level:2},{value:"Printing queries",id:"printing-queries",level:2},{value:"Running queries",id:"running-queries",level:2}],p={toc:d},c="wrapper";function u(e){let{components:t,...a}=e;return(0,r.kt)(c,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"ZIO SQL lets you write type-safe, type-inferred, and composable SQL queries in ordinary Scala, helping you prevent persistence bugs before they happen, and leverage your IDE to make writing SQL productive, safe, and fun."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/zio/zio/wiki/Project-Stages"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/Project%20Stage-Production%20Ready-brightgreen.svg",alt:"Production Ready"}))," ",(0,r.kt)("img",{parentName:"p",src:"https://github.com/zio/zio-sql/workflows/CI/badge.svg",alt:"CI Badge"})," ",(0,r.kt)("a",{parentName:"p",href:"https://oss.sonatype.org/content/repositories/releases/dev/zio/zio-sql_2.13/"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nexus/r/https/oss.sonatype.org/dev.zio/zio-sql_2.13.svg?label=Sonatype%20Release",alt:"Sonatype Releases"}))," ",(0,r.kt)("a",{parentName:"p",href:"https://oss.sonatype.org/content/repositories/snapshots/dev/zio/zio-sql_2.13/"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nexus/s/https/oss.sonatype.org/dev.zio/zio-sql_2.13.svg?label=Sonatype%20Snapshot",alt:"Sonatype Snapshots"}))," ",(0,r.kt)("a",{parentName:"p",href:"https://javadoc.io/doc/dev.zio/zio-sql-docs_2.13"},(0,r.kt)("img",{parentName:"a",src:"https://javadoc.io/badge2/dev.zio/zio-sql-docs_2.13/javadoc.svg",alt:"javadoc"}))," ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zio/zio-sql"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/github/stars/zio/zio-sql?style=social",alt:"ZIO SQL"}))),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Type-safety"),". ZIO SQL queries are type-safe by construction. Most classes of bugs can be detected at compile-time, shortening your feedback loop and helping you use your IDE to write correct queries."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Composable"),". All ZIO SQL components are ordinary values, which can be transformed and composed in sensible ways. This uniformity and regularity means you have a lot of power in a small package."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Type-inferred"),". ZIO SQL uses maximal variance and lower-kinded types, which means it features very good type inference. You can let Scala figure out the types required for type-safe SQL."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"No magic"),". ZIO SQL does not need any macros or plug-ins to operate (everything is a value!), and it works across both Scala 2.x and Scala 3. Optionally, Scala schema can be created from database schemas.")),(0,r.kt)("p",null,"ZIO SQL can be used as a library for modeling SQL in a type-safe ADT. In addition, ZIO SQL has a JDBC interface, which utilizes the type-safe SQL ADT for interacting with common JDBC databases."),(0,r.kt)("p",null,"For the JDBC module:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Like Slick, ZIO SQL has an emphasis on type-safe SQL construction using Scala values and methods. However, ZIO SQL utilizes reified lenses, contravariant intersection types, and in-query nullability to improve ergonomics for end-users. Unlike Slick, the intention is to use names resembling SQL instead of trying to mimic the Scala collections."),(0,r.kt)("li",{parentName:"ul"},"Like Doobie, ZIO SQL is purely functional, but ZIO SQL does compile-time query validation that catches most issues, and has rich ZIO integration, offering improved type-safety compared to monofunctor effects and minimal dependencies (depending only on ZIO).")),(0,r.kt)("p",null,"ZIO SQL does not offer Language Integrated Queries (LINQ) or similar functionality. It is intended only as a data model for representing SQL queries and an accompanying lightweight JDBC-based executor."),(0,r.kt)("h2",{id:"current-status-non-production-release"},"Current status: Non-production release"),(0,r.kt)("h3",{id:"progress-report-towards-01"},"Progress report towards 0.1"),(0,r.kt)("p",null,"\u2714\ufe0f - good to go"),(0,r.kt)("p",null,"\u2705 - some more work needed"),(0,r.kt)("h4",{id:"general-features"},"General features:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Feature"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Progress"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Type-safe schema"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Type-safe DSL"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Running Reads"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Running Deletes"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Running Updates"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Running Inserts"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Transactions"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Connection pool"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2705")))),(0,r.kt)("h4",{id:"db-specific-features"},"Db-specific features:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Feature"),(0,r.kt)("th",{parentName:"tr",align:"left"},"PostgreSQL"),(0,r.kt)("th",{parentName:"tr",align:"left"},"SQL Server"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Oracle"),(0,r.kt)("th",{parentName:"tr",align:"left"},"MySQL"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Render Read"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Render Delete"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Render Update"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Render Insert"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Functions"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2714\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Types"),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"left"}),(0,r.kt)("td",{parentName:"tr",align:"left"}),(0,r.kt)("td",{parentName:"tr",align:"left"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Operators"),(0,r.kt)("td",{parentName:"tr",align:"left"}),(0,r.kt)("td",{parentName:"tr",align:"left"}),(0,r.kt)("td",{parentName:"tr",align:"left"}),(0,r.kt)("td",{parentName:"tr",align:"left"})))),(0,r.kt)("h2",{id:"installation"},"Installation"),(0,r.kt)("p",null,"ZIO SQL is packaged into separate modules for different databases. Depending on which of these (currently supported) systems you're using, you will need to add one of the following dependencies:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'//PostgreSQL\nlibraryDependencies += "dev.zio" %% "zio-sql-postgres" % "0.1.2" \n\n//MySQL\nlibraryDependencies += "dev.zio" %% "zio-sql-mysql" % "0.1.2"\n\n//Oracle\nlibraryDependencies += "dev.zio" %% "zio-sql-oracle" % "0.1.2"\n\n//SQL Server\nlibraryDependencies += "dev.zio" %% "zio-sql-sqlserver" % "0.1.2"\n')),(0,r.kt)("h2",{id:"imports-and-modules"},"Imports and modules"),(0,r.kt)("p",null,"Most of the needed imports will be resolved with"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.sql._\n")),(0,r.kt)("p",null,"ZIO SQL relies heavily on path dependent types, so to use most of the features you need to be in the scope of one of the database modules:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait MyRepositoryModule extends PostgresModule {\n\n  // your ZIO SQL code here\n\n}\n\n// other available modules are MysqlModule, OracleModule and SqlServerModule\n")),(0,r.kt)("p",null,"We will assume this scope in the following examples."),(0,r.kt)("h2",{id:"table-schema"},"Table schema"),(0,r.kt)("p",null,"In order to construct correct and type-safe queries, we need to describe tables by writing user defined data type - case class in which\nname of the case class represents table name, field names represent column names and field types represent column types."),(0,r.kt)("p",null,"Values that will represent tables in DSL are then created by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"defineTable")," method which takes case class type parameter.\nIn order for ",(0,r.kt)("inlineCode",{parentName:"p"},"defineTable")," to work, user need to provide implicit ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema")," of data type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import java.util.UUID\nimport zio.sql.postgresql.PostgresJdbcModule\nimport java.time._\n\nobject Repository extends PostgresJdbcModule {\n  final case class Product(id: UUID, name: String, price: BigDecimal)\n  implicit val productSchema = DeriveSchema.gen[Product]\n\n  val products = defineTableSmart[Product]\n  \n  final case class Order(id: UUID, productId: UUID, quantity: Int, orderDate: LocalDate)\n  implicit val orderSchema = DeriveSchema.gen[Order]\n  \n  val orders = defineTable[Order]\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"defineTable")," method is overloaded with an alternative that takes table name as an input. User can also specify table name using ",(0,r.kt)("inlineCode",{parentName:"p"},"@name")," annotation.\nAlternatively user can use ",(0,r.kt)("inlineCode",{parentName:"p"},"defineTableSmart")," method which will smartly pluralize table name according to english grammar.\n",(0,r.kt)("inlineCode",{parentName:"p"},"OrderOrigin")," -> ",(0,r.kt)("inlineCode",{parentName:"p"},"order_origins"),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"Foot")," -> ",(0,r.kt)("inlineCode",{parentName:"p"},"feet"),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"PersonAddress")," -> ",(0,r.kt)("inlineCode",{parentName:"p"},"person_addresses"),"\nField names are also converted to lowercase and snake case.\n",(0,r.kt)("inlineCode",{parentName:"p"},"productId")," -> ",(0,r.kt)("inlineCode",{parentName:"p"},"product_id")," and so on."),(0,r.kt)("h2",{id:"table-schema-decomposition"},"Table schema decomposition"),(0,r.kt)("p",null,"Once we have our table definition we need to decompose table into columns which we will use in queries.\nUsing the previous example with ",(0,r.kt)("inlineCode",{parentName:"p"},"Product")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Order")," table"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val (id, name, price) = products.columns\n\nval (orderId, productId, quantity) = orders.columns\n")),(0,r.kt)("h2",{id:"selects"},"Selects"),(0,r.kt)("p",null,"Simple select."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val allProducts = select(productId, name, price).from(products)\n")),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"where")," clause."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def productById(id: UUID) = \n  select(productId, name, price).from(products).where(productId === id)\n")),(0,r.kt)("p",null,"Inner join."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val ordersWithProductNames = \n  select(orderId, name).from(products.join(orders).on(productId === fkProductId))\n")),(0,r.kt)("p",null,"Left outer join."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val leftOuter = \n  select(orderId, name).from(products.leftOuter(orders).on(productId === fkProductId))\n")),(0,r.kt)("p",null,"Right outer join."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val rightOuter = \n  select(orderId, name).from(products.rightOuter(orders).on(productId === fkProductId))\n")),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"limit")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"offset")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val limitedResults = \n  select(orderId, name)\n    .from(products.join(orders)\n    .on(productId === fkProductId))\n    .limit(5)\n    .offset(10)\n")),(0,r.kt)("h2",{id:"inserts"},"Inserts"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'insertInto(products)\n    (productId, name, price)\n  .values((UUID.randomUUID(), "Zionomicon", 10.5))\n')),(0,r.kt)("h2",{id:"updates"},"Updates"),(0,r.kt)("p",null,"TODO: details"),(0,r.kt)("h2",{id:"deletes"},"Deletes"),(0,r.kt)("p",null,"TODO: details"),(0,r.kt)("h2",{id:"transactions"},"Transactions"),(0,r.kt)("p",null,"TODO: details"),(0,r.kt)("h2",{id:"printing-queries"},"Printing queries"),(0,r.kt)("p",null,"TODO: details"),(0,r.kt)("h2",{id:"running-queries"},"Running queries"),(0,r.kt)("p",null,"TODO: details"))}u.isMDXComponent=!0}}]);