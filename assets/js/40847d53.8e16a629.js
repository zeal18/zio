"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[84513],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,h=u["".concat(l,".").concat(m)]||u[m]||c[m]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},23478:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const i={id:"debug",title:"Debug"},o=void 0,s={unversionedId:"zio-prelude/functional-abstractions/concrete-types/debug",id:"zio-prelude/functional-abstractions/concrete-types/debug",title:"Debug",description:"Debug[A] describes the ability to render a value of type A to a human readable format for debugging purposes.",source:"@site/docs/zio-prelude/functional-abstractions/concrete-types/debug.md",sourceDirName:"zio-prelude/functional-abstractions/concrete-types",slug:"/zio-prelude/functional-abstractions/concrete-types/debug",permalink:"/zio-prelude/functional-abstractions/concrete-types/debug",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/concrete-types/debug.md",tags:[],version:"current",frontMatter:{id:"debug",title:"Debug"},sidebar:"ecosystem-sidebar",previous:{title:"Commutative",permalink:"/zio-prelude/functional-abstractions/concrete-types/commutative"},next:{title:"Equal",permalink:"/zio-prelude/functional-abstractions/concrete-types/equal"}},l={},p=[{value:"Structured Rendering",id:"structured-rendering",level:2},{value:"Defining Debug Instances",id:"defining-debug-instances",level:2},{value:"Rendering",id:"rendering",level:2}],d={toc:p},u="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Debug[A]")," describes the ability to render a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," to a human readable format for debugging purposes."),(0,r.kt)("p",null,"Its signature is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait Debug[-A] {\n  def debug(a: A): Debug.Repr\n}\n\nobject Debug {\n\n  sealed trait Renderer\n\n  sealed trait Repr {\n    def render: String\n    def render(renderer: Renderer): String\n  }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Repr")," here is a data structure that captures the information needed to render a data type in a structured format so that it can be displayed in different ways. A ",(0,r.kt)("inlineCode",{parentName:"p"},"Renderer")," is a data type that knows how to render a ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr")," to a particular string representation, for example using short names for readability or fully qualified names for using the rendered output as valid code."),(0,r.kt)("p",null,"If we import ",(0,r.kt)("inlineCode",{parentName:"p"},"zio.prelude._")," then we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"debug")," operator on any data type with a ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," instance defined for it. We can also just use the ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," operator on any data type with a ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," instance defined for it to render it to a simple string representation."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," abstraction is the functional equivalent of the ",(0,r.kt)("inlineCode",{parentName:"p"},"toString")," operator but it has several advantages over just using ",(0,r.kt)("inlineCode",{parentName:"p"},"toString"),"."),(0,r.kt)("p",null,"First, as with other functional abstractions we can define when it makes sense to render a data type at all."),(0,r.kt)("p",null,"We can call ",(0,r.kt)("inlineCode",{parentName:"p"},"toString")," on anything including classes whose string representation only points to their memory address. Fortunately this is more often the cause of annoyance than real bugs but it is certainly nice to know when there isn't much point in trying to render something."),(0,r.kt)("p",null,"Related to this, we can define our own way of rendering for data types that are not under our control. For example, if we are debugging code involving arrays we can frequently be frustrated when the string representation of the array consists of its memory location rather than the elements actually in the array."),(0,r.kt)("p",null,"With ZIO Prelude, we can easily define a ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," instance for ",(0,r.kt)("inlineCode",{parentName:"p"},"Array"),". We can even handle nested arrays."),(0,r.kt)("p",null,"The final advantage that the ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," abstraction has over the Scala standard library and older functional programming libraries is that it captures rendering information in a structured data format instead of just a ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,r.kt)("p",null,"When we render a data type we may want to do it in various ways. We may want to do it using short names for a readable description in the context of a discussion like this one, rendering it as something like ",(0,r.kt)("inlineCode",{parentName:"p"},"Validation[String, Int]"),"."),(0,r.kt)("p",null,"In another context like being able to copy and paste our rendering into a REPL, IDE, or worksheet and having it compile we may want to use fully qualified names, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"zio.prelude.Validation[scala.String, scala.Int]"),". Or we may decide that including the fully qualified name for standard library types is a little too much, and want to render this as ",(0,r.kt)("inlineCode",{parentName:"p"},"zio.prelude.Validation[String, Int]"),"."),(0,r.kt)("p",null,"All of these are valid choices, but just rendering values as a ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," forces us to choose one. A ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," does not have enough structure to preserve all the information we need for rendering different ways so we are forced to choose one arbitrarily."),(0,r.kt)("p",null,"This also allows us to define meaningful laws for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," abstraction. In other functional programming libraries interfaces that provide similar functionality are essentially lawless since there is nothing describing what this string representation should look like."),(0,r.kt)("p",null,"In contrast, in ZIO Prelude ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," follows a well defined law that the Scala rendering of any data type should itself be valid Scala code."),(0,r.kt)("h2",{id:"structured-rendering"},"Structured Rendering"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr")," data type preserves all the information we need to render a data type to a ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," in various ways. There is nothing magic about this data type, it is just an algebraic data type with a variety of cases representing the different possible pieces of information we could need for rendering."),(0,r.kt)("p",null,"If you just want to render data types from ZIO or the Scala standard library that have meaningful string representations then you can just use the ",(0,r.kt)("inlineCode",{parentName:"p"},"debug")," operator but if you want to define ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," instances for your own data type it is helpful to understand usage of ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr"),"."),(0,r.kt)("p",null,"Most of the cases of ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr"),' are "simple" cases that just describe existing primitive data types.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait Repr\n\nobject Repr {\n  case class Int(value: scala.Int)           extends Repr\n  case class Double(value: scala.Double)     extends Repr\n  case class Float(value: scala.Long)        extends Repr\n  case class Long(value: scala.Long)         extends Repr\n  case class Byte(value: scala.Byte)         extends Repr\n  case class Char(value: scala.Char)         extends Repr\n  case class Boolean(value: scala.Boolean)   extends Repr\n  case class Short(value: scala.Short)       extends Repr\n  case class String(value: java.lang.String) extends Repr\n}\n")),(0,r.kt)("p",null,"As you can see these cases are indeed quite straightforward other than the minor complexity of avoiding name collisions with the underlying data types."),(0,r.kt)("p",null,"With these representations we can describe the structure of primitive values in a way that supports structured rendering. For example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"42")," would be ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr.Int(42)")," and we could match on it to render it in various ways such as ",(0,r.kt)("inlineCode",{parentName:"p"},"42")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Int: 42"),"."),(0,r.kt)("p",null,"The next case, ",(0,r.kt)("inlineCode",{parentName:"p"},"Object"),", lets us define our own primitive types."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"object Repr {\n  case class Object(namespace: List[java.lang.String], name: java.lang.String) extends Repr\n}\n")),(0,r.kt)("p",null,"As its name implies, this lets us define representations for data types like objects that aren't existing primitive types but also do not depend on other data types for their rendering. The information needed to render an object is just the name of the object and its namespace."),(0,r.kt)("p",null,"For example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," would be ",(0,r.kt)("inlineCode",{parentName:"p"},'Repr.Object(List("scala"), "None")'),". Note how the namespace gives us the information we need to render the ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr")," as valid Scala code and gives us the ability to decide at the time of rendering whether we want to include some or all of this or just the name itself."),(0,r.kt)("p",null,"The final cases of ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr")," let us build more complex data types such as sum types, product types, and collections from simpler ones."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.collection.immutable.ListMap\n\nobject Repr {\n  case class VConstructor(\n    namespace: List[java.lang.String],\n    name: java.lang.String,\n    reprs: List[Repr]\n  ) extends Repr\n  case class Constructor(\n    namespace: List[java.lang.String],\n    name: java.lang.String,\n    reprs: ListMap[java.lang.String, Repr]\n  ) extends Repr\n  case class KeyValue(\n    key: Repr,\n    value: Repr\n  ) extends Repr\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"VConstructor")," case mirrors the constructor arguments of a class or case class. Just like the ",(0,r.kt)("inlineCode",{parentName:"p"},"Object")," constructor it contains a namespace and name but now it also has a list of ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr")," values describing how each of the constructor parameters can be rendered."),(0,r.kt)("p",null,"For example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"Some(42)")," would be ",(0,r.kt)("inlineCode",{parentName:"p"},'Repr.VConstructor(List("scala"), "Some", List(Repr.Int(42)))'),". Again, this gives us everything we need to render the value in different ways."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Constructor")," case is like ",(0,r.kt)("inlineCode",{parentName:"p"},"VConstructor")," but mirrors a data type like a case class with named fields. The list of constructor arguments now included the name of each constructor argument along with its representation."),(0,r.kt)("p",null,"For example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr")," of ",(0,r.kt)("inlineCode",{parentName:"p"},'Person("John", 42)')," would be ",(0,r.kt)("inlineCode",{parentName:"p"},'Repr.Constructor(List.empty, "Person", Map("name" -> Repr.String("John"), "age" -> Repr.Int(42)))'),". The names of the constructor arguments may or may not be shown depending on the renderer used."),(0,r.kt)("p",null,"The final case is ",(0,r.kt)("inlineCode",{parentName:"p"},"KeyValue"),", which covers situations where the constructor arguments are key value pairs, like in a ",(0,r.kt)("inlineCode",{parentName:"p"},"Map"),". We capture this separately so we can render them appropriately, for example using ",(0,r.kt)("inlineCode",{parentName:"p"},"->")," to ensure that we can render the key value pairs as valid code."),(0,r.kt)("p",null,"Most of the time you won't have to use most of these constructors yourself but it is helpful to know what they are since you will often have to use one or two in defining your own ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," instances, typically the ",(0,r.kt)("inlineCode",{parentName:"p"},"Object"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"VConstructor"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"Constructor")," cases."),(0,r.kt)("h2",{id:"defining-debug-instances"},"Defining Debug Instances"),(0,r.kt)("p",null,"ZIO Prelude comes with ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," instances defined for all data types with meaningful string representations in ZIO and the Scala standard library, as well as data types composed of those types."),(0,r.kt)("p",null,"To define a ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," instance for your own data type you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"make")," operator which requires you to specify how to create a representation of your own data type. Typically you can do this just by using one of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr")," constructors such as ",(0,r.kt)("inlineCode",{parentName:"p"},"Constructor"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Object"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"VConstructor")," and using the ",(0,r.kt)("inlineCode",{parentName:"p"},"debug")," operator on any values that are inside your data type."),(0,r.kt)("p",null,"For example, here is how we could define a ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," instance for a ",(0,r.kt)("inlineCode",{parentName:"p"},"Person")," data type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.prelude._\n\ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val PersonDebug: Debug[Person] =\n    Debug.make { case Person(name, age) =>\n      Debug.Repr.Constructor(\n        List.empty,\n        "Person",\n        "name" -> name.debug,\n        "age"  -> age.debug\n      )\n    }\n}\n')),(0,r.kt)("p",null,"Notice how we used the ",(0,r.kt)("inlineCode",{parentName:"p"},"debug")," operator on ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"age"),". In this simple case we could have used ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr.String(name)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr.Int(age)")," but this would not have worked if the constructor values were more complex and would have forced us to spend more time working with ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr")," directly."),(0,r.kt)("p",null,"We can use the same strategy to define ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," instances for polymorphic data types. We just need to add a constraint that there is a ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," instance for the different types that we want to render."),(0,r.kt)("p",null,"For example, here is how we could define a ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," instance for a simplified version of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Validation")," data type from ZIO Prelude."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.NonEmptyChunk\n\nsealed trait Validation[+E, +A]\n\nobject Validation {\n\n  case class Success[+A](a: A) extends Validation[Nothing, A]\n  case class Failure[+E](es: NonEmptyChunk[E]) extends Validation[E, Nothing]\n\n  implicit def ValidationDebug[E: Debug, A: Debug]: Debug[Validation[E, A]] =\n    Debug.make {\n      case Success(a)  => Debug.Repr.VConstructor(List("zio", "prelude"), "Validation.Success", List(a.debug))\n      case Failure(es) => Debug.Repr.VConstructor(List("zio", "prelude"), "Validation.Failure", List(es.debug))\n    }\n}\n')),(0,r.kt)("p",null,"Here we used context bounds of ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," for the ",(0,r.kt)("inlineCode",{parentName:"p"},"E")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," type parameters to require that ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," instances for them exist. This makes sense because there is no way we can create a meaningful string representation of a value if we can't create meaningful string representations of its components."),(0,r.kt)("h2",{id:"rendering"},"Rendering"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr")," data type returned by the ",(0,r.kt)("inlineCode",{parentName:"p"},"debug")," operator is just a representation of the data type in a way that supports meaningful string rendering. To actually get a string we still need to render it with its ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," operator."),(0,r.kt)("p",null,"The easiest way to do that is to call the ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," operator directly, which uses a default renderer that renders data in a simple way that is being read by humans but is not necessarily valid Scala code. If we want to, we can call ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," with an argument and provide a ",(0,r.kt)("inlineCode",{parentName:"p"},"Renderer")," to render the representation in a different way."),(0,r.kt)("p",null,"ZIO Prelude comes with two other renderers."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Scala")," renderer renders data as valid Scala code that you can copy and paste into an IDE, REPL, or worksheet. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Full")," renderer renders data with as much detail as possible, including information like field names where available, and can be helpful for debugging purposes."),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Renderer")," is just a function that takes a ",(0,r.kt)("inlineCode",{parentName:"p"},"Repr")," and returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),", so you can also define your own ",(0,r.kt)("inlineCode",{parentName:"p"},"Renderer")," if you want to. ZIO Prelude's ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," abstraction preserves all the information so you can render your data types the way you want to."))}c.isMDXComponent=!0}}]);