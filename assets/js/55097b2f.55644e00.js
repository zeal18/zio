"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[9224],{3905:(e,n,a)=>{a.d(n,{Zo:()=>p,kt:()=>h});var t=a(67294);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function s(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function l(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=t.createContext({}),c=function(e){var n=t.useContext(o),a=n;return e&&(a="function"==typeof e?e(n):s(s({},n),e)),a},p=function(e){var n=c(e.components);return t.createElement(o.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(a),u=i,h=m["".concat(o,".").concat(u)]||m[u]||d[u]||r;return a?t.createElement(h,s(s({ref:n},p),{},{components:a})):t.createElement(h,s({ref:n},p))}));function h(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=u;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l[m]="string"==typeof e?e:i,s[1]=l;for(var c=2;c<r;c++)s[c]=a[c];return t.createElement.apply(null,s)}return t.createElement.apply(null,a)}u.displayName="MDXCreateElement"},6346:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var t=a(87462),i=(a(67294),a(3905));const r={id:"understanding-zio-schema",title:"Understanding ZIO Schema"},s=void 0,l={unversionedId:"zio-schema/understanding-zio-schema",id:"zio-schema/understanding-zio-schema",title:"Understanding ZIO Schema",description:"ZIO Schema is a library used in many ZIO projects such as ZIO Flow, ZIO Redis, ZIO Web, ZIO SQL and ZIO DynamoDB.",source:"@site/docs/zio-schema/understanding-zio-schema.md",sourceDirName:"zio-schema",slug:"/zio-schema/understanding-zio-schema",permalink:"/zio-schema/understanding-zio-schema",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-schema/understanding-zio-schema.md",tags:[],version:"current",frontMatter:{id:"understanding-zio-schema",title:"Understanding ZIO Schema"},sidebar:"ecosystem-sidebar",previous:{title:"Our First Schema",permalink:"/zio-schema/our-first-schema"},next:{title:"ZIO Telemetry",permalink:"/zio-telemetry/"}},o={},c=[{value:"Reification: Functional Effects",id:"reification-functional-effects",level:2},{value:"Reification: Optics",id:"reification-optics",level:2},{value:"Reification: Schema",id:"reification-schema",level:2},{value:"Getting started",id:"getting-started",level:2},{value:"Basic Building Blocks",id:"basic-building-blocks",level:3},{value:"Schema",id:"schema",level:4},{value:"Records",id:"records",level:4},{value:"Enumerations",id:"enumerations",level:4},{value:"Sequence",id:"sequence",level:4},{value:"Optionals",id:"optionals",level:4},{value:"Primitives",id:"primitives",level:4},{value:"Transforming Schemas",id:"transforming-schemas",level:3},{value:"Codecs",id:"codecs",level:4}],p={toc:c},m="wrapper";function d(e){let{components:n,...a}=e;return(0,i.kt)(m,(0,t.Z)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"ZIO Schema is a library used in many ZIO projects such as ",(0,i.kt)("em",{parentName:"p"},"ZIO Flow"),", ",(0,i.kt)("em",{parentName:"p"},"ZIO Redis"),", ",(0,i.kt)("em",{parentName:"p"},"ZIO Web"),", ",(0,i.kt)("em",{parentName:"p"},"ZIO SQL")," and ",(0,i.kt)("em",{parentName:"p"},"ZIO DynamoDB"),'.\nZIO is all about reification of your types. Reification means transforming something abstract (e.g. side effects, accessing fields, structure)  into something "real" (values).'),(0,i.kt)("h2",{id:"reification-functional-effects"},"Reification: Functional Effects"),(0,i.kt)("p",null,"In functional effects, we reify by turning side-effects into values."),(0,i.kt)("p",null,"E.g. you might have a simple statement like"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'println("Hello")\nprintln("World")\n')),(0,i.kt)("p",null,"and in ZIO we reify this statement to a value like"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val effect1 = Task(println("Hello"))\nval effect2 = Task(println("World"))\n')),(0,i.kt)("p",null,"and then are able to do awesome things like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'(Task(println("Hello")) zipPar Task(println("World"))).retryN(100)\n')),(0,i.kt)("h2",{id:"reification-optics"},"Reification: Optics"),(0,i.kt)("p",null,"In scala we have product types like this case class of a Person:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"final case class Person(name: String, age: Int)\n")),(0,i.kt)("p",null,"This case class has two fields:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'a field "name" of type ',(0,i.kt)("inlineCode",{parentName:"li"},"String")),(0,i.kt)("li",{parentName:"ul"},'a field "age" of type ',(0,i.kt)("inlineCode",{parentName:"li"},"Int"))),(0,i.kt)("p",null,"The Scala language provides special support to access the fields inside case classes using the dot syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val person = Person("Michelle", 32)\nval name = person.name\nval age  = person.age\n')),(0,i.kt)("p",null,'However, this is a "special language feature", it\'s not "real" like the side effects we\'ve seen in the previous example ( ',(0,i.kt)("inlineCode",{parentName:"p"},"println(..) vs. Task"),"println(...)))` )."),(0,i.kt)("p",null,'Because these basic operations are not "real", we\'re unable to create an operator that we can use to\ne.g. combine two fields that are inside a nested structure.'),(0,i.kt)("p",null,'The solution to this kind of problem is called an "Optic". Optics provide a way to access the fields of a case class and nested structures.\nThere are three main types of optics:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Lens"),": A lens is a way to access a field of a case class."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Prism"),": A prism is a way to access a field of a nested structure or a collection."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Traversal"),": A traversal is a way to access all fields of a case class, nested structures or collections.")),(0,i.kt)("p",null,"Optics allow us to take things which are not a first-class ",(0,i.kt)("strong",{parentName:"p"},"concept"),", and turn that into a first-class ",(0,i.kt)("strong",{parentName:"p"},"value"),",\nnamely the concept of"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"drilling down into a field inside a case class or"),(0,i.kt)("li",{parentName:"ul"},"drilling down into a nested structure.")),(0,i.kt)("p",null,"Once we have a value, we can compose these things together to solve hard problems in functional programming, e.g."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"handling nested case class copies,"),(0,i.kt)("li",{parentName:"ul"},"iterations down deep inside on elements of a nested structure or collections")),(0,i.kt)("p",null,"For more information on optics, refer to the ",(0,i.kt)("a",{parentName:"p",href:"https://zio.github.io/zio-optics/docs/overview/overview_index"},"ZIO Optics")," documentation."),(0,i.kt)("h2",{id:"reification-schema"},"Reification: Schema"),(0,i.kt)("p",null,"So far we've looked at how to"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"reify side-effects into values (ZIO)"),(0,i.kt)("li",{parentName:"ul"},"how to reify accessing + modifying fields inside case classes or arbitrary structures by turning these operations into values as well (Optics)")),(0,i.kt)("p",null,"ZIO Schema is now about how to describe entire data structures using values."),(0,i.kt)("p",null,'The "built-in" way in scala on how to describe data structures are ',(0,i.kt)("inlineCode",{parentName:"p"},"case classes")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"classes"),"."),(0,i.kt)("p",null,"E.g. the following data type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"final case class Person(name: String, age: Int)\n")),(0,i.kt)("p",null,"Has the following information:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'name of the structure: "Person"'),(0,i.kt)("li",{parentName:"ul"},'fields: "name" and "age"'),(0,i.kt)("li",{parentName:"ul"},"type of the fields: String and Int"),(0,i.kt)("li",{parentName:"ul"},"type of the structure: Person")),(0,i.kt)("p",null,"ZIO Schema tries to reify the concept of structure for datatypes by turning the above information into values."),(0,i.kt)("p",null,"Not only for case classes, but also for other types like collections, tuples, enumerations etc."),(0,i.kt)("h2",{id:"getting-started"},"Getting started"),(0,i.kt)("p",null,"To get started, first you need to understand that a ZIO Schema is basically built-up from these three\nsealed traits:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Record[R]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Enum[A]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Sequence[Col, Elem]"),"\nand the case class ",(0,i.kt)("inlineCode",{parentName:"li"},"Primitive[A]"),". Every other type is just a specialisation of one of these (or not relevant to get you started).")),(0,i.kt)("p",null,"We will take a look at them now."),(0,i.kt)("h3",{id:"basic-building-blocks"},"Basic Building Blocks"),(0,i.kt)("h4",{id:"schema"},"Schema"),(0,i.kt)("p",null,"The core data type of ZIO Schema is a ",(0,i.kt)("inlineCode",{parentName:"p"},"Schema[A]")," which is ",(0,i.kt)("strong",{parentName:"p"},"invariant in ",(0,i.kt)("inlineCode",{parentName:"strong"},"A"))," by necessity, because a Schema allows you to\nderive operations that produce an ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," but also operations that consume an ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," and that imposes limitations on the types of\n",(0,i.kt)("strong",{parentName:"p"},"transformation operators")," and ",(0,i.kt)("strong",{parentName:"p"},"composition operators")," that we can provide based on a ",(0,i.kt)("inlineCode",{parentName:"p"},"Schema"),"."),(0,i.kt)("p",null,"It looks kind of like this (simplified):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait Schema[A] {\n  self =>\n  type Accessors[Lens[_, _], Prism[_, _], Traversal[_, _]]\n\n  /**\n   * A symbolic operator for [[optional]].\n   */\n  def ? : Schema[Option[A]] = self.optional\n\n  def makeAccessors(b: AccessorBuilder): Accessors[b.Lens, b.Prism, b.Traversal]\n  \n  /**\n   * Transforms this `Schema[A]` into a `Schema[B]`, by supplying two functions that can transform\n   * between `A` and `B`, without possibility of failure.\n   */\n  def transform[B](f: A => B, g: B => A): Schema[B] =\n    Schema.Transform[A, B](self, a => Right(f(a)), b => Right(g(b)))\n\n  def transformOrFail[B](f: A => Either[String, B], g: B => Either[String, A]): Schema[B] =\n    Schema.Transform[A, B](self, f, g)\n  \n  def zip[B](that: Schema[B]): Schema[(A, B)] = Schema.Tuple(self, that)\n}\n")),(0,i.kt)("h4",{id:"records"},"Records"),(0,i.kt)("p",null,"Your data structures usually are composed from a lot of types. For example, you might have a ",(0,i.kt)("inlineCode",{parentName:"p"},"User"),"\ntype that has a ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," field, an ",(0,i.kt)("inlineCode",{parentName:"p"},"age")," field, an ",(0,i.kt)("inlineCode",{parentName:"p"},"address")," field, and a ",(0,i.kt)("inlineCode",{parentName:"p"},"friends")," field."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class User(name: String, age: Int, address: Address, friends: List[User])\n")),(0,i.kt)("p",null,'This is called a "product type" in functional programming.\nThe equivalent of a product type in ZIO Schema is called a record.'),(0,i.kt)("p",null,"In ZIO Schema such a record would be represented using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Record[R]")," typeclass:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n  sealed trait Record[R] extends Schema[R] {\n    def structure: Chunk[Field[_]]\n    def annotations: Chunk[Any] = Chunk.empty\n    def rawConstruct(values: Chunk[Any]): Either[String, R]\n  }\n}\n\n")),(0,i.kt)("h4",{id:"enumerations"},"Enumerations"),(0,i.kt)("p",null,"Other times, you might have a type that represents a list of different types. For example, you might\nhave a type, like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  sealed trait PaymentMethod \n\n  object PaymentMethod {\n    final case class CreditCard(number: String, expirationMonth: Int, expirationYear: Int) extends PaymentMethod\n    final case class WireTransfer(accountNumber: String, bankCode: String) extends PaymentMethod\n  }\n")),(0,i.kt)("p",null,'In functional programming, this kind of type is called a "sum type".\nIn Scala2, this is called a "sealed trait".\nIn Scala3, this is called an "enum".'),(0,i.kt)("p",null,"In ZIO Schema we call these types ",(0,i.kt)("inlineCode",{parentName:"p"},"enumeration")," types and they are\nrepresented using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Enum[A]")," type class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object Schema ... {\n  sealed trait Enum[A] extends Schema[A] {\n    def annotations: Chunk[Any]\n    def structure: ListMap[String, Schema[_]]\n  }\n}\n")),(0,i.kt)("h4",{id:"sequence"},"Sequence"),(0,i.kt)("p",null,"Often you have a type that is a collection of elements. For example, you might have a ",(0,i.kt)("inlineCode",{parentName:"p"},"List[User]"),".\nThis is called a ",(0,i.kt)("inlineCode",{parentName:"p"},"Sequence")," and is represented using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Sequence[Col, Elem]")," type class:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'object Schema ... {\n  ...\n \n  final case class Sequence[Col, Elem](\n                                        elementSchema: Schema[Elem],\n                                        fromChunk: Chunk[Elem] => Col,\n                                        toChunk: Col => Chunk[Elem]\n                                      ) extends Schema[Col] {\n    self =>\n    override type Accessors[Lens[_, _], Prism[_, _], Traversal[_, _]] = Traversal[Col, Elem]\n    override def makeAccessors(b: AccessorBuilder): b.Traversal[Col, Elem] = b.makeTraversal(self, schemaA)\n    override def toString: String = s"Sequence($elementSchema)"\n  }\n  ...\n}\n')),(0,i.kt)("h4",{id:"optionals"},"Optionals"),(0,i.kt)("p",null,"A special variant of a collection type is the ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional[A]")," type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'object Schema ... {\n\n  final case class Optional[A](codec: Schema[A]) extends Schema[Option[A]] {\n    self =>\n\n    private[schema] val someCodec: Schema[Some[A]] = codec.transform(a => Some(a), _.get)\n\n    override type Accessors[Lens[_, _], Prism[_, _], Traversal[_, _]] =\n      (Prism[Option[A], Some[A]], Prism[Option[A], None.type])\n\n    val toEnum: Enum2[Some[A], None.type, Option[A]] = Enum2(\n      Case[Some[A], Option[A]]("Some", someCodec, _.asInstanceOf[Some[A]], Chunk.empty),\n      Case[None.type, Option[A]]("None", singleton(None), _.asInstanceOf[None.type], Chunk.empty),\n      Chunk.empty\n    )\n\n    override def makeAccessors(b: AccessorBuilder): (b.Prism[Option[A], Some[A]], b.Prism[Option[A], None.type]) =\n      b.makePrism(toEnum, toEnum.case1) -> b.makePrism(toEnum, toEnum.case2)\n  }\n\n}\n')),(0,i.kt)("h4",{id:"primitives"},"Primitives"),(0,i.kt)("p",null,"Last but not least, we have primitive values."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object Schema ... {\n  ...\n  final case class Primitive[A](standardType: StandardType[A]) extends Schema[A] {\n    type Accessors[Lens[_, _], Prism[_, _], Traversal[_, _]] = Unit\n\n    override def makeAccessors(b: AccessorBuilder): Unit = ()\n  }\n  ...\n}\n")),(0,i.kt)("p",null,"Primitive values are represented using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Primitive[A]")," type class and represent the elements,\nthat we cannot further define through other means. If you visualize your data structure as a tree,\nprimitives are the leaves."),(0,i.kt)("p",null,"ZIO Schema provides a number of built-in primitive types, that you can use to represent your data.\nThese can be found in the ",(0,i.kt)("inlineCode",{parentName:"p"},"StandardType")," companion-object."),(0,i.kt)("h3",{id:"transforming-schemas"},"Transforming Schemas"),(0,i.kt)("p",null,"Once we have a ",(0,i.kt)("inlineCode",{parentName:"p"},"Schema"),", we can transform it into another ",(0,i.kt)("inlineCode",{parentName:"p"},"Schema")," by applying a ",(0,i.kt)("inlineCode",{parentName:"p"},"Transformer"),".\nIn normal Scala code this would be the equivalent of ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,i.kt)("p",null,"In ZIO Schema this is modelled by the ",(0,i.kt)("inlineCode",{parentName:"p"},"Transform")," type class:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'  final case class Transform[A, B](codec: Schema[A], f: A => Either[String, B], g: B => Either[String, A])\n      extends Schema[B] {\n    override type Accessors[Lens[_, _], Prism[_, _], Traversal[_, _]] = codec.Accessors[Lens, Prism, Traversal]\n\n    override def makeAccessors(b: AccessorBuilder): codec.Accessors[b.Lens, b.Prism, b.Traversal] =\n      codec.makeAccessors(b)\n\n    override def serializable: Schema[Schema[_]] = Meta(SchemaAst.fromSchema(codec))\n    override def toString: String                = s"Transform($codec)"\n  }\n')),(0,i.kt)("p",null,"In the example above, we can transform the ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," Schema into a ",(0,i.kt)("inlineCode",{parentName:"p"},"UserRecord")," Schema, which is a record,\nby using the ",(0,i.kt)("inlineCode",{parentName:"p"},"transform"),'-method, which has to be an "isomorphism" (= providing methods to transform A to B ',(0,i.kt)("em",{parentName:"p"},"and")," B to A):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  /**\n   * Transforms this `Schema[A]` into a `Schema[B]`, by supplying two functions that can transform\n   * between `A` and `B`, without possibility of failure.\n   */\n  def transform[B](f: A => B, g: B => A): Schema[B] =\n    Schema.Transform[A, B](self, a => Right(f(a)), b => Right(g(b)))\n")),(0,i.kt)("h4",{id:"codecs"},"Codecs"),(0,i.kt)("p",null,"Once you have your schema, you can combine it with a codec.\nA codec is a combination of a schema and a serializer.\nUnlike codecs in other libraries, a codec in ZIO Schema has no type parameter."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"\ntrait Codec {\n  def encoder[A](schema: Schema[A]): ZTransducer[Any, Nothing, A, Byte]\n  def decoder[A](schema: Schema[A]): ZTransducer[Any, String, Byte, A]\n\n  def encode[A](schema: Schema[A]): A => Chunk[Byte]\n  def decode[A](schema: Schema[A]): Chunk[Byte] => Either[String, A]\n}\n\n")),(0,i.kt)("p",null,"It basically says:\n",(0,i.kt)("inlineCode",{parentName:"p"},"encoder[A]"),": Given a ",(0,i.kt)("inlineCode",{parentName:"p"},"Schema[A]")," it is capable of generating an ",(0,i.kt)("inlineCode",{parentName:"p"},"Encoder[A]")," ( ",(0,i.kt)("inlineCode",{parentName:"p"},"A => Chunk[Byte]"),") for any Schema.\n",(0,i.kt)("inlineCode",{parentName:"p"},"decoder[A]"),": Given a ",(0,i.kt)("inlineCode",{parentName:"p"},"Schema[A]")," it is capable of generating a ",(0,i.kt)("inlineCode",{parentName:"p"},"Decoder[A]")," ( ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk[Byte] => Either[String, A]"),") for any Schema."),(0,i.kt)("p",null,"Example of possible codecs are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"CSV Codec"),(0,i.kt)("li",{parentName:"ul"},"JSON Codec (already available)"),(0,i.kt)("li",{parentName:"ul"},"Apache Avro Codec (in progress)"),(0,i.kt)("li",{parentName:"ul"},"Apache Thrift Codec (in progress)"),(0,i.kt)("li",{parentName:"ul"},"XML Codec"),(0,i.kt)("li",{parentName:"ul"},"YAML Codec"),(0,i.kt)("li",{parentName:"ul"},"Protobuf Codec (already available)"),(0,i.kt)("li",{parentName:"ul"},"QueryString Codec"),(0,i.kt)("li",{parentName:"ul"},"etc.")))}d.isMDXComponent=!0}}]);