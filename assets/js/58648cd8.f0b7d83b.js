"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[18938],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},u="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=s(n),d=r,m=u["".concat(c,".").concat(d)]||u[d]||f[d]||o;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[u]="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},51725:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>f,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var a=n(87462),r=(n(67294),n(3905));const o={id:"overview_creating_effects",title:"Creating Effects"},i=void 0,l={unversionedId:"overview/overview_creating_effects",id:"version-1.0.18/overview/overview_creating_effects",title:"Creating Effects",description:"This section explores some of the common ways to create ZIO effects from values, from common Scala types, and from both synchronous and asynchronous side-effects.",source:"@site/versioned_docs/version-1.0.18/overview/creating_effects.md",sourceDirName:"overview",slug:"/overview/overview_creating_effects",permalink:"/1.0.18/overview/overview_creating_effects",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/overview/creating_effects.md",tags:[],version:"1.0.18",frontMatter:{id:"overview_creating_effects",title:"Creating Effects"},sidebar:"overview_sidebar",previous:{title:"Summary",permalink:"/1.0.18/overview/"},next:{title:"Basic Operations",permalink:"/1.0.18/overview/overview_basic_operations"}},c={},s=[{value:"From Success Values",id:"from-success-values",level:2},{value:"From Failure Values",id:"from-failure-values",level:2},{value:"From Scala Values",id:"from-scala-values",level:2},{value:"Option",id:"option",level:3},{value:"Either",id:"either",level:3},{value:"Try",id:"try",level:3},{value:"Function",id:"function",level:3},{value:"Future",id:"future",level:3},{value:"From Side-Effects",id:"from-side-effects",level:2},{value:"Synchronous Side-Effects",id:"synchronous-side-effects",level:3},{value:"Asynchronous Side-Effects",id:"asynchronous-side-effects",level:3},{value:"Blocking Synchronous Side-Effects",id:"blocking-synchronous-side-effects",level:2},{value:"Next Steps",id:"next-steps",level:2}],p={toc:s},u="wrapper";function f(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This section explores some of the common ways to create ZIO effects from values, from common Scala types, and from both synchronous and asynchronous side-effects."),(0,r.kt)("h2",{id:"from-success-values"},"From Success Values"),(0,r.kt)("p",null,"Using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.succeed")," method, you can create an effect that succeeds with the specified value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val s1 = ZIO.succeed(42)\n")),(0,r.kt)("p",null,"You can also use methods in the companion objects of the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO")," type aliases:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val s2: Task[Int] = Task.succeed(42)\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"succeed")," method takes a by-name parameter to make sure that any accidental side effects from constructing the value can be properly managed by the ZIO Runtime. However, ",(0,r.kt)("inlineCode",{parentName:"p"},"succeed")," is intended for values which do not have any side effects. If you know that your value does have side effects consider using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.effectTotal")," for clarity."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val now = ZIO.effectTotal(System.currentTimeMillis())\n")),(0,r.kt)("p",null,"The value inside a successful effect constructed with ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.effectTotal")," will only be constructed if absolutely required."),(0,r.kt)("h2",{id:"from-failure-values"},"From Failure Values"),(0,r.kt)("p",null,"Using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.fail")," method, you can create an effect that models failure:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val f1 = ZIO.fail("Uh oh!")\n')),(0,r.kt)("p",null,"For the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO")," data type, there is no restriction on the error type. You may use strings, exceptions, or custom data types appropriate for your application."),(0,r.kt)("p",null,"Many applications will model failures with classes that extend ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Exception"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val f2 = Task.fail(new Exception("Uh oh!"))\n')),(0,r.kt)("p",null,"Note that unlike the other effect companion objects, the ",(0,r.kt)("inlineCode",{parentName:"p"},"UIO")," companion object does not have ",(0,r.kt)("inlineCode",{parentName:"p"},"UIO.fail"),", because ",(0,r.kt)("inlineCode",{parentName:"p"},"UIO")," values cannot fail."),(0,r.kt)("h2",{id:"from-scala-values"},"From Scala Values"),(0,r.kt)("p",null,"Scala's standard library contains a number of data types that can be converted into ZIO effects."),(0,r.kt)("h3",{id:"option"},"Option"),(0,r.kt)("p",null,"An ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," can be converted into a ZIO effect using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.fromOption"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val zoption: IO[Option[Nothing], Int] = ZIO.fromOption(Some(2))\n")),(0,r.kt)("p",null,"The error type of the resulting effect is ",(0,r.kt)("inlineCode",{parentName:"p"},"Option[Nothing]"),", which provides no information on why the value is not there. You can change the ",(0,r.kt)("inlineCode",{parentName:"p"},"Option[Nothing]")," into a more specific error type using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#mapError"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val zoption2: IO[String, Int] = zoption.mapError(_ => "It wasn\'t there!")\n')),(0,r.kt)("p",null,"You can also readily compose it with other operators while preserving the optional nature of the result (similar to an ",(0,r.kt)("inlineCode",{parentName:"p"},"OptionT"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val maybeId: IO[Option[Nothing], String] = ZIO.fromOption(Some("abc123"))\ndef getUser(userId: String): IO[Throwable, Option[User]] = ???\ndef getTeam(teamId: String): IO[Throwable, Team] = ???\n\n\nval result: IO[Throwable, Option[(User, Team)]] = (for {\n  id   <- maybeId\n  user <- getUser(id).some\n  team <- getTeam(user.teamId).asSomeError \n} yield (user, team)).optional \n')),(0,r.kt)("h3",{id:"either"},"Either"),(0,r.kt)("p",null,"An ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," can be converted into a ZIO effect using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.fromEither"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val zeither = ZIO.fromEither(Right("Success!"))\n')),(0,r.kt)("p",null,"The error type of the resulting effect will be whatever type the ",(0,r.kt)("inlineCode",{parentName:"p"},"Left")," case has, while the success type will be whatever type the ",(0,r.kt)("inlineCode",{parentName:"p"},"Right")," case has."),(0,r.kt)("h3",{id:"try"},"Try"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Try")," value can be converted into a ZIO effect using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.fromTry"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.util.Try\n\nval ztry = ZIO.fromTry(Try(42 / 0))\n")),(0,r.kt)("p",null,"The error type of the resulting effect will always be ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable"),", because ",(0,r.kt)("inlineCode",{parentName:"p"},"Try")," can only fail with values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable"),"."),(0,r.kt)("h3",{id:"function"},"Function"),(0,r.kt)("p",null,"A function ",(0,r.kt)("inlineCode",{parentName:"p"},"A => B")," can be converted into a ZIO effect with ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.fromFunction"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val zfun: URIO[Int, Int] =\n  ZIO.fromFunction((i: Int) => i * i)\n")),(0,r.kt)("p",null,"The environment type of the effect is ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," (the input type of the function), because in order to run the effect, it must be supplied with a value of this type."),(0,r.kt)("h3",{id:"future"},"Future"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Future")," can be converted into a ZIO effect using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.fromFuture"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import scala.concurrent.Future\n\nlazy val future = Future.successful("Hello!")\n\nval zfuture: Task[String] =\n  ZIO.fromFuture { implicit ec =>\n    future.map(_ => "Goodbye!")\n  }\n')),(0,r.kt)("p",null,"The function passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"fromFuture")," is passed an ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutionContext"),", which allows ZIO to manage where the ",(0,r.kt)("inlineCode",{parentName:"p"},"Future")," runs (of course, you can ignore this ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutionContext"),")."),(0,r.kt)("p",null,"The error type of the resulting effect will always be ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable"),", because ",(0,r.kt)("inlineCode",{parentName:"p"},"Future")," can only fail with values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable"),"."),(0,r.kt)("h2",{id:"from-side-effects"},"From Side-Effects"),(0,r.kt)("p",null,"ZIO can convert both synchronous and asynchronous side-effects into ZIO effects (pure values)."),(0,r.kt)("p",null,"These functions can be used to wrap procedural code, allowing you to seamlessly use all features of ZIO with legacy Scala and Java code, as well as third-party libraries."),(0,r.kt)("h3",{id:"synchronous-side-effects"},"Synchronous Side-Effects"),(0,r.kt)("p",null,"A synchronous side-effect can be converted into a ZIO effect using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.effect"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.io.StdIn\n\nval getStrLn: Task[String] =\n  ZIO.effect(StdIn.readLine())\n")),(0,r.kt)("p",null,"The error type of the resulting effect will always be ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable"),", because side-effects may throw exceptions with any value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable"),"."),(0,r.kt)("p",null,"If a given side-effect is known to not throw any exceptions, then the side-effect can be converted into a ZIO effect using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.effectTotal"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def putStrLn(line: String): UIO[Unit] =\n  ZIO.effectTotal(println(line))\n")),(0,r.kt)("p",null,"You should be careful when using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.effectTotal"),"\u2014when in doubt about whether or not a side-effect is total, prefer ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.effect")," to convert the effect."),(0,r.kt)("p",null,"If you wish to refine the error type of an effect (by treating other errors as fatal), then you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO#refineToOrDie")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import java.io.IOException\n\nval getStrLn2: IO[IOException, String] =\n  ZIO.effect(StdIn.readLine()).refineToOrDie[IOException]\n")),(0,r.kt)("h3",{id:"asynchronous-side-effects"},"Asynchronous Side-Effects"),(0,r.kt)("p",null,"An asynchronous side-effect with a callback-based API can be converted into a ZIO effect using ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.effectAsync"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"object legacy {\n  def login(\n    onSuccess: User => Unit,\n    onFailure: AuthError => Unit): Unit = ???\n}\n\nval login: IO[AuthError, User] =\n  IO.effectAsync[AuthError, User] { callback =>\n    legacy.login(\n      user => callback(IO.succeed(user)),\n      err  => callback(IO.fail(err))\n    )\n  }\n")),(0,r.kt)("p",null,"Asynchronous ZIO effects are much easier to use than callback-based APIs, and they benefit from ZIO features like interruption, resource-safety, and superior error handling."),(0,r.kt)("h2",{id:"blocking-synchronous-side-effects"},"Blocking Synchronous Side-Effects"),(0,r.kt)("p",null,"Some side-effects use blocking IO or otherwise put a thread into a waiting state. If not carefully managed, these side-effects can deplete threads from your application's main thread pool, resulting in work starvation."),(0,r.kt)("p",null,"ZIO provides the ",(0,r.kt)("inlineCode",{parentName:"p"},"zio.blocking")," package, which can be used to safely convert such blocking side-effects into ZIO effects."),(0,r.kt)("p",null,"A blocking side-effect can be converted directly into a ZIO effect blocking with the ",(0,r.kt)("inlineCode",{parentName:"p"},"effectBlocking")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.blocking._\n\nval sleeping =\n  effectBlocking(Thread.sleep(Long.MaxValue))\n")),(0,r.kt)("p",null,"The resulting effect will be executed on a separate thread pool designed specifically for blocking effects."),(0,r.kt)("p",null,"Blocking side-effects can be interrupted by invoking ",(0,r.kt)("inlineCode",{parentName:"p"},"Thread.interrupt")," using the ",(0,r.kt)("inlineCode",{parentName:"p"},"effectBlockingInterrupt")," method."),(0,r.kt)("p",null,"Some blocking side-effects can only be interrupted by invoking a cancellation effect. You can convert these side-effects using the ",(0,r.kt)("inlineCode",{parentName:"p"},"effectBlockingCancelable")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import java.net.ServerSocket\nimport zio.UIO\n\ndef accept(l: ServerSocket) =\n  effectBlockingCancelable(l.accept())(UIO.effectTotal(l.close()))\n")),(0,r.kt)("p",null,"If a side-effect has already been converted into a ZIO effect, then instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"effectBlocking"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"blocking")," method can be used to ensure the effect will be executed on the blocking thread pool:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.io.{ Codec, Source }\n\ndef download(url: String) =\n  Task.effect {\n    Source.fromURL(url)(Codec.UTF8).mkString\n  }\n\ndef safeDownload(url: String) =\n  blocking(download(url))\n")),(0,r.kt)("h2",{id:"next-steps"},"Next Steps"),(0,r.kt)("p",null,"If you are comfortable creating effects from values, Scala data types, and side-effects, the next step is learning ",(0,r.kt)("a",{parentName:"p",href:"/1.0.18/overview/overview_basic_operations"},"basic operations")," on effects."))}f.isMDXComponent=!0}}]);