"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[86844],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>k});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(t),m=r,k=d["".concat(s,".").concat(m)]||d[m]||c[m]||i;return t?a.createElement(k,l(l({ref:n},u),{},{components:t})):a.createElement(k,l({ref:n},u))}));function k(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},78569:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=t(87462),r=(t(67294),t(3905));const i={id:"writing-queries",title:"Writing Queries"},l=void 0,o={unversionedId:"zio-quill/writing-queries",id:"zio-quill/writing-queries",title:"Writing Queries",description:"Introduction",source:"@site/docs/zio-quill/writing-queries.md",sourceDirName:"zio-quill",slug:"/zio-quill/writing-queries",permalink:"/zio-quill/writing-queries",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-quill/writing-queries.md",tags:[],version:"current",frontMatter:{id:"writing-queries",title:"Writing Queries"},sidebar:"ecosystem-sidebar",previous:{title:"Getting Started",permalink:"/zio-quill/getting-started"},next:{title:"Extending Quill",permalink:"/zio-quill/extending-quill"}},s={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Compile-time quotations",id:"compile-time-quotations",level:2},{value:"Inline queries",id:"inline-queries",level:4},{value:"Bindings",id:"bindings",level:2},{value:"Lifted values",id:"lifted-values",level:3},{value:"Lifted queries",id:"lifted-queries",level:3},{value:"contains",id:"contains",level:4},{value:"batch action",id:"batch-action",level:4},{value:"Schema",id:"schema",level:2},{value:"Schema customization",id:"schema-customization",level:3},{value:"Database-generated values",id:"database-generated-values",level:3},{value:"returningGenerated",id:"returninggenerated",level:4},{value:"returning",id:"returning",level:4},{value:"returningMany",id:"returningmany",level:4},{value:"Postgres Customized returning",id:"postgres-customized-returning",level:4},{value:"insert.returning",id:"insertreturning",level:4},{value:"Embedded case classes",id:"embedded-case-classes",level:3},{value:"Queries",id:"queries",level:2},{value:"filter",id:"filter",level:3},{value:"map",id:"map",level:3},{value:"flatMap",id:"flatmap",level:3},{value:"sortBy",id:"sortby",level:3},{value:"aggregation",id:"aggregation",level:3},{value:"groupByMap",id:"groupbymap",level:3},{value:"groupBy",id:"groupby",level:3},{value:"drop/take",id:"droptake",level:3},{value:"concatMap (i.e. <code>UNNEST</code>)",id:"concatmap-ie-unnest",level:3},{value:"union",id:"union",level:3},{value:"unionAll/++",id:"unionall",level:3},{value:"aggregation",id:"aggregation-1",level:3},{value:"isEmpty/nonEmpty",id:"isemptynonempty",level:3},{value:"contains",id:"contains-1",level:3},{value:"distinct",id:"distinct",level:3},{value:"distinct on",id:"distinct-on",level:3},{value:"nested",id:"nested",level:3},{value:"joins",id:"joins",level:3},{value:"applicative joins",id:"applicative-joins",level:4},{value:"implicit joins",id:"implicit-joins",level:4},{value:"flat joins",id:"flat-joins",level:3},{value:"Optionals / Nullable Fields",id:"optionals--nullable-fields",level:3},{value:"isDefined / isEmpty",id:"isdefined--isempty",level:4},{value:"exists",id:"exists",level:4},{value:"forall",id:"forall",level:4},{value:"filterIfDefined",id:"filterifdefined",level:4},{value:"map",id:"map-1",level:4},{value:"flatMap and flatten",id:"flatmap-and-flatten",level:4},{value:"orNull / getOrNull",id:"ornull--getornull",level:4},{value:"equals",id:"equals",level:3},{value:"Optional Tables",id:"optional-tables",level:4},{value:"Ad-Hoc Case Classes",id:"ad-hoc-case-classes",level:3},{value:"Query probing",id:"query-probing",level:2},{value:"Actions",id:"actions",level:2},{value:"insertValue / insert",id:"insertvalue--insert",level:3},{value:"It is also possible to insert specific columns (via insert):",id:"it-is-also-possible-to-insert-specific-columns-via-insert",level:4},{value:"batch insert",id:"batch-insert",level:3},{value:"updateValue / update",id:"updatevalue--update",level:3},{value:"Using specific columns (via update):",id:"using-specific-columns-via-update",level:4},{value:"Using columns as part of the update:",id:"using-columns-as-part-of-the-update",level:4},{value:"batch update",id:"batch-update",level:3},{value:"delete",id:"delete",level:3},{value:"insert or update (upsert, conflict)",id:"insert-or-update-upsert-conflict",level:3},{value:"Postgres and SQLite",id:"postgres-and-sqlite",level:4},{value:"Ignore conflict",id:"ignore-conflict",level:5},{value:"Update on Conflict",id:"update-on-conflict",level:5},{value:"MySQL",id:"mysql",level:4},{value:"Batch Optimization",id:"batch-optimization",level:2},{value:"Printing Queries",id:"printing-queries",level:2},{value:"IO Monad",id:"io-monad",level:2},{value:"IO Monad and transactions",id:"io-monad-and-transactions",level:3},{value:"Getting a ResultSet",id:"getting-a-resultset",level:3},{value:"Effect tracking",id:"effect-tracking",level:3},{value:"Implicit query",id:"implicit-query",level:2},{value:"SQL-specific operations",id:"sql-specific-operations",level:2},{value:"like",id:"like",level:3},{value:"forUpdate",id:"forupdate",level:3},{value:"SQL-specific encoding",id:"sql-specific-encoding",level:2},{value:"Arrays",id:"arrays",level:3},{value:"Cassandra-specific encoding",id:"cassandra-specific-encoding",level:2},{value:"Collections",id:"collections",level:3},{value:"User-Defined Types",id:"user-defined-types",level:3},{value:"Cassandra-specific operations",id:"cassandra-specific-operations",level:2},{value:"allowFiltering",id:"allowfiltering",level:3},{value:"ifNotExists",id:"ifnotexists",level:3},{value:"ifExists",id:"ifexists",level:3},{value:"usingTimestamp",id:"usingtimestamp",level:3},{value:"usingTtl",id:"usingttl",level:3},{value:"using",id:"using",level:3},{value:"ifCond",id:"ifcond",level:3},{value:"delete column",id:"delete-column",level:3},{value:"list.contains / set.contains",id:"listcontains--setcontains",level:3},{value:"map.contains",id:"mapcontains",level:3},{value:"map.containsValue",id:"mapcontainsvalue",level:3},{value:"Dynamic queries",id:"dynamic-queries",level:2},{value:"Dynamic query API",id:"dynamic-query-api",level:3},{value:"Dynamic query normalization cache",id:"dynamic-query-normalization-cache",level:3}],u={toc:p},d="wrapper";function c(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"The QDSL allows the user to write plain Scala code, leveraging Scala's syntax and type system. Quotations are created using the ",(0,r.kt)("inlineCode",{parentName:"p"},"quote")," method and can contain any excerpt of code that uses supported operations. To create quotations, first create a context instance. Please see the ",(0,r.kt)("a",{parentName:"p",href:"/zio-quill/contexts"},"context")," section for more details on the different context available."),(0,r.kt)("p",null,"For this documentation, a special type of context that acts as a ",(0,r.kt)("a",{parentName:"p",href:"/zio-quill/contexts#mirror-context"},"mirror")," is used:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import io.getquill._\n\nval ctx = new SqlMirrorContext(MirrorSqlDialect, Literal)\n")),(0,r.kt)("p",null,"The context instance provides all the types, methods, and encoders/decoders needed for quotations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import ctx._\n")),(0,r.kt)("p",null,"A quotation can be a simple value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val pi = quote(3.14159)\n")),(0,r.kt)("p",null,"And be used within another quotation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Circle(radius: Float)\n\nval areas = quote {\n  query[Circle].map(c => pi * c.radius * c.radius)\n}\n")),(0,r.kt)("p",null,"Quotations can also contain high-order functions and inline values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val area = quote {\n  (c: Circle) => {\n    val r2 = c.radius * c.radius\n    pi * r2\n  }\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val areas = quote {\n  query[Circle].map(c => area(c))\n}\n")),(0,r.kt)("p",null,"Quill's normalization engine applies reduction steps before translating the quotation to the target language. The correspondent normalized quotation for both versions of the ",(0,r.kt)("inlineCode",{parentName:"p"},"areas")," query is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val areas = quote {\n  query[Circle].map(c => 3.14159 * c.radius * c.radius)\n}\n")),(0,r.kt)("p",null,"Scala doesn't have support for high-order functions with type parameters. It's possible to use a method type parameter for this purpose:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def existsAny[T] = quote {\n  (xs: Query[T]) => (p: T => Boolean) =>\n        xs.filter(p(_)).nonEmpty\n}\n\nval q = quote {\n  query[Circle].filter { c1 =>\n    existsAny(query[Circle])(c2 => c2.radius > c1.radius)\n  }\n}\n")),(0,r.kt)("p",null,"You can also use implicit classes to extend things in quotations."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"implicit class Ext(q: Query[Person]) {\n  def olderThan(age: Int) = quote {\n    query[Person].filter(p => p.age > lift(age))\n  }\n}\n\nrun(query[Person].olderThan(44))\n")),(0,r.kt)("p",null,"(see ",(0,r.kt)("a",{parentName:"p",href:"/zio-quill/extending-quill#implicit-extensions"},"implicit-extensions")," for additional information.)"),(0,r.kt)("h2",{id:"compile-time-quotations"},"Compile-time quotations"),(0,r.kt)("p",null,"Quotations are both compile-time and runtime values. Quill uses a type refinement to store the quotation's AST as an annotation available at compile-time and the ",(0,r.kt)("inlineCode",{parentName:"p"},"q.ast")," method exposes the AST as runtime value."),(0,r.kt)("p",null,"It is important to avoid giving explicit types to quotations when possible. For instance, this quotation can't be read at compile-time as the type refinement is lost:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"// Avoid type widening (Quoted[Query[Circle]]), or else the quotation will be dynamic.\nval q: Quoted[Query[Circle]] = quote {\n  query[Circle].filter(c => c.radius > 10)\n}\n\nctx.run(q) // Dynamic query\n")),(0,r.kt)("p",null,"Quill falls back to runtime normalization and query generation if the quotation's AST can't be read at compile-time. Please refer to ",(0,r.kt)("a",{parentName:"p",href:"#dynamic-queries"},"dynamic queries")," for more information."),(0,r.kt)("h4",{id:"inline-queries"},"Inline queries"),(0,r.kt)("p",null,"Quoting is implicit when writing a query in a ",(0,r.kt)("inlineCode",{parentName:"p"},"run")," statement."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"ctx.run(query[Circle].map(_.radius))\n// SELECT r.radius FROM Circle r\n")),(0,r.kt)("h2",{id:"bindings"},"Bindings"),(0,r.kt)("p",null,"Quotations are designed to be self-contained, without references to runtime values outside their scope. There are two mechanisms to explicitly bind runtime values to a quotation execution."),(0,r.kt)("h3",{id:"lifted-values"},"Lifted values"),(0,r.kt)("p",null,"A runtime value can be lifted to a quotation through the method ",(0,r.kt)("inlineCode",{parentName:"p"},"lift"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def biggerThan(i: Float) = quote {\n  query[Circle].filter(r => r.radius > lift(i))\n}\nctx.run(biggerThan(10)) // SELECT r.radius FROM Circle r WHERE r.radius > ?\n")),(0,r.kt)("p",null,"Note that literal-constants do not need to be lifted, they can be used in queries directly. Literal constants are supported starting Scala 2.12."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"final val minAge = 21  // This is the same as: final val minAge: 21 = 21\nctx.run(query[Person].filter(p => p.age > minAge)) // SELECT p.name, p.age FROM Person p WHERE p.name > 21\n")),(0,r.kt)("h3",{id:"lifted-queries"},"Lifted queries"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterable")," instance can be lifted as a ",(0,r.kt)("inlineCode",{parentName:"p"},"Query"),". There are two main usages for lifted queries:"),(0,r.kt)("h4",{id:"contains"},"contains"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def find(radiusList: List[Float]) = quote {\n  query[Circle].filter(r => liftQuery(radiusList).contains(r.radius))\n}\nctx.run(find(List(1.1F, 1.2F)))\n// SELECT r.radius FROM Circle r WHERE r.radius IN (?)\n")),(0,r.kt)("h4",{id:"batch-action"},"batch action"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def insertValues(circles: List[Circle]) = quote {\n  liftQuery(circles).foreach(c => query[Circle].insertValue(c))\n}\nctx.run(insertValues(List(Circle(1.1F), Circle(1.2F))))\n// INSERT INTO Circle (radius) VALUES (?)\n")),(0,r.kt)("h2",{id:"schema"},"Schema"),(0,r.kt)("p",null,"The database schema is represented by case classes. By default, quill uses the class and field names as the database identifiers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Circle(radius: Float)\n\nval q = quote {\n  query[Circle].filter(c => c.radius > 1)\n}\n\nctx.run(q) // SELECT c.radius FROM Circle c WHERE c.radius > 1\n")),(0,r.kt)("h3",{id:"schema-customization"},"Schema customization"),(0,r.kt)("p",null,"Alternatively, the identifiers can be customized:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val circles = quote {\n  querySchema[Circle]("circle_table", _.radius -> "radius_column")\n}\n\nval q = quote {\n  circles.filter(c => c.radius > 1)\n}\n\nctx.run(q)\n// SELECT c.radius_column FROM circle_table c WHERE c.radius_column > 1\n')),(0,r.kt)("p",null,"If multiple tables require custom identifiers, it is good practice to define a ",(0,r.kt)("inlineCode",{parentName:"p"},"schema")," object with all table queries to be reused across multiple queries:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'case class Circle(radius: Int)\ncase class Rectangle(length: Int, width: Int)\nobject schema {\n  val circles = quote {\n    querySchema[Circle](\n        "circle_table",\n        _.radius -> "radius_column")\n  }\n  val rectangles = quote {\n    querySchema[Rectangle](\n        "rectangle_table",\n        _.length -> "length_column",\n        _.width -> "width_column")\n  }\n}\n')),(0,r.kt)("h3",{id:"database-generated-values"},"Database-generated values"),(0,r.kt)("h4",{id:"returninggenerated"},"returningGenerated"),(0,r.kt)("p",null,"Database generated values can be returned from an insert query by using ",(0,r.kt)("inlineCode",{parentName:"p"},".returningGenerated"),". These properties\nwill also be excluded from the insertion since they are database generated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Product(id: Int, description: String, sku: Long)\n\nval q = quote {\n  query[Product].insertValue(lift(Product(0, \"My Product\", 1011L))).returningGenerated(_.id)\n}\n\nval returnedIds = ctx.run(q) //: List[Int]\n// INSERT INTO Product (description,sku) VALUES (?, ?) -- NOTE that 'id' is not being inserted.\n")),(0,r.kt)("p",null,"Multiple properties can be returned in a Tuple or Case Class and all of them will be excluded from insertion."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"NOTE: Using multiple properties is currently supported by Postgres, Oracle and SQL Server")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"// Assuming sku is generated by the database.\nval q = quote {\n  query[Product].insertValue(lift(Product(0, \"My Product\", 1011L))).returningGenerated(r => (id, sku))\n}\n\nval returnedIds = ctx.run(q) //: List[(Int, Long)]\n// INSERT INTO Product (description) VALUES (?) RETURNING id, sku -- NOTE that 'id' and 'sku' are not being inserted.\n")),(0,r.kt)("h4",{id:"returning"},"returning"),(0,r.kt)("p",null,"In UPDATE and DELETE queries we frequently want to return the records that were modified/deleted.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"returning")," method is used for that."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that most of these operations are only supported in Postgres and SQL Server")),(0,r.kt)("p",null,"For example when we want to return information from records that are being updated:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val desc = "Update Product"\nval sku = 2002L\nval q = quote {\n  query[Product].filter(p => p.id == 42).update(_.description = lift(desc), _.sku = lift(sku)).returning(r => (r.id, r.description))\n}\nval updated = ctx.run(q) //: (Int, String)\n// Postgres\n// UPDATE Product AS p SET description = ?, sku = ? WHERE p.id = 42 RETURNING p.id, p.description\n// SQL Server\n// UPDATE Product SET description = ?, sku = ? OUTPUT id, description WHERE id = 42\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"When multiple records are updated using ",(0,r.kt)("inlineCode",{parentName:"p"},"update.returning")," a warning will be issued and only the first result will be returned.\nUse ",(0,r.kt)("a",{parentName:"p",href:"/zio-quill/writing-queries#returningmany"},(0,r.kt)("inlineCode",{parentName:"a"},"returningMany"))," to return all the updated records in this case.")),(0,r.kt)("p",null,"You can do the same thing with ",(0,r.kt)("inlineCode",{parentName:"p"},"updateValue"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'// (use an UpdateMeta to exclude generated id columns)\nimplicit val productUpdateMeta = updateMeta[Product](_.id)\nval q = quote {\n  query[Product].filter(p => p.id == 42).updateValue(lift(Product(42, "Updated Product", 2022L))).returning(r => (r.id, r.description))\n}\nval updated = ctx.run(q) //: (Int, String)\n// Postgres\n// UPDATE Product AS p SET description = ?, sku = ? WHERE p.id = 42 RETURNING p.id, p.description\n// SQL Server\n// UPDATE Product SET description = ?, sku = ? OUTPUT INSERTED.id, INSERTED.description WHERE id = 42\n')),(0,r.kt)("p",null,"You can also return information that is being deleted in a DELETE query. Or even the entire deleted record!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Product].filter(p => p.id == 42).delete.returning(r => r)\n}\n\nval deleted = ctx.run(q) //: Product\n// Postgres\n// DELETE FROM Product AS p WHERE p.id = 42 RETURNING p.id, p.description, p.sku \n// SQL Server\n// DELETE FROM Product OUTPUT DELETED.id, DELETED.description, DELETED.sku WHERE id = 42\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"When multiple records are deleted using ",(0,r.kt)("inlineCode",{parentName:"p"},"delete.returning")," a warning will be issued and only the first result will be returned.\nUse ",(0,r.kt)("a",{parentName:"p",href:"/zio-quill/writing-queries#returningmany"},(0,r.kt)("inlineCode",{parentName:"a"},"returningMany"))," to return all the deleted records in this case.")),(0,r.kt)("h4",{id:"returningmany"},"returningMany"),(0,r.kt)("p",null,"Similar to insert/update.returning, the returningMany function can be used to return all the values that were\nupdated/deleted from a query. Not just one."),(0,r.kt)("p",null,"Return ",(0,r.kt)("em",{parentName:"p"},"all")," the records that were updated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val desc = "Update Product"\nval sku = 2002L\nval q = quote {\n  query[Product].filter(p => p.id == 42).update(_.description = lift(desc), _.sku = lift(sku)).returning(r => (r.id, r.description))\n}\nval updated = ctx.run(q) //: List[(Int, String)]\n// Postgres\n// UPDATE Product AS p SET description = ?, sku = ? WHERE p.id = 42 RETURNING p.id, p.description\n// SQL Server\n// UPDATE Product SET description = ?, sku = ? OUTPUT id, description WHERE id = 42\n')),(0,r.kt)("p",null,"Return ",(0,r.kt)("em",{parentName:"p"},"all")," the records that were deleted."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Product].filter(p => p.id == 42).delete.returning(r => r)\n}\n\nval deleted = ctx.run(q) //: List[Product]\n// Postgres\n// DELETE FROM Product AS p WHERE p.id = 42 RETURNING p.id, p.description, p.sku \n// SQL Server\n// DELETE FROM Product OUTPUT DELETED.id, DELETED.description, DELETED.sku WHERE id = 42\n")),(0,r.kt)("h4",{id:"postgres-customized-returning"},"Postgres Customized returning"),(0,r.kt)("p",null,"Returning values returned can be further customized in some databases."),(0,r.kt)("p",null,"In Postgres, the ",(0,r.kt)("inlineCode",{parentName:"p"},"returning")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"returningGenerated")," methods also support arithmetic operations, SQL UDFs and\neven entire queries for INSERT, UPDATE, and DELETE actions. These are inserted directly into the SQL ",(0,r.kt)("inlineCode",{parentName:"p"},"RETURNING")," clause."),(0,r.kt)("p",null,"For example, assuming this basic query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val q = quote {\n  query[Product].filter(p => p.id == 42).update(_.description -> "My Product", _.sku -> 1011L)\n}\n')),(0,r.kt)("p",null,"Add 100 to the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"id"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"ctx.run(q.returning(r => r.id + 100)) //: List[Int]\n// UPDATE Product AS p SET description = 'My Product', sku = 1011L WHERE p.id = 42 RETURNING p.id + 100\n")),(0,r.kt)("p",null,"Pass the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," into a UDF:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val udf = quote { (i: Long) => sql\"myUdf($i)\".as[Int] }\nctx.run(q.returning(r => udf(r.id))) //: List[Int]\n// UPDATE Product AS p SET description = 'My Product', sku = 1011L WHERE p.id = 42 RETURNING myUdf(p.id)\n")),(0,r.kt)("p",null,"Use the return value of ",(0,r.kt)("inlineCode",{parentName:"p"},"sku")," to issue a query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Supplier(id: Int, clientSku: Long)\nctx.run {\n  q.returning(r => query[Supplier].filter(s => s.sku == r.sku).map(_.id).max)\n} //: List[Option[Long]]\n// UPDATE Product AS p SET description = 'My Product', sku = 1011L WHERE p.id = 42 RETURNING (SELECT MAX(s.id) FROM Supplier s WHERE s.sku = clientSku)\n")),(0,r.kt)("p",null,"As is typically the case with Quill, you can use all of these features together."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"ctx.run {\n  q.returning(r =>\n    (r.id + 100, udf(r.id), query[Supplier].filter(s => s.sku == r.sku).map(_.id).max)\n  )\n} // List[(Int, Int, Option[Long])]\n// UPDATE Product AS p SET description = 'My Product', sku = 1011L WHERE p.id = 42\n// RETURNING id + 100, myUdf(id), (SELECT MAX(s.id) FROM Supplier s WHERE s.sku = sku)\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"NOTE: Queries used inside of return clauses can only return a single row per insert.\nOtherwise, Postgres will throw:\n",(0,r.kt)("inlineCode",{parentName:"p"},"ERROR: more than one row returned by a subquery used as an expression"),". This is why is it strongly\nrecommended that you use aggregators such as ",(0,r.kt)("inlineCode",{parentName:"p"},"max")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"min"),"inside of quill returning-clause queries.\nIn the case that this is impossible (e.g. when using Postgres booleans), you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},".value")," method:\n",(0,r.kt)("inlineCode",{parentName:"p"},"q.returning(r => query[Supplier].filter(s => s.sku == r.sku).map(_.id).value)"),".")),(0,r.kt)("h4",{id:"insertreturning"},"insert.returning"),(0,r.kt)("p",null,"In certain situations we also may want to return information from inserted records."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val q = quote {\n  query[Product].insertValue(lift(Product(0, "My Product", 1011L))).returning(r => (id, description))\n}\n\nval returnedIds = ctx.run(q) //: List[(Int, String)]\n// INSERT INTO Product (id, description, sku) VALUES (?, ?, ?) RETURNING id, description\n')),(0,r.kt)("p",null,"Wait a second! Why did we just insert ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," into the database? That is because ",(0,r.kt)("inlineCode",{parentName:"p"},"returning")," does not exclude values\nfrom the insertion! We can fix this situation by manually specifying the columns to insert:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val q = quote {\n  query[Product].insert(_.description -> "My Product", _.sku -> 1011L))).returning(r => (id, description))\n}\n\nval returnedIds = ctx.run(q) //: List[(Int, String)]\n// INSERT INTO Product (description, sku) VALUES (?, ?) RETURNING id, description\n')),(0,r.kt)("p",null,"We can also fix this situation by using an insert-meta."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'implicit val productInsertMeta = insertMeta[Product](_.id)\nval q = quote {\n  query[Product].insertValue(lift(Product(0L, "My Product", 1011L))).returning(r => (id, description))\n}\n\nval returnedIds = ctx.run(q) //: List[(Int, String)]\n// INSERT INTO Product (description, sku) VALUES (?, ?) RETURNING id, description\n')),(0,r.kt)("h3",{id:"embedded-case-classes"},"Embedded case classes"),(0,r.kt)("p",null,"Quill supports nested embedded case classes."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"In previous iterations of Quill would need to extend the ",(0,r.kt)("inlineCode",{parentName:"p"},"Embedded")," trait but this is no longer necessary.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Contact(phone: String, address: String) /* The embedded class */\ncase class Person(id: Int, name: String, contact: Contact)\n\nctx.run(query[Person])\n// SELECT x.id, x.name, x.phone, x.address FROM Person x\n")),(0,r.kt)("p",null,"Note that default naming behavior uses the name of the nested case class properties. It's possible to override this default behavior using a custom ",(0,r.kt)("inlineCode",{parentName:"p"},"schema"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'case class Contact(phone: String, address: String) extends Embedded\ncase class Person(id: Int, name: String, homeContact: Contact, workContact: Option[Contact])\n\nval q = quote {\n  querySchema[Person](\n    "Person",\n    _.homeContact.phone          -> "homePhone",\n    _.homeContact.address        -> "homeAddress",\n    _.workContact.map(_.phone)   -> "workPhone",\n    _.workContact.map(_.address) -> "workAddress"\n  )\n}\n\nctx.run(q)\n// SELECT x.id, x.name, x.homePhone, x.homeAddress, x.workPhone, x.workAddress FROM Person x\n')),(0,r.kt)("h2",{id:"queries"},"Queries"),(0,r.kt)("p",null,"The overall abstraction of quill queries uses database tables as if they were in-memory collections. Scala for-comprehensions provide syntactic sugar to deal with these kinds of monadic operations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Person(id: Int, name: String, age: Int)\ncase class Contact(personId: Int, phone: String)\n\nval q = quote {\n  for {\n    p <- query[Person] if(p.id == 999)\n    c <- query[Contact] if(c.personId == p.id)\n  } yield {\n    (p.name, c.phone)\n  }\n}\n\nctx.run(q)\n// SELECT p.name, c.phone FROM Person p, Contact c WHERE (p.id = 999) AND (c.personId = p.id)\n")),(0,r.kt)("p",null,"Quill normalizes the quotation and translates the monadic joins to applicative joins, generating a database-friendly query that avoids nested queries."),(0,r.kt)("p",null,"Any of the following features can be used together with the others and/or within a for-comprehension:"),(0,r.kt)("h3",{id:"filter"},"filter"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].filter(p => p.age > 18)\n}\n\nctx.run(q)\n// SELECT p.id, p.name, p.age FROM Person p WHERE p.age > 18\n")),(0,r.kt)("h3",{id:"map"},"map"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].map(p => p.name)\n}\n\nctx.run(q)\n// SELECT p.name FROM Person p\n")),(0,r.kt)("h3",{id:"flatmap"},"flatMap"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].filter(p => p.age > 18).flatMap(p => query[Contact].filter(c => c.personId == p.id))\n}\n\nctx.run(q)\n// SELECT c.personId, c.phone FROM Person p, Contact c WHERE (p.age > 18) AND (c.personId = p.id)\n")),(0,r.kt)("h3",{id:"sortby"},"sortBy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q1 = quote {\n  query[Person].sortBy(p => p.age)\n}\n\nctx.run(q1)\n// SELECT p.id, p.name, p.age FROM Person p ORDER BY p.age ASC NULLS FIRST\n\nval q2 = quote {\n  query[Person].sortBy(p => p.age)(Ord.descNullsLast)\n}\n\nctx.run(q2)\n// SELECT p.id, p.name, p.age FROM Person p ORDER BY p.age DESC NULLS LAST\n\nval q3 = quote {\n  query[Person].sortBy(p => (p.name, p.age))(Ord(Ord.asc, Ord.desc))\n}\n\nctx.run(q3)\n// SELECT p.id, p.name, p.age FROM Person p ORDER BY p.name ASC, p.age DESC\n")),(0,r.kt)("h3",{id:"aggregation"},"aggregation"),(0,r.kt)("p",null,"You can use aggregators inside of map-clauses. Multiple aggregators can be used as needed.\nAvailable aggregators are ",(0,r.kt)("inlineCode",{parentName:"p"},"max"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"min"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"count"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"avg")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"sum"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].map(p => (min(p.age), max(p.age)))\n}\n// SELECT MIN(p.age), MAX(p.age) FROM Person p\n")),(0,r.kt)("h3",{id:"groupbymap"},"groupByMap"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"groupByMap")," method is the preferred way to do grouping in Quill. It provides a simple aggregation-syntax similar to SQL.\nAvailable aggregators are ",(0,r.kt)("inlineCode",{parentName:"p"},"max"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"min"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"count"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"avg")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"sum"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].groupByMap(p => p.name)(p => (p.name, max(p.age)))\n}\nctx.run(q)\n// SELECT p.name, MAX(p.age) FROM Person p GROUP BY p.name\n")),(0,r.kt)("p",null,"You can use as many aggregators as needed and group by multiple fields (using a Tuple)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].groupByMap(p => (p.name, p.otherField))(p => (p.name, p.otherField, max(p.age)))\n}\nctx.run(q)\n// SELECT p.name, p.otherField, MAX(p.age) FROM Person p GROUP BY p.name, p.otherField\n")),(0,r.kt)("p",null,"Writing a custom aggregator using ",(0,r.kt)("inlineCode",{parentName:"p"},"infix")," with the ",(0,r.kt)("inlineCode",{parentName:"p"},"groupByMax")," syntax is also very simple.\nFor example, in Postgres the ",(0,r.kt)("inlineCode",{parentName:"p"},"STRING_AGG")," function is used to concatenate all the encountered strings."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val stringAgg = quote {\n  (str: String, separator: String) => sql"STRING_AGG($str, $separator)".pure.as[String]\n}\nval q = quote {\n  query[Person].groupByMap(p => p.age)(p => (p.age, stringAgg(p.name, ";")))\n}\nrun(q)\n// SELECT p.age, STRING_AGG(p.name, \';\') FROM Person p GROUP BY p.age\n')),(0,r.kt)("p",null,"You can also map to a case class instead of a tuple. This will give you a ",(0,r.kt)("inlineCode",{parentName:"p"},"Query[YourCaseClass]")," that you can further compose."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class NameAge(name: String, age: Int)\n// Will return Query[NameAge]\nval q = quote {\n  query[Person].groupByMap(p => p.name)(p => NameAge(p.name, max(p.age)))\n}\nctx.run(q)\n// SELECT p.name, MAX(p.age) FROM Person p GROUP BY p.name\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that it is a requirement in SQL for every column in the selection (without an aggregator) to be in the ",(0,r.kt)("inlineCode",{parentName:"p"},"GROUP BY")," clause.\nIf it is not, an exception will be thrown by the database. Quill does not (yet!) protect the user in this situation."),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'run( query[Person].groupByMap(p => p.name)(p => (p.name, p.otherField, max(p.age))) )\n// > SELECT p.name, p.otherField, MAX(p.age) FROM Person p GROUP BY p.name\n// ERROR: column "person.otherField" must appear in the GROUP BY clause or be used in an aggregate function\n'))),(0,r.kt)("h3",{id:"groupby"},"groupBy"),(0,r.kt)("p",null,"Quill also provides a way to do ",(0,r.kt)("inlineCode",{parentName:"p"},"groupBy/map")," in a more scala-idiomatic way. In this case (below), the ",(0,r.kt)("inlineCode",{parentName:"p"},"groupBy"),"\nproduces a ",(0,r.kt)("inlineCode",{parentName:"p"},"Query[(Int,Query[Person])]")," where the inner Query can be mapped to an expression with an aggregator\n(as would be the Scala ",(0,r.kt)("inlineCode",{parentName:"p"},"List[Person]")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"Map[Int,List[Person]]")," resulting from a ",(0,r.kt)("inlineCode",{parentName:"p"},"(people:List[Person]).groupBy(_.name)"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].groupBy(p => p.age).map {\n    case (age, people) =>\n      (age, people.size)\n  }\n}\n\nctx.run(q)\n// SELECT p.age, COUNT(*) FROM Person p GROUP BY p.age\n")),(0,r.kt)("h3",{id:"droptake"},"drop/take"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].drop(2).take(1)\n}\n\nctx.run(q)\n// SELECT x.id, x.name, x.age FROM Person x LIMIT 1 OFFSET 2\n")),(0,r.kt)("h3",{id:"concatmap-ie-unnest"},"concatMap (i.e. ",(0,r.kt)("inlineCode",{parentName:"h3"},"UNNEST"),")"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'// similar to `flatMap` but for transformations that return a traversable instead of `Query`\n\nval q = quote {\n  query[Person].concatMap(p => p.name.split(" "))\n}\n\nctx.run(q)\n// SELECT UNNEST(SPLIT(p.name, " ")) FROM Person p\n')),(0,r.kt)("h3",{id:"union"},"union"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].filter(p => p.age > 18).union(query[Person].filter(p => p.age > 60))\n}\n\nctx.run(q)\n// SELECT x.id, x.name, x.age FROM (SELECT id, name, age FROM Person p WHERE p.age > 18\n// UNION SELECT id, name, age FROM Person p1 WHERE p1.age > 60) x\n")),(0,r.kt)("h3",{id:"unionall"},"unionAll/++"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].filter(p => p.age > 18).unionAll(query[Person].filter(p => p.age > 60))\n}\n\nctx.run(q)\n// SELECT x.id, x.name, x.age FROM (SELECT id, name, age FROM Person p WHERE p.age > 18\n// UNION ALL SELECT id, name, age FROM Person p1 WHERE p1.age > 60) x\n\nval q2 = quote {\n  query[Person].filter(p => p.age > 18) ++ query[Person].filter(p => p.age > 60)\n}\n\nctx.run(q2)\n// SELECT x.id, x.name, x.age FROM (SELECT id, name, age FROM Person p WHERE p.age > 18\n// UNION ALL SELECT id, name, age FROM Person p1 WHERE p1.age > 60) x\n")),(0,r.kt)("h3",{id:"aggregation-1"},"aggregation"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val r = quote {\n  query[Person].map(p => p.age)\n}\n\nctx.run(r.min) // SELECT MIN(p.age) FROM Person p\nctx.run(r.max) // SELECT MAX(p.age) FROM Person p\nctx.run(r.avg) // SELECT AVG(p.age) FROM Person p\nctx.run(r.sum) // SELECT SUM(p.age) FROM Person p\nctx.run(r.size) // SELECT COUNT(p.age) FROM Person p\n")),(0,r.kt)("h3",{id:"isemptynonempty"},"isEmpty/nonEmpty"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].filter{ p1 =>\n    query[Person].filter(p2 => p2.id != p1.id && p2.age == p1.age).isEmpty\n  }\n}\n\nctx.run(q)\n// SELECT p1.id, p1.name, p1.age FROM Person p1 WHERE\n// NOT EXISTS (SELECT * FROM Person p2 WHERE (p2.id <> p1.id) AND (p2.age = p1.age))\n\nval q2 = quote {\n  query[Person].filter{ p1 =>\n    query[Person].filter(p2 => p2.id != p1.id && p2.age == p1.age).nonEmpty\n  }\n}\n\nctx.run(q2)\n// SELECT p1.id, p1.name, p1.age FROM Person p1 WHERE\n// EXISTS (SELECT * FROM Person p2 WHERE (p2.id <> p1.id) AND (p2.age = p1.age))\n")),(0,r.kt)("h3",{id:"contains-1"},"contains"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].filter(p => liftQuery(Set(1, 2)).contains(p.id))\n}\n\nctx.run(q)\n// SELECT p.id, p.name, p.age FROM Person p WHERE p.id IN (?, ?)\n\nval q1 = quote { (ids: Query[Int]) =>\n  query[Person].filter(p => ids.contains(p.id))\n}\n\nctx.run(q1(liftQuery(List(1, 2))))\n// SELECT p.id, p.name, p.age FROM Person p WHERE p.id IN (?, ?)\n\nval peopleWithContacts = quote {\n  query[Person].filter(p => query[Contact].filter(c => c.personId == p.id).nonEmpty)\n}\nval q2 = quote {\n  query[Person].filter(p => peopleWithContacts.contains(p.id))\n}\n\nctx.run(q2)\n// SELECT p.id, p.name, p.age FROM Person p WHERE p.id IN (SELECT p1.* FROM Person p1 WHERE EXISTS (SELECT c.* FROM Contact c WHERE c.personId = p1.id))\n")),(0,r.kt)("h3",{id:"distinct"},"distinct"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].map(p => p.age).distinct\n}\n\nctx.run(q)\n// SELECT DISTINCT p.age FROM Person p\n")),(0,r.kt)("h3",{id:"distinct-on"},"distinct on"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"DISTINCT ON")," is currently only supported in Postgres and H2.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].distinctOn(p => p.name)\n}\n\nctx.run(q)\n// SELECT DISTINCT ON (p.name) p.name, p.age FROM Person\n")),(0,r.kt)("p",null,"Typically, ",(0,r.kt)("inlineCode",{parentName:"p"},"DISTINCT ON")," is used with ",(0,r.kt)("inlineCode",{parentName:"p"},"SORT BY"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].distinctOn(p => p.name).sortBy(p => p.age)\n}\n\nctx.run(q)\n// SELECT DISTINCT ON (p.name) p.name, p.age FROM Person ORDER BY p.age ASC NULLS FIRST\n")),(0,r.kt)("p",null,"You can also use multiple fields in the ",(0,r.kt)("inlineCode",{parentName:"p"},"DISTINCT ON")," criteria:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"// case class Person(firstName: String, lastName: String, age: Int)\nval q = quote {\n  query[Person].distinctOn(p => (p.firstName, p.lastName))\n}\n\nctx.run(q)\n// SELECT DISTINCT ON (p.firstName, p.lastName) p.firstName, p.lastName, p.age FROM Person p\n")),(0,r.kt)("h3",{id:"nested"},"nested"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].filter(p => p.name == \"John\").nested.map(p => p.age)\n}\n\nctx.run(q)\n// SELECT p.age FROM (SELECT p.age FROM Person p WHERE p.name = 'John') p\n")),(0,r.kt)("h3",{id:"joins"},"joins"),(0,r.kt)("p",null,"Joins are arguably the largest source of complexity in most SQL queries.\nQuill offers a few different syntaxes so you can choose the right one for your use-case!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class A(id: Int)\ncase class B(fk: Int)\n\n// Applicative Joins:\nquote {\n  query[A].join(query[B]).on(_.id == _.fk)\n}\n\n// Implicit Joins:\nquote {\n  for {\n    a <- query[A]\n    b <- query[B] if (a.id == b.fk)\n  } yield (a, b)\n}\n\n// Flat Joins:\nquote {\n  for {\n    a <- query[A]\n    b <- query[B].join(_.fk == a.id)\n  } yield (a, b)\n}\n")),(0,r.kt)("p",null,"Let's see them one by one assuming the following schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Person(id: Int, name: String)\ncase class Address(street: String, zip: Int, fk: Int)\n")),(0,r.kt)("p",null,"(Note: If your use case involves lots and lots of joins, both inner and outer. Skip right to the flat-joins section!)"),(0,r.kt)("h4",{id:"applicative-joins"},"applicative joins"),(0,r.kt)("p",null,"Applicative joins are useful for joining two tables together,\nthey are straightforward to understand, and typically look good on one line.\nQuill supports inner, left-outer, right-outer, and full-outer (i.e. cross) applicative joins."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"// Inner Join\nval q = quote {\n  query[Person].join(query[Address]).on(_.id == _.fk)\n}\n\nctx.run(q) //: List[(Person, Address)]\n// SELECT x1.id, x1.name, x2.street, x2.zip, x2.fk\n// FROM Person x1 INNER JOIN Address x2 ON x1.id = x2.fk\n\n// Left (Outer) Join\nval q = quote {\n  query[Person].leftJoin(query[Address]).on((p, a) => p.id == a.fk)\n}\n\nctx.run(q) //: List[(Person, Option[Address])]\n// Note that when you use named-variables in your comprehension, Quill does its best to honor them in the query.\n// SELECT p.id, p.name, a.street, a.zip, a.fk\n// FROM Person p LEFT JOIN Address a ON p.id = a.fk\n\n// Right (Outer) Join\nval q = quote {\n  query[Person].rightJoin(query[Address]).on((p, a) => p.id == a.fk)\n}\n\nctx.run(q) //: List[(Option[Person], Address)]\n// SELECT p.id, p.name, a.street, a.zip, a.fk\n// FROM Person p RIGHT JOIN Address a ON p.id = a.fk\n\n// Full (Outer) Join\nval q = quote {\n  query[Person].fullJoin(query[Address]).on((p, a) => p.id == a.fk)\n}\n\nctx.run(q) //: List[(Option[Person], Option[Address])]\n// SELECT p.id, p.name, a.street, a.zip, a.fk\n// FROM Person p FULL JOIN Address a ON p.id = a.fk\n")),(0,r.kt)("p",null,"What about joining more than two tables with the applicative syntax?\nHere's how to do that:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Company(zip: Int)\n\n// All is well for two tables but for three or more, the nesting mess begins:\nval q = quote {\n  query[Person]\n    .join(query[Address]).on({case (p, a) => p.id == a.fk}) // Let's use `case` here to stay consistent\n    .join(query[Company]).on({case ((p, a), c) => a.zip == c.zip})\n}\n\nctx.run(q) //: List[((Person, Address), Company)]\n// (Unfortunately when you use `case` statements, Quill can't help you with the variables names either!)\n// SELECT x01.id, x01.name, x11.street, x11.zip, x11.fk, x12.name, x12.zip\n// FROM Person x01 INNER JOIN Address x11 ON x01.id = x11.fk INNER JOIN Company x12 ON x11.zip = x12.zip\n")),(0,r.kt)("p",null,"No worries though, implicit joins and flat joins have your other use-cases covered!"),(0,r.kt)("h4",{id:"implicit-joins"},"implicit joins"),(0,r.kt)("p",null,"Quill's implicit joins use a monadic syntax making them pleasant to use for joining many tables together.\nThey look a lot like Scala collections when used in for-comprehensions\nmaking them familiar to a typical Scala developer.\nWhat's the catch? They can only do inner-joins."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  for {\n    p <- query[Person]\n    a <- query[Address] if (p.id == a.fk)\n  } yield (p, a)\n}\n\nrun(q) //: List[(Person, Address)]\n// SELECT p.id, p.name, a.street, a.zip, a.fk\n// FROM Person p, Address a WHERE p.id = a.fk\n")),(0,r.kt)("p",null,"Now, this is great because you can keep adding more and more joins\nwithout having to do any pesky nesting."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  for {\n    p <- query[Person]\n    a <- query[Address] if (p.id == a.fk)\n    c <- query[Company] if (c.zip == a.zip)\n  } yield (p, a, c)\n}\n\nrun(q) //: List[(Person, Address, Company)]\n// SELECT p.id, p.name, a.street, a.zip, a.fk, c.name, c.zip\n// FROM Person p, Address a, Company c WHERE p.id = a.fk AND c.zip = a.zip\n")),(0,r.kt)("p",null,"Well that looks nice but wait! What If I need to inner, ",(0,r.kt)("strong",{parentName:"p"},"and")," outer join lots of tables nicely?\nNo worries, flat-joins are here to help!"),(0,r.kt)("h3",{id:"flat-joins"},"flat joins"),(0,r.kt)("p",null,"Flat Joins give you the best of both worlds! In the monadic syntax, you can use both inner joins,\nand left-outer joins together without any of that pesky nesting."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"// Inner Join\nval q = quote {\n  for {\n    p <- query[Person]\n    a <- query[Address].join(a => a.fk == p.id)\n  } yield (p,a)\n}\n\nctx.run(q) //: List[(Person, Address)]\n// SELECT p.id, p.name, a.street, a.zip, a.fk\n// FROM Person p INNER JOIN Address a ON a.fk = p.id\n\n// Left (Outer) Join\nval q = quote {\n  for {\n    p <- query[Person]\n    a <- query[Address].leftJoin(a => a.fk == p.id)\n  } yield (p,a)\n}\n\nctx.run(q) //: List[(Person, Option[Address])]\n// SELECT p.id, p.name, a.street, a.zip, a.fk\n// FROM Person p LEFT JOIN Address a ON a.fk = p.id\n")),(0,r.kt)("p",null,"Now you can keep adding both right and left joins without nesting!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  for {\n    p <- query[Person]\n    a <- query[Address].join(a => a.fk == p.id)\n    c <- query[Company].leftJoin(c => c.zip == a.zip)\n  } yield (p,a,c)\n}\n\nctx.run(q) //: List[(Person, Address, Option[Company])]\n// SELECT p.id, p.name, a.street, a.zip, a.fk, c.name, c.zip\n// FROM Person p\n// INNER JOIN Address a ON a.fk = p.id\n// LEFT JOIN Company c ON c.zip = a.zip\n")),(0,r.kt)("p",null,"Can't figure out what kind of join you want to use? Who says you have to choose?"),(0,r.kt)("p",null,"With Quill the following multi-join queries are equivalent, use them according to preference:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"\ncase class Employer(id: Int, personId: Int, name: String)\n\nval qFlat = quote {\n  for{\n    (p,e) <- query[Person].join(query[Employer]).on(_.id == _.personId)\n       c  <- query[Contact].leftJoin(_.personId == p.id)\n  } yield(p, e, c)\n}\n\nval qNested = quote {\n  for{\n    ((p,e),c) <-\n      query[Person].join(query[Employer]).on(_.id == _.personId)\n      .leftJoin(query[Contact]).on(\n        _._1.id == _.personId\n      )\n  } yield(p, e, c)\n}\n\nctx.run(qFlat)\nctx.run(qNested)\n// SELECT p.id, p.name, p.age, e.id, e.personId, e.name, c.id, c.phone\n// FROM Person p INNER JOIN Employer e ON p.id = e.personId LEFT JOIN Contact c ON c.personId = p.id\n")),(0,r.kt)("p",null,"Note that in some cases implicit and flat joins cannot be used together, for example, the following\nquery will fail."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  for {\n    p <- query[Person]\n    p1 <- query[Person] if (p1.name == p.name)\n    c <- query[Contact].leftJoin(_.personId == p.id)\n  } yield (p, c)\n}\n\n// ctx.run(q)\n// java.lang.IllegalArgumentException: requirement failed: Found an `ON` table reference of a table that is\n// not available: Set(p). The `ON` condition can only use tables defined through explicit joins.\n")),(0,r.kt)("p",null,"This happens because an explicit join typically cannot be done after an implicit join in the same query."),(0,r.kt)("p",null,"A good guideline is in any query or subquery, choose one of the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Use flat-joins + applicative joins or"),(0,r.kt)("li",{parentName:"ul"},"Use implicit joins")),(0,r.kt)("p",null,"Also, note that not all Option operations are available on outer-joined tables (i.e. tables wrapped in an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," object),\nonly a specific subset. This is mostly due to the inherent limitations of SQL itself. For more information, see the\n'Optional Tables' section."),(0,r.kt)("h3",{id:"optionals--nullable-fields"},"Optionals / Nullable Fields"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that the behavior of Optionals has recently changed to include stricter null-checks. See the ",(0,r.kt)("a",{parentName:"p",href:"#ornull--getornull"},"orNull / getOrNull")," section for more details.")),(0,r.kt)("p",null,"Option objects are used to encode nullable fields.\nSay you have the following schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE Person(\n  id INT NOT NULL PRIMARY KEY,\n  name VARCHAR(255) -- This is nullable!\n);\nCREATE TABLE Address(\n  fk INT, -- This is nullable!\n  street VARCHAR(255) NOT NULL,\n  zip INT NOT NULL,\n  CONSTRAINT a_to_p FOREIGN KEY (fk) REFERENCES Person(id)\n);\nCREATE TABLE Company(\n  name VARCHAR(255) NOT NULL,\n  zip INT NOT NULL\n)\n")),(0,r.kt)("p",null,"This would encode to the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Person(id:Int, name:Option[String])\ncase class Address(fk:Option[Int], street:String, zip:Int)\ncase class Company(name:String, zip:Int)\n")),(0,r.kt)("p",null,"Some important notes regarding Optionals and nullable fields."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"In many cases, Quill tries to rely on the null-fallthrough behavior that is ANSI standard:"),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null == null := false")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null == [true | false] := false"))),(0,r.kt)("p",{parentName:"blockquote"},"This allows the generated SQL for most optional operations to be simple. For example, the expression\n",(0,r.kt)("inlineCode",{parentName:"p"},'Option[String].map(v => v + "foo")')," can be expressed as the SQL ",(0,r.kt)("inlineCode",{parentName:"p"},"v || 'foo'")," as opposed to\n",(0,r.kt)("inlineCode",{parentName:"p"},"CASE IF (v is not null) v || 'foo' ELSE null END")," so long as the concatenation operator ",(0,r.kt)("inlineCode",{parentName:"p"},"||"),'\n"falls-through" and returns ',(0,r.kt)("inlineCode",{parentName:"p"},"null")," when the input is null. This is not true of all databases (e.g. ",(0,r.kt)("a",{parentName:"p",href:"https://community.oracle.com/ideas/19866"},"Oracle"),"),\nforcing Quill to return the longer expression with explicit null-checking. Also, if there are conditionals inside\nof an Option operation (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},'o.map(v => if (v == "x") "y" else "z")'),") this creates SQL with case statements,\nwhich will never fall-through when the input value is null. This forces Quill to explicitly null-check such statements in every\nSQL dialect.")),(0,r.kt)("p",null,"Let's go through the typical operations of optionals."),(0,r.kt)("h4",{id:"isdefined--isempty"},"isDefined / isEmpty"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"isDefined")," method is generally a good way to null-check a nullable field:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Address].filter(a => a.fk.isDefined)\n}\nctx.run(q)\n// SELECT a.fk, a.street, a.zip FROM Address a WHERE a.fk IS NOT NULL\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"isEmpty")," method works the same way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Address].filter(a => a.fk.isEmpty)\n}\nctx.run(q)\n// SELECT a.fk, a.street, a.zip FROM Address a WHERE a.fk IS NULL\n")),(0,r.kt)("h4",{id:"exists"},"exists"),(0,r.kt)("p",null,"This method is typically used for inspecting nullable fields inside of boolean conditions, most notably joining!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].join(query[Address]).on((p, a)=> a.fk.exists(_ == p.id))\n}\nctx.run(q)\n// SELECT p.id, p.name, a.fk, a.street, a.zip FROM Person p INNER JOIN Address a ON a.fk = p.id\n")),(0,r.kt)("p",null,"Note that in the example above, the ",(0,r.kt)("inlineCode",{parentName:"p"},"exists")," method does not cause the generated\nSQL to do an explicit null-check in order to express the ",(0,r.kt)("inlineCode",{parentName:"p"},"False")," case. This is because Quill relies on the\ntypical database behavior of immediately falsifying a statement that has ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," on one side of the equation."),(0,r.kt)("h4",{id:"forall"},"forall"),(0,r.kt)("p",null,"Use this method in boolean conditions that should succeed in the null case."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].join(query[Address]).on((p, a) => a.fk.forall(_ == p.id))\n}\nctx.run(q)\n// SELECT p.id, p.name, a.fk, a.street, a.zip FROM Person p INNER JOIN Address a ON a.fk IS NULL OR a.fk = p.id\n")),(0,r.kt)("p",null,"Typically this is useful when doing negative conditions, e.g. when a field is ",(0,r.kt)("strong",{parentName:"p"},"not")," some specified value (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},'"Joe"'),").\nBeing ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," in this case is typically a matching result."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].filter(p => p.name.forall(_ != \"Joe\"))\n}\n\nctx.run(q)\n// SELECT p.id, p.name FROM Person p WHERE p.name IS NULL OR p.name <> 'Joe'\n")),(0,r.kt)("h4",{id:"filterifdefined"},"filterIfDefined"),(0,r.kt)("p",null,"Use this to filter by a optional field that you want to ignore when None.\nThis is useful when you want to filter by a map-key that may or may not exist."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val fieldFilters: Map[String, String] = Map("name" -> "Joe", "age" -> "123")\nval q = quote {\n  query[Person].filter(p => lift(fieldFilters.get("name)).filterIfDefined(_ == p.name))\n}\n \nctx.run(q)\n// SELECT p.id, p.name, p.title FROM Person p WHERE p.title IS NULL OR p.title = \'The Honorable\'\n')),(0,r.kt)("p",null,"It also works for regular fields."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"// case class Person(name: String, age: Int, title: Option[String])\nval q = quote {\n  query[Person].filter(p => p.title.filterIfDefined(_ == \"The Honorable\"))\n}\n \nctx.run(q)\n// SELECT p.id, p.name, p.title FROM Person p WHERE p.title IS NULL OR p.title = 'The Honorable'\n")),(0,r.kt)("h4",{id:"map-1"},"map"),(0,r.kt)("p",null,"As in regular Scala code, performing any operation on an optional value typically requires using the ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n for {\n    p <- query[Person]\n  } yield (p.id, p.name.map(\"Dear \" + _))\n}\n\nctx.run(q)\n// SELECT p.id, 'Dear ' || p.name FROM Person p\n// * In Dialects where `||` does not fall-through for nulls (e.g. Oracle):\n// * SELECT p.id, CASE WHEN p.name IS NOT NULL THEN 'Dear ' || p.name ELSE null END FROM Person p\n")),(0,r.kt)("p",null,"Additionally, this method is useful when you want to get a non-optional field out of an outer-joined table\n(i.e. a table wrapped in an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," object)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Company].leftJoin(query[Address])\n    .on((c, a) => c.zip == a.zip)\n    .map {case(c,a) =>                          // Row type is (Company, Option[Address])\n      (c.name, a.map(_.street), a.map(_.zip))   // Use `Option.map` to get `street` and `zip` fields\n    }\n}\n\nrun(q)\n// SELECT c.name, a.street, a.zip FROM Company c LEFT JOIN Address a ON c.zip = a.zip\n")),(0,r.kt)("p",null,"For more details about this operation (and some caveats), see the 'Optional Tables' section."),(0,r.kt)("h4",{id:"flatmap-and-flatten"},"flatMap and flatten"),(0,r.kt)("p",null,"Use these when the ",(0,r.kt)("inlineCode",{parentName:"p"},"Option.map")," functionality is not sufficient. This typically happens when you need to manipulate\nmultiple nullable fields in a way which would otherwise result in ",(0,r.kt)("inlineCode",{parentName:"p"},"Option[Option[T]]"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  for {\n    a <- query[Person]\n    b <- query[Person] if (a.id > b.id)\n  } yield (\n    // If this was `a.name.map`, resulting record type would be Option[Option[String]]\n    a.name.flatMap(an =>\n      b.name.map(bn =>\n        an+\" comes after \"+bn)))\n}\n\nctx.run(q) //: List[Option[String]]\n// SELECT (a.name || ' comes after ') || b.name FROM Person a, Person b WHERE a.id > b.id\n// * In Dialects where `||` does not fall-through for nulls (e.g. Oracle):\n// * SELECT CASE WHEN a.name IS NOT NULL AND b.name IS NOT NULL THEN (a.name || ' comes after ') || b.name ELSE null END FROM Person a, Person b WHERE a.id > b.id\n\n// Alternatively, you can use `flatten`\nval q = quote {\n  for {\n    a <- query[Person]\n    b <- query[Person] if (a.id > b.id)\n  } yield (\n    a.name.map(an =>\n      b.name.map(bn =>\n        an + \" comes after \" + bn)).flatten)\n}\n\nctx.run(q) //: List[Option[String]]\n// SELECT (a.name || ' comes after ') || b.name FROM Person a, Person b WHERE a.id > b.id\n")),(0,r.kt)("p",null,"This is also very useful when selecting from outer-joined tables i.e. where the entire table\nis inside of an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," object. Note how below we get the ",(0,r.kt)("inlineCode",{parentName:"p"},"fk")," field from ",(0,r.kt)("inlineCode",{parentName:"p"},"Option[Address]"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].leftJoin(query[Address])\n    .on((p, a) => a.fk.exists(_ == p.id))\n    .map {case (p /*Person*/, a /*Option[Address]*/) => (p.name, a.flatMap(_.fk))}\n}\n\nctx.run(q) //: List[(Option[String], Option[Int])]\n// SELECT p.name, a.fk FROM Person p LEFT JOIN Address a ON a.fk = p.id\n")),(0,r.kt)("h4",{id:"ornull--getornull"},"orNull / getOrNull"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"orNull")," method can be used to convert an Option-enclosed row back into a regular row.\nSince ",(0,r.kt)("inlineCode",{parentName:"p"},"Option[T].orNull")," does not work for primitive types (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"Int"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Double"),", etc...),\nyou can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"getOrNull")," method inside of quoted blocks to do the same thing."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that since the presence of null columns can cause queries to break in some data sources (e.g. Spark), so use this operation very carefully.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].join(query[Address])\n    .on((p, a) => a.fk.exists(_ == p.id))\n    .filter {case (p /*Person*/, a /*Option[Address]*/) =>\n      a.fk.getOrNull != 123 } // Exclude a particular value from the query.\n                              // Since we already did an inner-join on this value, we know it is not null.\n}\n\nctx.run(q) //: List[(Address, Person)]\n// SELECT p.id, p.name, a.fk, a.street, a.zip FROM Person p INNER JOIN Address a ON a.fk IS NOT NULL AND a.fk = p.id WHERE a.fk <> 123\n")),(0,r.kt)("p",null,"In certain situations, you may wish to pretend that a nullable-field is not actually nullable and perform regular operations\n(e.g. arithmetic, concatenation, etc...) on the field. You can use a combination of ",(0,r.kt)("inlineCode",{parentName:"p"},"Option.apply")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"orNull")," (or ",(0,r.kt)("inlineCode",{parentName:"p"},"getOrNull")," where needed)\nin order to do this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].map(p => Option(p.name.orNull + \" suffix\"))\n}\n\nctx.run(q)\n// SELECT p.name || ' suffix' FROM Person p\n// i.e. same as the previous behavior\n")),(0,r.kt)("p",null,"In all other situations, since Quill strictly checks nullable values, and ",(0,r.kt)("inlineCode",{parentName:"p"},"case.. if")," conditionals will work correctly in all Optional constructs.\nHowever, since they may introduce behavior changes in your codebase, the following warning has been introduced:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Conditionals inside of Option.","[map | flatMap | exists | forall]"," will create a ",(0,r.kt)("inlineCode",{parentName:"p"},"CASE")," statement in order to properly null-check the sub-query (...)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"val q = quote {\n  query[Person].map(p => p.name.map(n => if (n == \"Joe\") \"foo\" else \"bar\").getOrElse(\"baz\"))\n}\n// Information:(16, 15) Conditionals inside of Option.map will create a `CASE` statement in order to properly null-check the sub-query: `p.name.map((n) => if(n == \"Joe\") \"foo\" else \"bar\")`.\n// Expressions like Option(if (v == \"foo\") else \"bar\").getOrElse(\"baz\") will now work correctly, but expressions that relied on the broken behavior (where \"bar\" would be returned instead) need to be modified  (see the \"orNull / getOrNull\" section of the documentation of more detail).\n\nctx.run(a)\n// Used to be this:\n// SELECT CASE WHEN CASE WHEN p.name = 'Joe' THEN 'foo' ELSE 'bar' END IS NOT NULL THEN CASE WHEN p.name = 'Joe' THEN 'foo' ELSE 'bar' END ELSE 'baz' END FROM Person p\n// Now is this:\n// SELECT CASE WHEN p.name IS NOT NULL AND CASE WHEN p.name = 'Joe' THEN 'foo' ELSE 'bar' END IS NOT NULL THEN CASE WHEN p.name = 'Joe' THEN 'foo' ELSE 'bar' END ELSE 'baz' END FROM Person p\n")),(0,r.kt)("h3",{id:"equals"},"equals"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"=="),", ",(0,r.kt)("inlineCode",{parentName:"p"},"!="),", and ",(0,r.kt)("inlineCode",{parentName:"p"},".equals")," methods can be used to compare regular types as well Option types in a scala-idiomatic way.\nThat is to say, either ",(0,r.kt)("inlineCode",{parentName:"p"},"T == T")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Option[T] == Option[T]"),' is supported and the following "truth-table" is observed:'),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Left"),(0,r.kt)("th",{parentName:"tr",align:null},"Right"),(0,r.kt)("th",{parentName:"tr",align:null},"Equality"),(0,r.kt)("th",{parentName:"tr",align:null},"Result"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"a")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"b")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"==")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"a == b"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Some[T](a)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Some[T](b)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"==")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"a == b"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Some[T](a)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"None")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"==")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"None      ")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Some[T](b)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"==")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"None      ")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"None")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"==")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Some[T]   ")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Some[R]   ")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"==")),(0,r.kt)("td",{parentName:"tr",align:null},"Exception thrown.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"a")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"b")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"!=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"a != b"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Some[T](a)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Some[T](b)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"!=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"a != b"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Some[T](a)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"None")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"!=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"None      ")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Some[T](b)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"!=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Some[T]   ")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Some[R]   ")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"!=")),(0,r.kt)("td",{parentName:"tr",align:null},"Exception thrown.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"None      ")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"None")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"!=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false"))))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Node(id:Int, status:Option[String], otherStatus:Option[String])\n\nval q = quote { query[Node].filter(n => n.id == 123) }\nctx.run(q)\n// SELECT n.id, n.status, n.otherStatus FROM Node n WHERE p.id = 123\n\nval q = quote { query[Node].filter(r => r.status == r.otherStatus) }\nctx.run(q)\n// SELECT r.id, r.status, r.otherStatus FROM Node r WHERE r.status IS NULL AND r.otherStatus IS NULL OR r.status = r.otherStatus\n\nval q = quote { query[Node].filter(n => n.status == Option(\"RUNNING\")) }\nctx.run(q)\n// SELECT n.id, n.status, n.otherStatus FROM node n WHERE n.status IS NOT NULL AND n.status = 'RUNNING'\n\nval q = quote { query[Node].filter(n => n.status != Option(\"RUNNING\")) }\nctx.run(q)\n// SELECT n.id, n.status, n.otherStatus FROM node n WHERE n.status IS NULL OR n.status <> 'RUNNING'\n")),(0,r.kt)("p",null,"If you would like to use an equality operator that follows that ansi-idiomatic approach, failing\nthe comparison if either side is null as well as the principle that ",(0,r.kt)("inlineCode",{parentName:"p"},"null = null := false"),", you can import ",(0,r.kt)("inlineCode",{parentName:"p"},"===")," (and ",(0,r.kt)("inlineCode",{parentName:"p"},"=!="),")\nfrom ",(0,r.kt)("inlineCode",{parentName:"p"},"Context.extras"),". These operators work across ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Option[T]")," allowing comparisons like ",(0,r.kt)("inlineCode",{parentName:"p"},"T === Option[T]"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"Option[T] == T")," etc... to be made. You can use also ",(0,r.kt)("inlineCode",{parentName:"p"},"==="),"\ndirectly in Scala code and it will have the same behavior, returning ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," when other the left-hand\nor right-hand side is ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),". This is particularity useful in paradigms like Spark where\nyou will typically transition inside and outside of Quill code."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"When using ",(0,r.kt)("inlineCode",{parentName:"p"},"a === b")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"a =!= b")," sometimes you will see the extra ",(0,r.kt)("inlineCode",{parentName:"p"},"a IS NOT NULL AND b IS NOT NULL")," comparisons\nand sometimes you will not. This depends on ",(0,r.kt)("inlineCode",{parentName:"p"},"equalityBehavior")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"SqlIdiom")," which determines whether the given SQL\ndialect already does ansi-idiomatic comparison to ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," when an ",(0,r.kt)("inlineCode",{parentName:"p"},"=")," operator is used,\nthis allows us to omit the extra ",(0,r.kt)("inlineCode",{parentName:"p"},"a IS NOT NULL AND b IS NOT NULL"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import ctx.extras._\n\n// === works the same way inside of a quotation\nval q = run( query[Node].filter(n => n.status === "RUNNING") )\n// SELECT n.id, n.status FROM node n WHERE n.status IS NOT NULL AND n.status = \'RUNNING\'\n\n// as well as outside\n(nodes:List[Node]).filter(n => n.status === "RUNNING")\n')),(0,r.kt)("h4",{id:"optional-tables"},"Optional Tables"),(0,r.kt)("p",null,"As we have seen in the examples above, only the ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"flatMap")," methods are available on outer-joined tables\n(i.e. tables wrapped in an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," object)."),(0,r.kt)("p",null,"Since you cannot use ",(0,r.kt)("inlineCode",{parentName:"p"},"Option[Table].isDefined"),", if you want to null-check a whole table\n(e.g. if a left-join was not matched), you have to ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," to a specific field on which you can do the null-check."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Company].leftJoin(query[Address])\n    .on((c, a) => c.zip == a.zip)         // Row type is (Company, Option[Address])\n    .filter({case(c,a) => a.isDefined})   // You cannot null-check a whole table!\n}\n")),(0,r.kt)("p",null,"Instead, map the row-variable to a specific field and then check that field."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Company].leftJoin(query[Address])\n    .on((c, a) => c.zip == a.zip)                     // Row type is (Company, Option[Address])\n    .filter({case(c,a) => a.map(_.street).isDefined}) // Null-check a non-nullable field instead\n}\nctx.run(q)\n// SELECT c.name, c.zip, a.fk, a.street, a.zip\n// FROM Company c\n// LEFT JOIN Address a ON c.zip = a.zip\n// WHERE a.street IS NOT NULL\n")),(0,r.kt)("p",null,"Finally, it is worth noting that a whole table can be wrapped into an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," object. This is particularly\nuseful when doing a union on table-sets that are both right-joined and left-joined together."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val aCompanies = quote {\n  for {\n    c <- query[Company] if (c.name like \"A%\")\n    a <- query[Address].join(_.zip == c.zip)\n  } yield (c, Option(a))  // change (Company, Address) to (Company, Option[Address])\n}\nval bCompanies = quote {\n  for {\n    c <- query[Company] if (c.name like \"A%\")\n    a <- query[Address].leftJoin(_.zip == c.zip)\n  } yield (c, a) // (Company, Option[Address])\n}\nval union = quote {\n  aCompanies union bCompanies\n}\nctx.run(union)\n// SELECT x.name, x.zip, x.fk, x.street, x.zip FROM (\n// (SELECT c.name name, c.zip zip, x1.zip zip, x1.fk fk, x1.street street\n// FROM Company c INNER JOIN Address x1 ON x1.zip = c.zip WHERE c.name like 'A%')\n// UNION\n// (SELECT c1.name name, c1.zip zip, x2.zip zip, x2.fk fk, x2.street street\n// FROM Company c1 LEFT JOIN Address x2 ON x2.zip = c1.zip WHERE c1.name like 'A%')\n// ) x\n")),(0,r.kt)("h3",{id:"ad-hoc-case-classes"},"Ad-Hoc Case Classes"),(0,r.kt)("p",null,"Case Classes can also be used inside quotations as output values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Person(id: Int, name: String, age: Int)\ncase class Contact(personId: Int, phone: String)\ncase class ReachablePerson(name:String, phone: String)\n\nval q = quote {\n  for {\n    p <- query[Person] if(p.id == 999)\n    c <- query[Contact] if(c.personId == p.id)\n  } yield {\n    ReachablePerson(p.name, c.phone)\n  }\n}\n\nctx.run(q)\n// SELECT p.name, c.phone FROM Person p, Contact c WHERE (p.id = 999) AND (c.personId = p.id)\n")),(0,r.kt)("p",null,"As well as in general:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class IdFilter(id:Int)\n\nval q = quote {\n  val idFilter = new IdFilter(999)\n  for {\n    p <- query[Person] if(p.id == idFilter.id)\n    c <- query[Contact] if(c.personId == p.id)\n  } yield {\n    ReachablePerson(p.name, c.phone)\n  }\n}\n\nctx.run(q)\n// SELECT p.name, c.phone FROM Person p, Contact c WHERE (p.id = 999) AND (c.personId = p.id)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Note"))," however that this functionality has the following restrictions:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The Ad-Hoc Case Class can only have one constructor with one set of parameters."),(0,r.kt)("li",{parentName:"ol"},"The Ad-Hoc Case Class must be constructed inside the quotation using one of the following methods:",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"Using the ",(0,r.kt)("inlineCode",{parentName:"li"},"new")," keyword: ",(0,r.kt)("inlineCode",{parentName:"li"},'new Person("Joe", "Bloggs")')),(0,r.kt)("li",{parentName:"ol"},"Using a companion object's apply method:  ",(0,r.kt)("inlineCode",{parentName:"li"},'Person("Joe", "Bloggs")')),(0,r.kt)("li",{parentName:"ol"},"Using a companion object's apply method explicitly: ",(0,r.kt)("inlineCode",{parentName:"li"},'Person.apply("Joe", "Bloggs")')))),(0,r.kt)("li",{parentName:"ol"},"Any custom logic in a constructor/apply-method of an Ad-Hoc case class will not be invoked when it is 'constructed' inside a quotation. To construct an Ad-Hoc case class with custom logic inside a quotation, you can use a quoted method.")),(0,r.kt)("h2",{id:"query-probing"},"Query probing"),(0,r.kt)("p",null,"Query probing validates queries against the database at compile time, failing the compilation if it is not valid. The query validation does not alter the database state."),(0,r.kt)("p",null,"This feature is disabled by default. To enable it, mix the ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryProbing")," trait to the database configuration:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"object myContext extends YourContextType with QueryProbing\n")),(0,r.kt)("p",null,"The context must be created in a separate compilation unit in order to be loaded at compile time. Please use ",(0,r.kt)("a",{parentName:"p",href:"http://www.scala-sbt.org/0.13/docs/Macro-Projects.html"},"this guide")," that explains how to create a separate compilation unit for macros, that also serves to the purpose of defining a query-probing-capable context. ",(0,r.kt)("inlineCode",{parentName:"p"},"context")," could be used instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"macros")," as the name of the separate compilation unit."),(0,r.kt)("p",null,"The configurations correspondent to the config key must be available at compile time. You can achieve it by adding this line to your project settings:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'unmanagedClasspath in Compile += baseDirectory.value / "src" / "main" / "resources"\n')),(0,r.kt)("p",null,"If your project doesn't have a standard layout, e.g. a play project, you should configure the path to point to the folder that contains your config file."),(0,r.kt)("h2",{id:"actions"},"Actions"),(0,r.kt)("p",null,"Database actions are defined using quotations as well. These actions don't have a collection-like API but rather a custom DSL to express inserts, deletes, and updates."),(0,r.kt)("h3",{id:"insertvalue--insert"},"insertValue / insert"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val a = quote(query[Contact].insertValue(lift(Contact(999, "+1510488988"))))\n\nctx.run(a) // = 1 if the row was inserted 0 otherwise\n// INSERT INTO Contact (personId,phone) VALUES (?, ?)\n')),(0,r.kt)("h4",{id:"it-is-also-possible-to-insert-specific-columns-via-insert"},"It is also possible to insert specific columns (via insert):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val a = quote {\n  query[Contact].insert(_.personId -> lift(999), _.phone -> lift("+1510488988"))\n}\n\nctx.run(a)\n// INSERT INTO Contact (personId,phone) VALUES (?, ?)\n')),(0,r.kt)("h3",{id:"batch-insert"},"batch insert"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val a = quote {\n  liftQuery(List(Person(0, "John", 31),Person(2, "name2", 32))).foreach(e => query[Person].insertValue(e))\n}\n\nctx.run(a) //: List[Long] size = 2. Contains 1 @ positions, where row was inserted E.g List(1,1)\n// INSERT INTO Person (id,name,age) VALUES (?, ?, ?)\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"In addition to regular JDBC batching, Quill can optimize batch queries by using multiple VALUES-clauses e.g:"),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"ctx.run(a, 2)\n// INSERT INTO Person (id,name,age) VALUES (?, ?, ?), (?, ?, ?) // Note, the extract (?, ?, ?) will not be visible in the compiler output. \n")),(0,r.kt)("p",{parentName:"blockquote"},"In situations with high network latency this can improve performance by 20-40x! See the ",(0,r.kt)("a",{parentName:"p",href:"#batch-optimization"},"Batch Optimization")," below for more info.")),(0,r.kt)("p",null,"Just as in regular queries use the extended insert/update syntaxes to achieve finer-grained control of the data being created/modified modified.\nFor example, if the ID is a generated value you can skip ID insertion like this:\n(This can also be accomplied with an insert-meta)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'// case class Person(id: Int, name: String, age: Int)\nval a = quote {\n  liftQuery(List(Person(0, "John", 31),Person(0, "name2", 32))).foreach(e => query[Person].insert(_.name -> p.name, _.age -> p.age))\n}\n\nctx.run(a)\n// INSERT INTO Person (name,age) VALUES (?, ?)\n')),(0,r.kt)("p",null,"Batch queries can also have a returning/returningGenerated clause:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'// case class Person(id: Int, name: String, age: Int)\nval a = quote {\n  liftQuery(List(Person(0, "John", 31),Person(0, "name2", 32))).foreach(e => query[Person].insert(_.name -> p.name, _.age -> p.age)).returning(_.id)\n}\n\nctx.run(a)\n// INSERT INTO Person (name,age) VALUES (?, ?) RETURNING id\n')),(0,r.kt)("p",null,"Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"liftQuery[Something]")," and the query","[Something]","` values do not necessarily need to be the same object-type.\n(In fact the liftQuery value can even be a constant!)\nFor example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"// case class Person(name: String, age: Int)\n// case class Vip(first: String, last: String, age: Int)\n// val vips: List[Vip] = ...\nval q = quote {\n  liftQuery(vips).foreach(v => query[Person].insertValue(Person(v.first + v.last, v.age)))\n}\n\nctx.run(q)\n// INSERT INTO Person (name,age) VALUES ((? || ?), ?)\n")),(0,r.kt)("p",null,"Note that UPDATE queries can also be done in batches (as well as DELETE queries)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  liftQuery(vips).foreach(v => query[Person].filter(p => p.age > 22).updateValue(Person(v.first + v.last, v.age)))\n}\n\nctx.run(q)\n// UPDATE Person SET name = (? || ?), age = ? WHERE age > 22\n")),(0,r.kt)("h3",{id:"updatevalue--update"},"updateValue / update"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val a = quote {\n  query[Person].filter(_.id == 999).updateValue(lift(Person(999, "John", 22)))\n}\n\nctx.run(a) // = Long number of rows updated\n// UPDATE Person SET id = ?, name = ?, age = ? WHERE id = 999\n')),(0,r.kt)("h4",{id:"using-specific-columns-via-update"},"Using specific columns (via update):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val a = quote {\n  query[Person].filter(p => p.id == lift(999)).update(_.age -> lift(18))\n}\n\nctx.run(a)\n// UPDATE Person SET age = ? WHERE id = ?\n")),(0,r.kt)("h4",{id:"using-columns-as-part-of-the-update"},"Using columns as part of the update:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val a = quote {\n  query[Person].filter(p => p.id == lift(999)).update(p => p.age -> (p.age + 1))\n}\n\nctx.run(a)\n// UPDATE Person SET age = (age + 1) WHERE id = ?\n")),(0,r.kt)("h3",{id:"batch-update"},"batch update"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val a = quote {\n  liftQuery(List(Person(1, "name", 31),Person(2, "name2", 32))).foreach { person =>\n     query[Person].filter(_.id == person.id).update(_.name -> person.name, _.age -> person.age)\n  }\n}\n\nctx.run(a) // : List[Long] size = 2. Contains 1 @ positions, where row was inserted E.g List(1,0)\n// UPDATE Person SET name = ?, age = ? WHERE id = ?\n')),(0,r.kt)("h3",{id:"delete"},"delete"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val a = quote {\n  query[Person].filter(p => p.name == \"\").delete\n}\n\nctx.run(a) // = Long the number of rows deleted\n// DELETE FROM Person WHERE name = ''\n")),(0,r.kt)("h3",{id:"insert-or-update-upsert-conflict"},"insert or update (upsert, conflict)"),(0,r.kt)("p",null,"Upsert is supported by Postgres, SQLite, MySQL and H2 ",(0,r.kt)("inlineCode",{parentName:"p"},"onConflictIgnore")," only (since v1.4.200 in PostgreSQL compatibility mode)"),(0,r.kt)("h4",{id:"postgres-and-sqlite"},"Postgres and SQLite"),(0,r.kt)("h5",{id:"ignore-conflict"},"Ignore conflict"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val a = quote {\n  query[Product].insert(_.id -> 1, _.sku -> 10).onConflictIgnore\n}\n\n// INSERT INTO Product AS t (id,sku) VALUES (1, 10) ON CONFLICT DO NOTHING\n")),(0,r.kt)("p",null,"Ignore conflict by explicitly setting conflict target"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val a = quote {\n  query[Product].insert(_.id -> 1, _.sku -> 10).onConflictIgnore(_.id)\n}\n\n// INSERT INTO Product AS t (id,sku) VALUES (1, 10) ON CONFLICT (id) DO NOTHING\n")),(0,r.kt)("p",null,"Multiple properties can be used as well."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val a = quote {\n  query[Product].insert(_.id -> 1, _.sku -> 10).onConflictIgnore(_.id, _.description)\n}\n\n// INSERT INTO Product (id,sku) VALUES (1, 10) ON CONFLICT (id,description) DO NOTHING\n")),(0,r.kt)("h5",{id:"update-on-conflict"},"Update on Conflict"),(0,r.kt)("p",null,"Resolve conflict by updating existing row if needed. In ",(0,r.kt)("inlineCode",{parentName:"p"},"onConflictUpdate(target)((t, e) => assignment)"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"target")," refers to\nconflict target, ",(0,r.kt)("inlineCode",{parentName:"p"},"t")," - to existing row and ",(0,r.kt)("inlineCode",{parentName:"p"},"e")," - to excluded, e.g. row proposed for insert."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val a = quote {\n  query[Product]\n    .insert(_.id -> 1, _.sku -> 10)\n    .onConflictUpdate(_.id)((t, e) => t.sku -> (t.sku + e.sku))\n}\n\n// INSERT INTO Product AS t (id,sku) VALUES (1, 10) ON CONFLICT (id) DO UPDATE SET sku = (t.sku + EXCLUDED.sku)\n")),(0,r.kt)("p",null,"Multiple properties can be used with ",(0,r.kt)("inlineCode",{parentName:"p"},"onConflictUpdate")," as well."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val a = quote {\n  query[Product]\n    .insert(_.id -> 1, _.sku -> 10)\n    .onConflictUpdate(_.id, _.description)((t, e) => t.sku -> (t.sku + e.sku))\n}\n\nINSERT INTO Product AS t (id,sku) VALUES (1, 10) ON CONFLICT (id,description) DO UPDATE SET sku = (t.sku + EXCLUDED.sku)\n")),(0,r.kt)("h4",{id:"mysql"},"MySQL"),(0,r.kt)("p",null,"Ignore any conflict, e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"insert ignore")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val a = quote {\n  query[Product].insert(_.id -> 1, _.sku -> 10).onConflictIgnore\n}\n\n// INSERT IGNORE INTO Product (id,sku) VALUES (1, 10)\n")),(0,r.kt)("p",null,"Ignore duplicate key conflict by explicitly setting it"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val a = quote {\n  query[Product].insert(_.id -> 1, _.sku -> 10).onConflictIgnore(_.id)\n}\n\n// INSERT INTO Product (id,sku) VALUES (1, 10) ON DUPLICATE KEY UPDATE id=id\n")),(0,r.kt)("p",null,"Resolve duplicate key by updating existing row if needed. In ",(0,r.kt)("inlineCode",{parentName:"p"},"onConflictUpdate((t, e) => assignment)"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"t")," refers to\nexisting row and ",(0,r.kt)("inlineCode",{parentName:"p"},"e")," - to values, e.g. values proposed for insert."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val a = quote {\n  query[Product]\n    .insert(_.id -> 1, _.sku -> 10)\n    .onConflictUpdate((t, e) => t.sku -> (t.sku + e.sku))\n}\n\n// INSERT INTO Product (id,sku) VALUES (1, 10) ON DUPLICATE KEY UPDATE sku = (sku + VALUES(sku))\n")),(0,r.kt)("h2",{id:"batch-optimization"},"Batch Optimization"),(0,r.kt)("p",null,"When doing batch INSERT queries (as well as UPDATE, and DELETE), Quill mostly delegates the functionality to standard JDBC batching.\nThis functionality works roughtly in the following way."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val ps: PreparedStatement = connection.prepareStatement("INSERT ... VALUES ...")\n// 1. Iterate over the rows\nfor (row <- rowsToInsert) {\n  // 2. For each row, add the columns to the prepared statement\n  for ((column, columnIndex) <- row)\n    row.setColumn(column, columnIndex)\n  // 3. Add the row to the list of things being added in the batch\n  ps.addBatch()\n}\n// 4. Write everything in the batch to the Database\nps.executeBatch()\n')),(0,r.kt)("p",null,"Reasonably speaking, we would expect each call in Stage #3 to locally stage the value of the row and then submit\nall of the rows to the database in Stage #4 but that basically every database that is not what happens. In Stage #3,\na network call is actually made to the Database to remotely stage the row. Practically this means that the performance of\naddBatch/executeBatch degrades per-row, per-millisecond-network-latency. Even at 50 milliseconds of network latency\nthe impact of this is highly significant:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Network Latency"),(0,r.kt)("th",{parentName:"tr",align:null},"Rows Inserted"),(0,r.kt)("th",{parentName:"tr",align:null},"Total Time"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0ms"),(0,r.kt)("td",{parentName:"tr",align:null},"10k rows"),(0,r.kt)("td",{parentName:"tr",align:null},"0.486")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"50ms"),(0,r.kt)("td",{parentName:"tr",align:null},"10k rows"),(0,r.kt)("td",{parentName:"tr",align:null},"3.226")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"100ms"),(0,r.kt)("td",{parentName:"tr",align:null},"10k rows"),(0,r.kt)("td",{parentName:"tr",align:null},"5.266")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0ms"),(0,r.kt)("td",{parentName:"tr",align:null},"100k rows"),(0,r.kt)("td",{parentName:"tr",align:null},"1.416")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"50ms"),(0,r.kt)("td",{parentName:"tr",align:null},"100k rows"),(0,r.kt)("td",{parentName:"tr",align:null},"23.248")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"100ms"),(0,r.kt)("td",{parentName:"tr",align:null},"100k rows"),(0,r.kt)("td",{parentName:"tr",align:null},"43.077")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0ms"),(0,r.kt)("td",{parentName:"tr",align:null},"1m rows"),(0,r.kt)("td",{parentName:"tr",align:null},"13.616")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"50ms"),(0,r.kt)("td",{parentName:"tr",align:null},"1m rows"),(0,r.kt)("td",{parentName:"tr",align:null},"234.452")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"100ms"),(0,r.kt)("td",{parentName:"tr",align:null},"1m rows"),(0,r.kt)("td",{parentName:"tr",align:null},"406.101")))),(0,r.kt)("p",null,"In order to alleviate this problem Quill can take advantage of the ability of most database dialects to use multiple\nVALUES-clauses to batch-insert rows. Conceptually, this works in the following way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'case class Person(name: String, age: Int)\nval people = List(Person("Joe", 22), Person("Jack", 33), Person("Jill", 44))\nval q = quote { liftQuery(people).foreach(p => query[Person].insertValue(p)) }\nrun(q, 2) // i.e. insert rows from the `people` list in batches of 2\n//\n// Query1) INSERT INTO Person (name, age) VALUES ([Joe] , [22]), ([Jack], [33])\n//         INSERT INTO Person (name, age) VALUES (  ?   ,  ?  ), (   ?  ,  ?  ) <- actual query\n// Query2) INSERT INTO Person (name, age) VALUES ([Jill], [44])\n//         INSERT INTO Person (name, age) VALUES (  ?   ,  ?  )                 <- actual query\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that only ",(0,r.kt)("inlineCode",{parentName:"p"},"INSERT INTO Person (name, age) VALUES (?, ?)")," will appear in the compiler-output for this query!")),(0,r.kt)("p",null,"Using a batch-count of about 1000-5000 rows (i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"run(q, 1000)"),") can significantly improve query performance:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Network Latency"),(0,r.kt)("th",{parentName:"tr",align:null},"Rows Inserted"),(0,r.kt)("th",{parentName:"tr",align:null},"Total Time"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0ms"),(0,r.kt)("td",{parentName:"tr",align:null},"10k rows"),(0,r.kt)("td",{parentName:"tr",align:null},"3.772")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"50ms"),(0,r.kt)("td",{parentName:"tr",align:null},"10k rows"),(0,r.kt)("td",{parentName:"tr",align:null},"3.899")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"100ms"),(0,r.kt)("td",{parentName:"tr",align:null},"10k rows"),(0,r.kt)("td",{parentName:"tr",align:null},"4.63")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0ms"),(0,r.kt)("td",{parentName:"tr",align:null},"100k rows"),(0,r.kt)("td",{parentName:"tr",align:null},"2.902")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"50ms"),(0,r.kt)("td",{parentName:"tr",align:null},"100k rows"),(0,r.kt)("td",{parentName:"tr",align:null},"3.225")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"100ms"),(0,r.kt)("td",{parentName:"tr",align:null},"100k rows"),(0,r.kt)("td",{parentName:"tr",align:null},"3.554")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0ms"),(0,r.kt)("td",{parentName:"tr",align:null},"1m rows"),(0,r.kt)("td",{parentName:"tr",align:null},"9.923")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"50ms"),(0,r.kt)("td",{parentName:"tr",align:null},"1m rows"),(0,r.kt)("td",{parentName:"tr",align:null},"10.035")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"100ms"),(0,r.kt)("td",{parentName:"tr",align:null},"1m rows"),(0,r.kt)("td",{parentName:"tr",align:null},"10.328")))),(0,r.kt)("p",null,"One thing to take note of is that each one of the ",(0,r.kt)("inlineCode",{parentName:"p"},"?")," placeholders above is a prepared-statement variable. This means\nthat in batch-sizes of 1000, there will be 1000 ",(0,r.kt)("inlineCode",{parentName:"p"},"?")," variables in each query. In many databases this has a strict limit.\nFor example, in Postgres this is restricted to 32767. This means that when using batches of 1000 rows, each row can have\nup to 32 columns or the following error will occur:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"IOException: Tried to send an out-of-range integer as a 2-byte value\n")),(0,r.kt)("p",null,"In other database e.g. SQL Server, unfortunately this limit is much smaller. For example in SQL Server it is just 2100 variables\nor the following error will occur."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"The server supports a maximum of 2100 parameters. Reduce the number of parameters and resend the request\n")),(0,r.kt)("p",null,"This means that in SQL Server, for a batch-size of 100, you can only insert into a table of up to 21 columns."),(0,r.kt)("p",null,"In the future, we hope to alleviate this issue by directly substituting variables into ",(0,r.kt)("inlineCode",{parentName:"p"},"?")," variables before the query is executed\nhowever such functionality could potentially come at the risk of SQL-injection vunerabilities."),(0,r.kt)("h2",{id:"printing-queries"},"Printing Queries"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"translate")," method is used to convert a Quill query into a string which can then be printed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val str = ctx.translate(query[Person])\nprintln(str)\n// SELECT x.id, x.name, x.age FROM Person x\n")),(0,r.kt)("p",null,"Insert queries can also be printed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val str = ctx.translate(query[Person].insertValue(lift(Person(0, \"Joe\", 45))))\nprintln(str)\n// INSERT INTO Person (id,name,age) VALUES (0, 'Joe', 45)\n")),(0,r.kt)("p",null,"As well as batch insertions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  liftQuery(List(Person(0, \"Joe\",44), Person(1, \"Jack\",45)))\n    .foreach(e => query[Person].insertValue(e))\n}\nval strs: List[String] = ctx.translate(q)\nstrs.map(println)\n// INSERT INTO Person (id, name,age) VALUES (0, 'Joe', 44)\n// INSERT INTO Person (id, name,age) VALUES (1, 'Jack', 45)\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"translate")," method is available in every Quill context as well as the Cassandra and OrientDB contexts,\nthe latter two, however, do not support Insert and Batch Insert query printing."),(0,r.kt)("h2",{id:"io-monad"},"IO Monad"),(0,r.kt)("p",null,"Quill provides an IO monad that allows the user to express multiple computations and execute them separately. This mechanism is also known as a free monad, which provides a way of expressing computations as referentially-transparent values and isolates the unsafe IO operations into a single operation. For instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'// this code using Future\n\ncase class Person(id: Int, name: String, age: Int)\n\nval p = Person(0, "John", 22)\nctx.run(query[Person].insertValue(lift(p))).flatMap { _ =>\n  ctx.run(query[Person])\n}\n\n// isn\'t referentially transparent because if you refactor the second database\n// interaction into a value, the result will be different:\n\nval allPeople = ctx.run(query[Person])\nctx.run(query[Person].insertValue(lift(p))).flatMap { _ =>\n  allPeople\n}\n\n// this happens because `ctx.run` executes the side-effect (database IO) immediately\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'// The IO monad doesn\'t perform IO immediately, so both computations:\n\nval p = Person(0, "John", 22)\n\nval a =\n  ctx.runIO(query[Person].insertValue(lift(p))).flatMap { _ =>\n    ctx.runIO(query[Person])\n  }\n\n\nval allPeople = ctx.runIO(query[Person])\n\nval b =\n  ctx.runIO(query[Person].insertValue(lift(p))).flatMap { _ =>\n    allPeople\n  }\n\n// produce the same result when executed\n\nperformIO(a) == performIO(b)\n')),(0,r.kt)("p",null,"The IO monad has an interface similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"Future"),"; please refer to ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/getquill/quill/blob/master/quill-core/src/main/scala/io/getquill/monad/IOMonad.scala#L39"},"the class")," for more information regarding the available operations."),(0,r.kt)("p",null,"The return type of ",(0,r.kt)("inlineCode",{parentName:"p"},"performIO")," varies according to the context. For instance, async contexts return ",(0,r.kt)("inlineCode",{parentName:"p"},"Future"),"s while JDBC returns values synchronously."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"NOTE")),": Avoid using the variable name ",(0,r.kt)("inlineCode",{parentName:"p"},"io")," since it conflicts with Quill's package ",(0,r.kt)("inlineCode",{parentName:"p"},"io.getquill"),", otherwise you will get the following error."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"recursive value io needs type\n")),(0,r.kt)("h3",{id:"io-monad-and-transactions"},"IO Monad and transactions"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"IO")," also provides the ",(0,r.kt)("inlineCode",{parentName:"p"},"transactional")," method that delimits a transaction:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val a =\n  ctx.runIO(query[Person].insertValue(lift(p))).flatMap { _ =>\n    ctx.runIO(query[Person])\n  }\n\nperformIO(a.transactional) // note: transactional can be used outside of `performIO`\n")),(0,r.kt)("h3",{id:"getting-a-resultset"},"Getting a ResultSet"),(0,r.kt)("p",null,"Quill JDBC Contexts allow you to use ",(0,r.kt)("inlineCode",{parentName:"p"},"prepare")," in order to get a low-level ",(0,r.kt)("inlineCode",{parentName:"p"},"ResultSet")," that is useful\nfor interacting with legacy APIs. This function  returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"f: (Connection) => (PreparedStatement)"),"\nclosure as opposed to a ",(0,r.kt)("inlineCode",{parentName:"p"},"PreparedStatement")," in order to guarantee that JDBC Exceptions are not\nthrown until you can wrap them into the appropriate Exception-handling mechanism (e.g.\n",(0,r.kt)("inlineCode",{parentName:"p"},"try"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"catch"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Try")," etc...)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Product].filter(_.id == 1)\n}\nval preparer: (Connection) => (PreparedStatement)  = ctx.prepare(q)\n// SELECT x1.id, x1.description, x1.sku FROM Product x1 WHERE x1.id = 1\n\n// Use ugly stateful code, bracketed effects, or try-with-resources here:\nvar preparedStatement: PreparedStatement = _\nvar resultSet: ResultSet = _\n\ntry {\n  preparedStatement = preparer(myCustomDataSource.getConnection)\n  resultSet = preparedStatement.executeQuery()\n} catch {\n  case e: Exception =>\n    // Close the preparedStatement and catch possible exceptions\n    // Close the resultSet and catch possible exceptions\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"prepare")," function can also be used with ",(0,r.kt)("inlineCode",{parentName:"p"},"insertValue"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"updateValue")," actions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val q = quote {\n  query[Product].insertValue(lift(Product(1, "Desc", 123))\n}\nval preparer: (Connection) => (PreparedStatement)  = ctx.prepare(q)\n// INSERT INTO Product (id,description,sku) VALUES (?, ?, ?)\n')),(0,r.kt)("p",null,"As well as with batch queries."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Make sure to first quote your batch query and then pass the result into the ",(0,r.kt)("inlineCode",{parentName:"p"},"prepare")," function\n(as is done in the example below) or the Scala compiler may not type the output correctly\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/getquill/quill/issues/1518"},"#1518"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  liftQuery(products).foreach(e => query[Product].insertValue(e))\n}\nval preparers: Connection => List[PreparedStatement] = ctx.prepare(q)\nval preparedStatement: List[PreparedStatement] = preparers(jdbcConf.dataSource.getConnection)\n")),(0,r.kt)("h3",{id:"effect-tracking"},"Effect tracking"),(0,r.kt)("p",null,"The IO monad tracks the effects that a computation performs in its second type parameter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val a: IO[ctx.RunQueryResult[Person], Effect.Write with Effect.Read] =\n  ctx.runIO(query[Person].insertValue(lift(p))).flatMap { _ =>\n    ctx.runIO(query[Person])\n  }\n")),(0,r.kt)("p",null,"This mechanism is useful to limit the kind of operations that can be performed. See this ",(0,r.kt)("a",{parentName:"p",href:"http://danielwestheide.com/blog/2015/06/28/put-your-writes-where-your-master-is-compile-time-restriction-of-slick-effect-types.html"},"blog post")," as an example."),(0,r.kt)("h2",{id:"implicit-query"},"Implicit query"),(0,r.kt)("p",null,"Quill provides implicit conversions from case class companion objects to ",(0,r.kt)("inlineCode",{parentName:"p"},"query[T]")," through an additional trait:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val ctx = new SqlMirrorContext(MirrorSqlDialect, Literal) with ImplicitQuery\n\nimport ctx._\n\nval q = quote {\n  for {\n    p <- Person if(p.id == 999)\n    c <- Contact if(c.personId == p.id)\n  } yield {\n    (p.name, c.phone)\n  }\n}\n\nctx.run(q)\n// SELECT p.name, c.phone FROM Person p, Contact c WHERE (p.id = 999) AND (c.personId = p.id)\n")),(0,r.kt)("p",null,"Note the usage of ",(0,r.kt)("inlineCode",{parentName:"p"},"Person")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Contact")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"query[Person]")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"query[Contact]"),"."),(0,r.kt)("h2",{id:"sql-specific-operations"},"SQL-specific operations"),(0,r.kt)("p",null,"Some operations are SQL-specific and not provided with the generic quotation mechanism. The SQL contexts provide implicit classes for this kind of operation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val ctx = new SqlMirrorContext(MirrorSqlDialect, Literal)\nimport ctx._\n")),(0,r.kt)("h3",{id:"like"},"like"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].filter(p => p.name like \"%John%\")\n}\nctx.run(q)\n// SELECT p.id, p.name, p.age FROM Person p WHERE p.name like '%John%'\n")),(0,r.kt)("h3",{id:"forupdate"},"forUpdate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].filter(p => p.name == \"Mary\").forUpdate()\n}\nctx.run(q)\n// SELECT p.id, p.name, p.age FROM Person p WHERE p.name = 'Mary' FOR UPDATE\n")),(0,r.kt)("h2",{id:"sql-specific-encoding"},"SQL-specific encoding"),(0,r.kt)("h3",{id:"arrays"},"Arrays"),(0,r.kt)("p",null,"Quill provides SQL Arrays support. In Scala we represent them as any collection that implements ",(0,r.kt)("inlineCode",{parentName:"p"},"Seq"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import java.util.Date\n\ncase class Book(id: Int, notes: List[String], pages: Vector[Int], history: Seq[Date])\n\nctx.run(query[Book])\n// SELECT x.id, x.notes, x.pages, x.history FROM Book x\n")),(0,r.kt)("p",null,"Note that not all drivers/databases provides such feature hence only ",(0,r.kt)("inlineCode",{parentName:"p"},"PostgresJdbcContext")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"PostgresAsyncContext")," support SQL Arrays."),(0,r.kt)("h2",{id:"cassandra-specific-encoding"},"Cassandra-specific encoding"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val ctx = new CassandraMirrorContext(Literal)\nimport ctx._\n")),(0,r.kt)("h3",{id:"collections"},"Collections"),(0,r.kt)("p",null,"The Cassandra context provides List, Set, and Map encoding:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"\ncase class Book(id: Int, notes: Set[String], pages: List[Int], history: Map[Int, Boolean])\n\nctx.run(query[Book])\n// SELECT id, notes, pages, history FROM Book\n")),(0,r.kt)("h3",{id:"user-defined-types"},"User-Defined Types"),(0,r.kt)("p",null,"The cassandra context provides encoding of UDT (user-defined types)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"\ncase class Name(firstName: String, lastName: String) extends Udt\n")),(0,r.kt)("p",null,"To encode the UDT and bind it into the query (insert/update queries), the context needs to retrieve UDT metadata from\nthe cluster object. By default, the context looks for UDT metadata within the currently logged keyspace, but it's also possible to specify a\nconcrete keyspace with ",(0,r.kt)("inlineCode",{parentName:"p"},"udtMeta"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'implicit val nameMeta = udtMeta[Name]("keyspace2.my_name")\n')),(0,r.kt)("p",null,"When a keyspace is not set in ",(0,r.kt)("inlineCode",{parentName:"p"},"udtMeta")," then the currently logged one is used."),(0,r.kt)("p",null,"Since it's possible to create a context without\nspecifying a keyspace, (e.g. the keyspace parameter is null and the session is not bound to any keyspace), the UDT metadata will be\nresolved throughout the entire cluster."),(0,r.kt)("p",null,"It is also possible to rename UDT columns with ",(0,r.kt)("inlineCode",{parentName:"p"},"udtMeta"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'implicit val nameMeta = udtMeta[Name]("name", _.firstName -> "first", _.lastName -> "last")\n')),(0,r.kt)("h2",{id:"cassandra-specific-operations"},"Cassandra-specific operations"),(0,r.kt)("p",null,"The cassandra context also provides a few additional operations:"),(0,r.kt)("h3",{id:"allowfiltering"},"allowFiltering"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].filter(p => p.age > 10).allowFiltering\n}\nctx.run(q)\n// SELECT id, name, age FROM Person WHERE age > 10 ALLOW FILTERING\n")),(0,r.kt)("h3",{id:"ifnotexists"},"ifNotExists"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].insert(_.age -> 10, _.name -> \"John\").ifNotExists\n}\nctx.run(q)\n// INSERT INTO Person (age,name) VALUES (10, 'John') IF NOT EXISTS\n")),(0,r.kt)("h3",{id:"ifexists"},"ifExists"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].filter(p => p.name == \"John\").delete.ifExists\n}\nctx.run(q)\n// DELETE FROM Person WHERE name = 'John' IF EXISTS\n")),(0,r.kt)("h3",{id:"usingtimestamp"},"usingTimestamp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q1 = quote {\n  query[Person].insert(_.age -> 10, _.name -> \"John\").usingTimestamp(99)\n}\nctx.run(q1)\n// INSERT INTO Person (age,name) VALUES (10, 'John') USING TIMESTAMP 99\n\nval q2 = quote {\n  query[Person].usingTimestamp(99).update(_.age -> 10)\n}\nctx.run(q2)\n// UPDATE Person USING TIMESTAMP 99 SET age = 10\n")),(0,r.kt)("h3",{id:"usingttl"},"usingTtl"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q1 = quote {\n  query[Person].insert(_.age -> 10, _.name -> \"John\").usingTtl(11)\n}\nctx.run(q1)\n// INSERT INTO Person (age,name) VALUES (10, 'John') USING TTL 11\n\nval q2 = quote {\n  query[Person].usingTtl(11).update(_.age -> 10)\n}\nctx.run(q2)\n// UPDATE Person USING TTL 11 SET age = 10\n\nval q3 = quote {\n  query[Person].usingTtl(11).filter(_.name == \"John\").delete\n}\nctx.run(q3)\n// DELETE FROM Person USING TTL 11 WHERE name = 'John'\n")),(0,r.kt)("h3",{id:"using"},"using"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q1 = quote {\n  query[Person].insert(_.age -> 10, _.name -> \"John\").using(ts = 99, ttl = 11)\n}\nctx.run(q1)\n// INSERT INTO Person (age,name) VALUES (10, 'John') USING TIMESTAMP 99 AND TTL 11\n\nval q2 = quote {\n  query[Person].using(ts = 99, ttl = 11).update(_.age -> 10)\n}\nctx.run(q2)\n// UPDATE Person USING TIMESTAMP 99 AND TTL 11 SET age = 10\n\nval q3 = quote {\n  query[Person].using(ts = 99, ttl = 11).filter(_.name == \"John\").delete\n}\nctx.run(q3)\n// DELETE FROM Person USING TIMESTAMP 99 AND TTL 11 WHERE name = 'John'\n")),(0,r.kt)("h3",{id:"ifcond"},"ifCond"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q1 = quote {\n  query[Person].update(_.age -> 10).ifCond(_.name == \"John\")\n}\nctx.run(q1)\n// UPDATE Person SET age = 10 IF name = 'John'\n\nval q2 = quote {\n  query[Person].filter(_.name == \"John\").delete.ifCond(_.age == 10)\n}\nctx.run(q2)\n// DELETE FROM Person WHERE name = 'John' IF age = 10\n")),(0,r.kt)("h3",{id:"delete-column"},"delete column"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Person].map(p => p.age).delete\n}\nctx.run(q)\n// DELETE p.age FROM Person\n")),(0,r.kt)("h3",{id:"listcontains--setcontains"},"list.contains / set.contains"),(0,r.kt)("p",null,"requires ",(0,r.kt)("inlineCode",{parentName:"p"},"allowFiltering")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Book].filter(p => p.pages.contains(25)).allowFiltering\n}\nctx.run(q)\n// SELECT id, notes, pages, history FROM Book WHERE pages CONTAINS 25 ALLOW FILTERING\n")),(0,r.kt)("h3",{id:"mapcontains"},"map.contains"),(0,r.kt)("p",null,"requires ",(0,r.kt)("inlineCode",{parentName:"p"},"allowFiltering")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Book].filter(p => p.history.contains(12)).allowFiltering\n}\nctx.run(q)\n// SELECT id, notes, pages, history FROM book WHERE history CONTAINS 12 ALLOW FILTERING\n")),(0,r.kt)("h3",{id:"mapcontainsvalue"},"map.containsValue"),(0,r.kt)("p",null,"requires ",(0,r.kt)("inlineCode",{parentName:"p"},"allowFiltering")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val q = quote {\n  query[Book].filter(p => p.history.containsValue(true)).allowFiltering\n}\nctx.run(q)\n// SELECT id, notes, pages, history FROM book WHERE history CONTAINS true ALLOW FILTERING\n")),(0,r.kt)("h2",{id:"dynamic-queries"},"Dynamic queries"),(0,r.kt)("p",null,"Quill's default operation mode is compile-time, but there are queries that have their structure defined only at runtime. Quill automatically falls back to runtime normalization and query generation if the query's structure is not static. Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val ctx = new SqlMirrorContext(MirrorSqlDialect, Literal)\n\nimport ctx._\n\nsealed trait QueryType\ncase object Minor extends QueryType\ncase object Senior extends QueryType\n\ndef people(t: QueryType): Quoted[Query[Person]] =\n  t match {\n    case Minor => quote {\n      query[Person].filter(p => p.age < 18)\n    }\n    case Senior => quote {\n      query[Person].filter(p => p.age > 65)\n    }\n  }\n\nctx.run(people(Minor))\n// SELECT p.id, p.name, p.age FROM Person p WHERE p.age < 18\n\nctx.run(people(Senior))\n// SELECT p.id, p.name, p.age FROM Person p WHERE p.age > 65\n")),(0,r.kt)("h3",{id:"dynamic-query-api"},"Dynamic query API"),(0,r.kt)("p",null,"Additionally, Quill provides a separate query API to facilitate the creation of dynamic queries. This API allows users to easily manipulate quoted values instead of working only with quoted transformations."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Important"),": A few of the dynamic query methods accept runtime string values. It's important to keep in mind that these methods could be a vector for SQL injection."),(0,r.kt)("p",null,"Let's use the ",(0,r.kt)("inlineCode",{parentName:"p"},"filter")," transformation as an example. In the regular API, this method has no implementation since it's an abstract member of a trait:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"def filter(f: T => Boolean): EntityQuery[T]\n")),(0,r.kt)("p",null,"In the dynamic API, ",(0,r.kt)("inlineCode",{parentName:"p"},"filter")," is has a different signature and a body that is executed at runtime:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"def filter(f: Quoted[T] => Quoted[Boolean]): DynamicQuery[T] =\n  transform(f, Filter)\n")),(0,r.kt)("p",null,"It takes a ",(0,r.kt)("inlineCode",{parentName:"p"},"Quoted[T]")," as input and produces a ",(0,r.kt)("inlineCode",{parentName:"p"},"Quoted[Boolean]"),". The user is free to use regular scala code within the transformation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def people(onlyMinors: Boolean) =\n  dynamicQuery[Person].filter(p => if(onlyMinors) quote(p.age < 18) else quote(true))\n")),(0,r.kt)("p",null,"In order to create a dynamic query, use one of the following methods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'dynamicQuery[Person]\ndynamicQuerySchema[Person]("people", alias(_.name, "pname"))\n')),(0,r.kt)("p",null,"It's also possible to transform a ",(0,r.kt)("inlineCode",{parentName:"p"},"Quoted")," into a dynamic query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val q = quote {\n  query[Person]\n}\nq.dynamic.filter(p => quote(p.name == "John"))\n')),(0,r.kt)("p",null,"The dynamic query API is very similar to the regular API but has a few differences:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Queries")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'// schema queries use `alias` instead of tuples\ndynamicQuerySchema[Person]("people", alias(_.name, "pname"))\n\n// this allows users to use a dynamic list of aliases\nval aliases = List(alias[Person](_.name, "pname"), alias[Person](_.age, "page"))\ndynamicQuerySchema[Person]("people", aliases:_*)\n\n// a few methods have an overload with the `Opt` suffix,\n// which apply the transformation only if the option is defined:\n\ndef people(minAge: Option[Int]) =\n  dynamicQuery[Person].filterOpt(minAge)((person, minAge) => quote(person.age >= minAge))\n\ndef people(maxRecords: Option[Int]) =\n  dynamicQuery[Person].takeOpt(maxRecords)\n\ndef people(dropFirst: Option[Int]) =\n  dynamicQuery[Person].dropOpt(dropFirst)\n\n// method with `If` suffix, for better chaining\ndef people(userIds: Seq[Int]) =\n  dynamicQuery[Person].filterIf(userIds.nonEmpty)(person => quote(liftQuery(userIds).contains(person.id)))\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Actions")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'// actions use `set`\ndynamicQuery[Person].filter(_.id == 1).update(set(_.name, quote("John")))\n\n// or `setValue` if the value is not quoted\ndynamicQuery[Person].insert(setValue(_.name, "John"))\n\n// or `setOpt` that will be applied only the option is defined\ndynamicQuery[Person].insert(setOpt(_.name, Some("John")))\n\n// it\'s also possible to use a runtime string value as the column name\ndynamicQuery[Person].filter(_.id == 1).update(set("name", quote("John")))\n\n// to insert or update a case class instance, use `insertValue`/`updateValue`\nval p = Person(0, "John", 21)\ndynamicQuery[Person].insertValue(p)\ndynamicQuery[Person].filter(_.id == 1).updateValue(p)\n')),(0,r.kt)("h3",{id:"dynamic-query-normalization-cache"},"Dynamic query normalization cache"),(0,r.kt)("p",null,"Quill is super fast for static queries (almost zero runtime overhead compared to directly sql executing)."),(0,r.kt)("p",null,"But there is significant impact for dynamic queries."),(0,r.kt)("p",null,"Normalization caching was introduced to improve the situation, which will speedup dynamic queries significantly. It is enabled by default."),(0,r.kt)("p",null,"To disable dynamic normalization caching, pass following property to sbt during compile time"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sbt -Dquill.query.cacheDaynamic=false\n")))}c.isMDXComponent=!0}}]);