"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[20358],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>k});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),d=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=d(e.components);return a.createElement(p.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),m=d(n),u=i,k=m["".concat(p,".").concat(u)]||m[u]||c[u]||r;return n?a.createElement(k,l(l({ref:t},s),{},{components:n})):a.createElement(k,l({ref:t},s))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=u;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[m]="string"==typeof e?e:i,l[1]=o;for(var d=2;d<r;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},69559:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var a=n(87462),i=(n(67294),n(3905));const r={id:"zio-2.x-migration-guide",title:"ZIO 2.x Migration Guide"},l=void 0,o={unversionedId:"guides/migrate/zio-2.x-migration-guide",id:"guides/migrate/zio-2.x-migration-guide",title:"ZIO 2.x Migration Guide",description:"In this guide we want to introduce the migration process to ZIO 2.x. So if you have a project written in ZIO 1.x and want to migrate that to ZIO 2.x, this article is for you.",source:"@site/docs/guides/migrate/migration-guide.md",sourceDirName:"guides/migrate",slug:"/guides/migrate/zio-2.x-migration-guide",permalink:"/guides/migrate/zio-2.x-migration-guide",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/guides/migrate/migration-guide.md",tags:[],version:"current",frontMatter:{id:"zio-2.x-migration-guide",title:"ZIO 2.x Migration Guide"},sidebar:"guides-sidebar",previous:{title:"Guava",permalink:"/guides/interop/with-guava"},next:{title:"Migration From Akka",permalink:"/guides/migrate/from-akka"}},p={},d=[{value:"Automatic Migration",id:"automatic-migration",level:2},{value:"Guidelines for Library Authors",id:"guidelines-for-library-authors",level:2},{value:"Deletion of Type Alias Companion Objects",id:"deletion-of-type-alias-companion-objects",level:2},{value:"Deletion of Has Data Type",id:"deletion-of-has-data-type",level:2},{value:"ZIO",id:"zio",level:2},{value:"Removed Methods",id:"removed-methods",level:3},{value:"ZIO 2.0 Naming Conventions",id:"zio-20-naming-conventions",level:3},{value:"Lazy Evaluation of Parameters",id:"lazy-evaluation-of-parameters",level:3},{value:"Composable Zips",id:"composable-zips",level:3},{value:"Compositional Concurrency",id:"compositional-concurrency",level:3},{value:"Either Values",id:"either-values",level:3},{value:"Descriptive Errors",id:"descriptive-errors",level:3},{value:"Elimination of Default Services From The ZIO Environment",id:"elimination-of-default-services-from-the-zio-environment",level:2},{value:"ZIO App",id:"zio-app",level:2},{value:"ZIOApp",id:"zioapp",level:3},{value:"Fiber",id:"fiber",level:2},{value:"Runtime, Platform and Executor",id:"runtime-platform-and-executor",level:2},{value:"Unsafe Marker",id:"unsafe-marker",level:3},{value:"Unsafe Variants",id:"unsafe-variants",level:3},{value:"Runtime Customization using Layers",id:"runtime-customization-using-layers",level:3},{value:"Runtime Customization Using ZIO Data Type",id:"runtime-customization-using-zio-data-type",level:3},{value:"Runtime Configurations are Scoped",id:"runtime-configurations-are-scoped",level:3},{value:"Custom Runtime for Mixed Applications",id:"custom-runtime-for-mixed-applications",level:3},{value:"Executor",id:"executor",level:3},{value:"Auto-Blocking",id:"auto-blocking",level:3},{value:"ZLayer",id:"zlayer",level:2},{value:"Constructing Layers",id:"constructing-layers",level:3},{value:"Accessing a Service from the Environment",id:"accessing-a-service-from-the-environment",level:3},{value:"Accessing Multiple Services in the Environment",id:"accessing-multiple-services-in-the-environment",level:3},{value:"Building the Dependency Graph",id:"building-the-dependency-graph",level:3},{value:"ZLayer Debugging",id:"zlayer-debugging",level:3},{value:"Descriptive ZIOApp Environment Compiler Errors",id:"descriptive-zioapp-environment-compiler-errors",level:3},{value:"Eliminators for Environmental Effects",id:"eliminators-for-environmental-effects",level:3},{value:"Service Pattern",id:"service-pattern",level:3},{value:"Other Changes",id:"other-changes",level:3},{value:"Scopes",id:"scopes",level:2},{value:"ZManaged",id:"zmanaged",level:3},{value:"Scopes",id:"scopes-1",level:3},{value:"Migration from <code>ZManaged</code> to <code>Scope</code>",id:"migration-from-zmanaged-to-scope",level:3},{value:"Deferred Migration",id:"deferred-migration",level:4},{value:"Immediate Migration",id:"immediate-migration",level:4},{value:"Simplification of Concurrent Data Types",id:"simplification-of-concurrent-data-types",level:2},{value:"Ref",id:"ref",level:2},{value:"Semaphore and TSemaphore",id:"semaphore-and-tsemaphore",level:2},{value:"Queue",id:"queue",level:2},{value:"ZIO Test",id:"zio-test",level:2},{value:"ZSpec",id:"zspec",level:3},{value:"Sharing Layers between Specs",id:"sharing-layers-between-specs",level:3},{value:"Smart Constructors",id:"smart-constructors",level:3},{value:"Unification of <code>Assertion</code> and <code>AssertionM</code>",id:"unification-of-assertion-and-assertionm",level:3},{value:"Smart Assertion",id:"smart-assertion",level:3},{value:"Compositional Specs",id:"compositional-specs",level:3},{value:"ZIO Streams",id:"zio-streams",level:2},{value:"ZIO Schedules",id:"zio-schedules",level:2},{value:"ZIO Services",id:"zio-services",level:2},{value:"Blocking Service",id:"blocking-service",level:3},{value:"Clock Service",id:"clock-service",level:3},{value:"Console Service",id:"console-service",level:3},{value:"Other New Features",id:"other-new-features",level:2},{value:"Smart Constructors",id:"smart-constructors-1",level:3},{value:"ZState",id:"zstate",level:3},{value:"Hub",id:"hub",level:3},{value:"ZIO Aspects",id:"zio-aspects",level:3},{value:"Debugging",id:"debugging",level:3},{value:"Logging",id:"logging",level:3},{value:"Compile-time Execution Tracing",id:"compile-time-execution-tracing",level:3}],s={toc:d},m="wrapper";function c(e){let{components:t,...r}=e;return(0,i.kt)(m,(0,a.Z)({},s,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In this guide we want to introduce the migration process to ZIO 2.x. So if you have a project written in ZIO 1.x and want to migrate that to ZIO 2.x, this article is for you. "),(0,i.kt)("h2",{id:"automatic-migration"},"Automatic Migration"),(0,i.kt)("p",null,"Before you migrate your own codebase, confirm that all of your ZIO-related dependencies have been migrated to ZIO 2.x with our ",(0,i.kt)("a",{parentName:"p",href:"https://zio-ecosystem.herokuapp.com/"},"ZIO Ecosystem Tool"),"."),(0,i.kt)("p",null,"ZIO uses the ",(0,i.kt)("a",{parentName:"p",href:"https://scalacenter.github.io/scalafix/"},"Scalafix")," for automatic migration. Scalafix is a code migration tool that takes a rewrite rule and reads the source code, converting deprecated features to newer ones, and then writing the result back to the source code. "),(0,i.kt)("p",null,"ZIO has a migration rule named ",(0,i.kt)("inlineCode",{parentName:"p"},"Zio2Upgrade")," which migrates a ZIO 1.x code base to ZIO 2.x. This migration rule covers most of the changes. Therefore, to migrate a ZIO project to 2.x, we prefer to apply the ",(0,i.kt)("inlineCode",{parentName:"p"},"Zio2Upgrade")," rule to the existing code. After that, we can go to the source code and fix the remaining compilation issues:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"First, we should ensure that all of our direct and transitive dependencies ",(0,i.kt)("a",{parentName:"p",href:"https://zio-ecosystem.herokuapp.com/"},"have released their compatible versions with ZIO 2.x"),". Note that we shouldn't update our dependencies to the 2.x compatible versions, before running scalafix.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Next, we need to install the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/sbt-scalafix"},"Scalafix SBT Plugin"),", by adding the following line into ",(0,i.kt)("inlineCode",{parentName:"p"},"project/plugins.sbt")," file:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// project/plugins.sbt\naddSbtPlugin("ch.epfl.scala" % "sbt-scalafix" % "<version>")\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"We are ready to apply the migration rule:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'sbt "scalafixEnable; scalafixAll github:zio/zio/Zio2Upgrade?sha=series/2.x" \n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"After running scalafix, it's time to upgrade ZIO dependencies. If we are using one of the following dependencies, we need to bump them into the ",(0,i.kt)("inlineCode",{parentName:"p"},"2.x")," version:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio"         % "2.0.0"\nlibraryDependencies += "dev.zio" %% "zio-streams" % "2.0.0"\nlibraryDependencies += "dev.zio" %% "zio-test"    % "2.0.0"\n')),(0,i.kt)("p",{parentName:"li"},"Other than ZIO, we should upgrade all other (official or community) ZIO libraries we are using in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Now, we have performed most of the migration. Finally, we should fix the remaining compilation errors with the help of the remaining sections in this article."))),(0,i.kt)("h2",{id:"guidelines-for-library-authors"},"Guidelines for Library Authors"),(0,i.kt)("p",null,"As a contributor to ZIO ecosystem libraries, we also should cover these guidelines:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"We should add ",(0,i.kt)("em",{parentName:"li"},"implicit trace parameter")," to all our codebase, this prevents the guts of our library from messing up the user's execution trace. ")),(0,i.kt)("p",null,"Let's see an example of that in the ZIO source code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"trait ZIO[-R, +E, +A] {\n-  def map[B](f: A => B): ZIO[R, E, B] =\n     flatMap(a => ZIO.succeed(f(a)))\n+  def map[B](f: A => B)(implicit trace: Trace): ZIO[R, E, B] = \n     flatMap(a => ZIO.succeed(f(a)))\n}\n")),(0,i.kt)("p",null,"Assume we have written the ",(0,i.kt)("inlineCode",{parentName:"p"},"FooLibrary")," as below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject FooLibrary {\n  def foo = bar.flatMap(x => ZIO.succeed(x * 2))  // line 4\n  private def bar = baz.flatMap(x => ZIO.succeed(x * x))  // line 5\n  private def baz = ZIO.fail("Oh uh!").as(5)              // line 6\n}\n')),(0,i.kt)("p",null,"Without ",(0,i.kt)("em",{parentName:"p"},"implicit trace parameter"),", the user of our library will get so many unrelated stack trace messages:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = FooLibrary.foo\n}\n")),(0,i.kt)("p",null,"To avoid messing up our user's execution trace, we should add implicit trace parameters to our methods:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject FooLibrary {\n  def foo(implicit trace: Trace) = bar.flatMap(x => ZIO.succeed(x * 2))\n  private def bar(implicit trace: Trace) = baz.flatMap(x => ZIO.succeed(x * x))\n  private def baz(implicit trace: Trace) = ZIO.fail("Oh uh!").as(5)\n}\n\nobject MainApp extends ZIOAppDefault {\n  def run = FooLibrary.foo // line 10\n}\n')),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"All parameters to operators returning an effect ",(0,i.kt)("a",{parentName:"p",href:"#lazy-evaluation-of-parameters"},"should be by-name"),". Also, we should be sure to capture any parameters that are referenced more than once as values suspended in a ZIO constructor such as ",(0,i.kt)("inlineCode",{parentName:"p"},"suspendSucceed")," to prevent ",(0,i.kt)("em",{parentName:"p"},"double evaluation"),". "),(0,i.kt)("p",{parentName:"li"},"The overall pattern in implementing such methods will be:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"- def foreachParN[A](n: Int)(a: Iterable[A]) = {\n    ... // The function body\n- }\n+ def foreachParN[A](n0: => Int)(a0: => Iterable[A]) = \n+   ZIO.suspendSucceed {\n+     val n = n0 \n+     val a = a0\n      ... // The function body\n+   }\n")),(0,i.kt)("p",{parentName:"li"},"As a result, the code will be robust to ",(0,i.kt)("em",{parentName:"p"},"double evaluation")," as well as to ",(0,i.kt)("em",{parentName:"p"},"side-effects embedded within parameters"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"We should update names to match ",(0,i.kt)("a",{parentName:"p",href:"#zio-20-naming-conventions"},"ZIO 2.0 naming conventions"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"ZIO 2.0 introduced ",(0,i.kt)("a",{parentName:"p",href:"#compositional-concurrency"},"new structured concurrently operators")," which helps us to change the regional parallelism settings of our application. So if applicable, we should use these operators instead of the old parallel operators.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"If we are exposing ",(0,i.kt)("a",{parentName:"p",href:"#unsafe-marker"},"unsafe operators")," in one of our interfaces we should use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Unsafe")," data type to indicate this. By convention we define these operators in an ",(0,i.kt)("inlineCode",{parentName:"p"},"UnsafeAPI")," trait in our interface that can be accessed using as ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," operator."))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"trait MyInterface {\n-  def unsafeDoSomething(): Unit\n+  def unsafe: UnsafeAPI\n+\n+  trait UnsafeAPI {\n+    def doSomething()(implicit unsafe: Unsafe): Unit\n+  }\n}\n")),(0,i.kt)("h2",{id:"deletion-of-type-alias-companion-objects"},"Deletion of Type Alias Companion Objects"),(0,i.kt)("p",null,"In ZIO 1.x, using the type aliases as objects created another way to do things and potentially led to confusion about whether these were the same or somehow different with little benefit."),(0,i.kt)("p",null,"In ZIO 2.x, we removed companion objects for type aliases. We still can use type aliases such as ",(0,i.kt)("inlineCode",{parentName:"p"},"UIO[Int]"),", but we couldn't do ",(0,i.kt)("inlineCode",{parentName:"p"},"UIO.succeed(1)")," anymore:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"- val effect: UIO[Int] = UIO.succeed(1)\n+ val effect: UIO[Int] = Exit.succeed(1)\n\n// another examp:\n- val stream: UStream[Int] = UStream.succeed(1)\n+ val stream: UStream[Int] = ZStream.succeed(1)\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"#automatic-migration"},"migration script")," will automatically convert all the usages of type aliases to the corresponding objects."),(0,i.kt)("h2",{id:"deletion-of-has-data-type"},"Deletion of Has Data Type"),(0,i.kt)("p",null,"The Has data type, which was used for combining services, was removed. Therefore, we no longer need to wrap services in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Has")," data type."),(0,i.kt)("p",null,"For example, in ZIO 1.x, the following layer denotes this layer requires ",(0,i.kt)("inlineCode",{parentName:"p"},"Logging"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Random"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Database")," and produce the ",(0,i.kt)("inlineCode",{parentName:"p"},"UserRepo"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val userRepo: ZLayer[Has[Logging] with Has[Random] with Has[Database], Throwable, Has[UserRepo]] = ???\n")),(0,i.kt)("p",null,"In ZIO 2.x, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Has")," has been removed and simplified for better ergonomics:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val userRepo: ZLayer[Logging with Random with Database, Throwable, UserRepo] = ???\n")),(0,i.kt)("p",null,"Also in ZIO 2.x instead of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Has")," data type, a type-level map called ",(0,i.kt)("inlineCode",{parentName:"p"},"ZEnvironment")," has been built into ZIO. Let's see how this changes the way we can provide a service to the environment."),(0,i.kt)("p",null,"Using the following code snippet, we demonstrate how we used to access and provide instances of ",(0,i.kt)("inlineCode",{parentName:"p"},"Config")," service to the application environment using ZIO 1.x:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// ZIO 1.x\nimport zio._\n\ncase class Config(url: String, port: Int)\n\nobject ConfigExample extends zio.App {\n\n  val app: ZIO[Has[console.Console.Service] with Has[Config], Nothing, Unit] = for {\n    config <- ZIO.service[Config]\n    _      <- console.putStrLn(s"application config: $config").orDie\n  } yield ()\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] = {\n\n    app.provideSome[Has[console.Console.Service]](_ ++ Has(Config("localhost", 8080))).exitCode\n  }\n}\n')),(0,i.kt)("p",null,"To migrate this snippet to ZIO 2.x, we need to remove all the ",(0,i.kt)("inlineCode",{parentName:"p"},"Has")," service wrappers, and finally, we will use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#provideSomeEnvironment")," method to append the ",(0,i.kt)("inlineCode",{parentName:"p"},"Config")," instance to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZEnvironment"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// ZIO 2.x\nimport zio._\n\ncase class Config(url: String, port: Int)\n\nobject ConfigExample extends ZIOAppDefault {\n  val app: ZIO[Config, Nothing, Unit] = for {\n    config <- ZIO.service[Config]\n    _      <- Console.printLine(s"application config: $config").orDie\n  } yield ()\n    \n  def run = \n    app.provideEnvironment(ZEnvironment(Config("localhost", 8080)))\n}\n')),(0,i.kt)("p",null,"Note that in ZIO 2.x, default services (e.g ",(0,i.kt)("inlineCode",{parentName:"p"},"Console"),") are eliminated from the environment."),(0,i.kt)("h2",{id:"zio"},"ZIO"),(0,i.kt)("h3",{id:"removed-methods"},"Removed Methods"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Arrow Combinators")," \u2014 (",(0,i.kt)("inlineCode",{parentName:"p"},"+++"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"|||"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"onSecond"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"onFirst"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"second"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"first"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"onRight"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"onLeft"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"andThen"),", ",(0,i.kt)("inlineCode",{parentName:"p"},">>>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"compose"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"<<<"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"identity"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"swap"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"join"),")"),(0,i.kt)("p",null,"In ZIO 2.0, all arrow combinators are removed, and we need to use alternatives like doing monadic for-comprehension style ",(0,i.kt)("inlineCode",{parentName:"p"},"flatMap")," with combinators like ",(0,i.kt)("inlineCode",{parentName:"p"},"provide"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"zip"),", and so on."),(0,i.kt)("h3",{id:"zio-20-naming-conventions"},"ZIO 2.0 Naming Conventions"),(0,i.kt)("p",null,"In ZIO 2.0, the name of constructors and operators becomes more ergonomic and simple. They reflect more about their purpose rather than just using idiomatic jargon of category theory or functional terms in functional programming with Haskell."),(0,i.kt)("p",null,"Here are some of the most important changes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Multiple ways of doing the same thing are removed")," \u2014 For example:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Both ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.succeed")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.effectTotal")," do the same thing. So in ZIO 2.0 we just have one version of these constructors which is ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.succeed"),"."),(0,i.kt)("li",{parentName:"ul"},"The bind operator ",(0,i.kt)("inlineCode",{parentName:"li"},">>=")," is removed. So we just have one way to flatMap which is the ",(0,i.kt)("inlineCode",{parentName:"li"},"flatMap")," method. Therefore, the ",(0,i.kt)("inlineCode",{parentName:"li"},">>=")," method doesn't surprise the non-Haskellers."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO#get")," method was essentially a more constrained version of ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO#some"),". So the ",(0,i.kt)("inlineCode",{parentName:"li"},"get")," method is deprecated."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"ZIO.attempt")," instead of ",(0,i.kt)("inlineCode",{parentName:"strong"},"ZIO.effect"))," \u2014 In ZIO 2.0 all ZIO constructors like ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.effect*")," that create a ZIO from a side effect are deprecated and renamed to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.attempt*")," version. For example, when we are reading from a file, it's more meaningful to say we are attempting to read from a file instead of saying we have an effect of reading from a file.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"ZIO")," instead of the ",(0,i.kt)("inlineCode",{parentName:"strong"},"M")," suffix")," \u2014 In effectful operations, the ",(0,i.kt)("inlineCode",{parentName:"p"},"M")," suffix is renamed to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," suffix. In ZIO 1.x, the ",(0,i.kt)("inlineCode",{parentName:"p"},"M")," suffix in an effectful operation means that the operation works with monad in a monadic context. This naming convention is the legacy of Haskell jargon. In ZIO 2.x, all these suffixes are renamed to ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO"),". For example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ifM")," operator is renamed to ",(0,i.kt)("inlineCode",{parentName:"p"},"ifZIO"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"Discard")," instead of the underscore ",(0,i.kt)("inlineCode",{parentName:"strong"},"_")," suffix")," \u2014 The underscore suffix is another legacy naming convention from Haskell's world. In ZIO 1.x, the underscore suffix means we are going to discard the result. The underscore version works exactly like the one without the underscore, but it discards the result and returns ",(0,i.kt)("inlineCode",{parentName:"p"},"Unit")," in the ZIO context. For example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"collectAll_")," operator renamed to ",(0,i.kt)("inlineCode",{parentName:"p"},"collectAllDiscard"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"as"),", ",(0,i.kt)("inlineCode",{parentName:"strong"},"to"),", ",(0,i.kt)("inlineCode",{parentName:"strong"},"into")," prefixes")," \u2014 The ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#to")," is renamed to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#intoPromise"),". So now we have three categories of conversion:"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"as")," \u2014 The ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO#as")," method and its variants like ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO#asSome"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO#asSomeError")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO#asService")," are used when transforming the ",(0,i.kt)("inlineCode",{parentName:"li"},"A")," inside of a ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO"),", generally as shortcuts for ",(0,i.kt)("inlineCode",{parentName:"li"},"map(aToFoo(_))"),"."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"to")," \u2014 The ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO#to")," method and its variants like ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO#toFuture")," are used when the ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO")," is transformed into something else other than the ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO")," data-type."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"into")," \u2014 All ",(0,i.kt)("inlineCode",{parentName:"li"},"into*")," methods, accept secondary data-type, modify it with the result of the current effect (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO#intoPromise"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ZStream#intoHub"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"ZStream#intoQueue"),")")))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#>>=")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#flatMap"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#bimap")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#mapBoth"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#mapEffect")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#mapAttempt"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#filterOrElse_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#filterOrElse"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#foldCauseM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#foldCauseZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#foldM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#foldZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#foldTraceM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#foldTraceZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#get")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#some"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#optional")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#unsome"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#someOrElseM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#someOrElseZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.forkAll_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.forkAllDiscard"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#forkInternal")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#fork"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#forkOn")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#onExecutionContext(ec).fork"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.fromFiberM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.fromFiberZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.require")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.someOrFail"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#on")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#onExecutionContext"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#rejectM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#rejectZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#run")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#exit"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#timeoutHalt")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#timeoutFailCause"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#to")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#intoPromise"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.access")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.environmentWith"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.accessM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.environmentWithZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.fromFunction")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.environmentWith"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.fromFunctionM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.environmentWithZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.services")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.service"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.bracket")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.acquireReleaseWith"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.bracketExit")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.acquireReleaseExitWith"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.bracketAuto")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.acquireReleaseWithAuto"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#bracket")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#acquireReleaseWith"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#bracket_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#acquireRelease"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#bracketExit")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#acquireReleaseExitWith"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#bracketExit")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#acquireReleaseExitWith"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#bracketOnError")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#acquireReleaseOnErrorWith"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.collectAll_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.collectAllDiscard"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.collectAllPar_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.collectAllParDiscard"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.collectAllParN_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.collectAllParNDiscard"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#collectM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#collectZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.effect")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.attempt"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.effectAsync")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.async"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.effectAsyncInterrupt")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.asyncInterrupt"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.effectAsyncM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.asyncZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.effectAsyncMaybe")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.asyncMaybe"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.effectBlocking")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlocking"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.effectBlockingCancelable")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlockingCancelable"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.effectBlockingIO")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlockingIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.effectBlockingInterrupt")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlockingInterrupt"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.effectSuspend")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.suspend"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.effectSuspendTotal")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.suspendSucceed"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.effectTotal")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.succeed"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.foreach_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.foreachDiscard"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.foreachPar_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.foreachParDiscard"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.foreachParN_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.foreachParNDiscard"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#replicateM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#replicateZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#replicateM_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#replicateZIODiscard"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.halt")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.failCause"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.haltWith")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.failCauseWith"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.ifM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.ifZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.loop_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.loopDiscard"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.whenCaseM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.whenCaseZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.whenM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.whenZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.unlessM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.unlessZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#unlessM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#unlessZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#whenM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#whenZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#repeatUntilM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#repeatUntilZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#repeatWhileM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#repeatWhileZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#retryUntilM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#retryUntilZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#retryWhileM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#retryWhileZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.replicateM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.replicateZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.replicateM_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.replicateZIODiscard"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.validate_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.validateDiscard"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.validatePar_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.validateParDiscard"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.tapCause")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.tapErrorCause"))))),(0,i.kt)("h3",{id:"lazy-evaluation-of-parameters"},"Lazy Evaluation of Parameters"),(0,i.kt)("p",null,"In ZIO 2.x, we changed the signature of those functions that return effects to use ",(0,i.kt)("em",{parentName:"p"},"by-name parameters"),". And we also encourage library authors to do the same for any functions that return effects."),(0,i.kt)("p",null,"Our motivation for this change was a common mistake among new users of ZIO, which they ",(0,i.kt)("em",{parentName:"p"},"accidentally embed raw effects")," inside the function they pass to ZIO constructors and operators. This mistake may produce some unwanted behaviors."),(0,i.kt)("p",null,"Let's see an example of this anti-pattern in ZIO 1.x:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"ZIO.bracket({\n  val random = scala.util.Random.nextInt()\n  ZIO.succeed(random)\n})(_ => ZIO.unit)(x => console.putStrLn(x.toString)).repeatN(2)\n")),(0,i.kt)("p",null,"The newbie user expects that this program prints 3 different random numbers, while the output would be something as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"1085597917\n1085597917\n1085597917\n")),(0,i.kt)("p",null,"This is because the user incorrectly introduced a raw effect into the ",(0,i.kt)("inlineCode",{parentName:"p"},"acquire")," parameter of ",(0,i.kt)("inlineCode",{parentName:"p"},"bracket")," operation. As the ",(0,i.kt)("inlineCode",{parentName:"p"},"acquire")," is ",(0,i.kt)("em",{parentName:"p"},"by-value parameter"),", the value passed to the function evaluated ",(0,i.kt)("em",{parentName:"p"},"eagerly"),", only once:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def bracket[R, E, A](acquire: ZIO[R, E, A]): ZIO.BracketAcquire[R, E, A]\n")),(0,i.kt)("p",null,"If we make the ",(0,i.kt)("inlineCode",{parentName:"p"},"acquire")," to ",(0,i.kt)("em",{parentName:"p"},"by-name parameter"),", we can prevent these mistakes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"- def bracket[R, E, A](acquire: ZIO[R, E, A]): ZIO.BracketAcquire[R, E, A]\n+ def bracket[R, E, A](acquire: => ZIO[R, E, A]): ZIO.BracketAcquire[R, E, A]\n")),(0,i.kt)("p",null,"So, in ZIO 2.x if we accidentally introduce an effect to the ZIO parameters, the lazy parameter prevents the program from producing undesired behaviors:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// Note that in ZIO 2.x, the `bracket` is deprecated and renamed to the `acquireReleaseWith`. In this example to prevent the consistency of our example, we used the `bracket`.\n\nZIO.bracket({\n  val random = scala.util.Random.nextInt()\n  ZIO.succeed(random)\n})(_ => ZIO.unit)(x => console.putStrLn(x.toString)).repeatN(2)\n")),(0,i.kt)("p",null,"The output would be something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"355191016\n2046799548\n333146616\n")),(0,i.kt)("h3",{id:"composable-zips"},"Composable Zips"),(0,i.kt)("p",null,"In ZIO 2.x, when we are zipping together different effects:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Tuple"),"s are not nested."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Unit"),"s do not contribute to the output.")),(0,i.kt)("p",null,"Assume we have these effects:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val x1: UIO[Int]     = ZIO.succeed(???)\nval x2: UIO[Unit]    = ZIO.succeed(???)\nval x3: UIO[String]  = ZIO.succeed(???)\nval x4: UIO[Boolean] = ZIO.succeed(???)\n")),(0,i.kt)("p",null,"In ZIO 1.x, the output of zipping together these effects are nested:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val zipped = x1 <*> x2 <*> x3 <*> x4\n")),(0,i.kt)("p",null,"While in ZIO 2.x, we have more ergonomics result type and also the ",(0,i.kt)("inlineCode",{parentName:"p"},"Unit")," data-type doesn't contribute to the output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val zipped = x1 <*> x2 <*> x3 <*> x4\n")),(0,i.kt)("p",null,"This change is not only for the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," data type but also for all other data types like ",(0,i.kt)("inlineCode",{parentName:"p"},"ZStream"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ZSTM"),", etc."),(0,i.kt)("p",null,"As we have compositional zips, we no longer need higher arity zips in ZIO 1.x like ",(0,i.kt)("inlineCode",{parentName:"p"},"mapN"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"mapParN"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Gen#zipN"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Gen#crossN"),". They are deprecated in ZIO 2.x."),(0,i.kt)("p",null,"Here is the list of ",(0,i.kt)("inlineCode",{parentName:"p"},"zip")," variants that are deprecated:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#&&&")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#zip"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.tupled")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.zip"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.tupledPar")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.zipPar"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.mapN")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.zip"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.mapParN")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.zipPar"))))),(0,i.kt)("h3",{id:"compositional-concurrency"},"Compositional Concurrency"),(0,i.kt)("p",null,"We introduced two operations that modify the parallel factor of a concurrent ZIO effect, ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#withParallelism")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#withParallelismUnbounded"),". This makes the maximum number of fibers for parallel operators as a regional setting. Therefore, all parallelism operators ending in ",(0,i.kt)("inlineCode",{parentName:"p"},"N"),", such as ",(0,i.kt)("inlineCode",{parentName:"p"},"foreachParN")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"collectAllParN"),", have been deprecated:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"foreachParN")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"foreachPar"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"foreachParN_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"foreachParDiscard"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"collectAllParN")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"collectAllPar"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"collectAllParN_")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"collectAllParDiscard"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"collectAllWithParN")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"collectAllWithPar"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"collectAllSuccessesParN")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"collectAllSuccessesPar"))))),(0,i.kt)("p",null,"Having separate methods for changing the parallelism factor of a parallel effect deprecates lots of extra operators and makes concurrency more compositional."),(0,i.kt)("p",null,"So instead of writing a parallel task like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"ZIO.foreachParN(8)(urls)(download)\n")),(0,i.kt)("p",null,"We should use the ",(0,i.kt)("inlineCode",{parentName:"p"},"withParallelism")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"ZIO.foreachPar(urls)(download).withParallelism(8)\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"withParallelismUnbounded")," method is useful when we want to run a parallel effect with an unbounded maximum number of fibers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"ZIO.foreachPar(urls)(download).withParallelismUnbounded\n")),(0,i.kt)("h3",{id:"either-values"},"Either Values"),(0,i.kt)("p",null,"In ZIO 1.x, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#left")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#right")," operators are lossy, and they don't preserve the information on the other side of ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," after the transformation."),(0,i.kt)("p",null,"For example, assume we have an effect of type ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO[Any, Throwable, Left[Int, String]]"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val effect         = Task.effect(Left[Int, String](5))\n// effect: ZIO[Any, Throwable, Left[Int, String]]\nval leftProjection = effect.left\n// leftProjection: ZIO[Any, Option[Throwable], Int]\n")),(0,i.kt)("p",null,"The error channel of ",(0,i.kt)("inlineCode",{parentName:"p"},"leftProjection")," doesn't contain type information of the other side of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Left[Int, String]"),", which is ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),". So after projecting to the left, we can not go back to the original effect."),(0,i.kt)("p",null,"In ZIO 2.x, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#left")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#right"),", contains all type information so then we can ",(0,i.kt)("inlineCode",{parentName:"p"},"unleft")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"unright")," to inverse that projection:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val effect         = ZIO.attempt(Left[Int, String](5))\nval leftProjection = effect.left\nval unlefted       = leftProjection.map(_ * 2).unleft\n")),(0,i.kt)("p",null,"So the error channel of the output of ",(0,i.kt)("inlineCode",{parentName:"p"},"left")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"right")," operators is changed from ",(0,i.kt)("inlineCode",{parentName:"p"},"Option")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),"."),(0,i.kt)("h3",{id:"descriptive-errors"},"Descriptive Errors"),(0,i.kt)("p",null,"ZIO's type system uses implicit evidence to ensure type safety, and some level of correctness at compile time. In ZIO 2.x, the ",(0,i.kt)("em",{parentName:"p"},"subtype evidence"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"<:<")," replaced by these two descriptive implicit evidences:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"IsSubtypeOfOutput"))," \u2014 The ",(0,i.kt)("inlineCode",{parentName:"p"},"O1 IsSubtypeOfOutput O2")," ensures that the output type ",(0,i.kt)("inlineCode",{parentName:"p"},"O1")," is subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"O2"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"IsSubtypeOfError"))," \u2014 The ",(0,i.kt)("inlineCode",{parentName:"p"},"E1 IsSubtypeOfError E2")," ensures that the error type ",(0,i.kt)("inlineCode",{parentName:"p"},"E1")," is a subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"E2")))),(0,i.kt)("p",null,"Now we have more descriptive errors at compile time in the vast majority of operators."),(0,i.kt)("p",null,"Let's just see an example of each one. In ZIO 1.x, the compiler print obscurant error messages:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.fail("Boom!").orDie\n// error: Cannot prove that String <:< Throwable.\n// ZIO.fail("Boom!").orDie\n// ^^^^^^^^^^^^^^^^^^^^^^^\n\nZIO.succeed(Set(3,4)).head\n// error: Cannot prove that scala.collection.immutable.Set[Int] <:< List[B].\n// ZIO.succeed(Set(3, 4)).head\n// ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n')),(0,i.kt)("p",null,"Now in ZIO 2.x we have such informative error messages:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.fail("Boom!").orDie\n// error: This operator requires that the error type be a subtype of Throwable but the actual type was String.\n// ZIO.fail("Boom!").orDie\n// ^^^^^^^^^^^^^^^^^^^^^^^\n\nZIO.succeed(Set(3, 4, 3)).head\n// error: This operator requires that the output type be a subtype of List[B] but the actual type was scala.collection.immutable.Set[Int].\n// ZIO.succeed(Set(3, 4, 3)).head\n// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n')),(0,i.kt)("h2",{id:"elimination-of-default-services-from-the-zio-environment"},"Elimination of Default Services From The ZIO Environment"),(0,i.kt)("p",null,"In ZIO 1.x we used default ZIO services such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Clock"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Console"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Random"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"System")," along with the service pattern. So each time we used one of these services by obtaining them from the environment, the requirement of our effect becomes bigger and bigger. Finally, at the end of the world, we had two options, one was to use the default implementation of these services, and the other one was to use our own implementations."),(0,i.kt)("p",null,"For example, in ZIO 1.x, we have the following boilerplate code to print random numbers every second. The environment type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"myApp")," effect is ",(0,i.kt)("inlineCode",{parentName:"p"},"Console with Clock with Random"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.clock.Clock\nimport zio.duration.durationInt\nimport zio.random.Random\nimport java.io.IOException\nimport zio.console._\n\nobject MainApp extends App {\n  val myApp: ZIO[Clock with Console with Random, IOException, Unit] =\n    for {\n      rnd <- random.nextIntBounded(100)\n      _   <- console.putStrLn(s"Random number: $rnd")\n      _   <- clock.sleep(1.second)\n    } yield ()\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.forever.exitCode  \n    // or we can provide our own implementation \n    // myApp.forever.provideLayer(Console.live ++ Clock.live ++ Random.live).exitCode\n}\n')),(0,i.kt)("p",null,"But these services did not fit well with the ",(0,i.kt)("em",{parentName:"p"},"service pattern")," because they were too low level and users frequently used them directly in their code to use the default implementation out of the box. So in most cases, users were not meant to provide their own implementation of these services. In another hand, as they are low level, they are used very often, so they pollute the environment type of the effect. They are too small to be used with the ",(0,i.kt)("em",{parentName:"p"},"service pattern"),"."),(0,i.kt)("p",null,"To improve on this, in ZIO 2.x, we deleted default services from the environment, instead, we built these services into the ZIO Runtime. So these services can still be modified and testable. In ZIO 2.x we encourage using the environment for higher-level services."),(0,i.kt)("p",null,"Therefore, the previous example In ZIO 2.x can be rewritten very simply as below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nimport java.io.IOException\n\nobject MainApp extends App {\n  val myApp: ZIO[Any, IOException, Unit] =\n    for {\n      rnd <- Random.nextIntBounded(100)\n      _   <- Console.printLine(s"Random number: $rnd")\n      _   <- Clock.sleep(1.second)\n    } yield ()\n\n  def run = myApp.forever\n}\n')),(0,i.kt)("p",null,"In nutshell, to migrate from ZIO 1.x to ZIO 2.x, we need follow these steps:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"We aren't required to obtain default services from the environment using functions like ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.service[Console]"),", instead we should obtain the ",(0,i.kt)("inlineCode",{parentName:"li"},"Console")," service using ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.console"),". So there is no need to access these services from the environment anymore, they are built into the ZIO Runtime. If we want to access them, we can use these functions instead:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.console"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.consoleWith")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.clock"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.clockWith")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.random"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.randomWith")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.system"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.systemWith"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"for {\n-  random <- ZIO.service[Random]\n+  random <- ZIO.random\n} yield ()\n")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"By removing these services from the environment, all usage of ",(0,i.kt)("inlineCode",{parentName:"li"},"ZEnv"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Console"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Clock"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Random"),", or ",(0,i.kt)("inlineCode",{parentName:"li"},"System")," in the environment type of ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ZStream")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"ZLayer")," should be generally deleted:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"- val myApp: ZIO[Clock with Console with Random with UserRepo with Logging, IOException, Unit] = ???\n+ val myApp: ZIO[UserRepo with Logging, IOException, Unit] = ???\n")),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},"If we want to use the live version in tests we can use these test aspects instead of providing them as layers:\n",(0,i.kt)("inlineCode",{parentName:"li"},"withLiveClock"),(0,i.kt)("inlineCode",{parentName:"li"},"withLiveConsole"),(0,i.kt)("inlineCode",{parentName:"li"},"withLiveRandom"),(0,i.kt)("inlineCode",{parentName:"li"},"withLiveSystem"),(0,i.kt)("inlineCode",{parentName:"li"},"withLiveEnvironment"))),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},'- testM("TestLiveClock") { ... }.provideLayer(Clock.live)\n+ test("TestLiveClock") { ... } @@ withLiveClock\n')),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},"In ZIO 1.x, whenever we wanted to provide our own versions of ZIO default services, we could do that using one of the ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO#provide*")," operators. In ZIO 2.x if we need to modify the implementation of one of these services on a more fine-grained basis we can use of the following combinators:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.withConsole"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.withConsoleScoped")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.withClock"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.withClockScoped")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.withRandom"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.withRandomScoped")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.withSystem"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.withSystemScoped"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MyClockLive extends Clock {\n  ... \n}\n\nZIO.withClock(MyClockLive)(effect)\n")),(0,i.kt)("ol",{start:5},(0,i.kt)("li",{parentName:"ol"},"According to the removal of default services from the ZIO environment we no longer need layers defined in the ZIO library which produce default ZIO services. So all these layers were removed, such as the following layers:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Console.live"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Clock.any")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Clock.live"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Clock.javaClock"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Clock.any")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Random.live"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Random.scalaRandom"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Random.any")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"System.live"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"System.any"))),(0,i.kt)("ol",{start:6},(0,i.kt)("li",{parentName:"ol"},"In ZIO some services have an alternative implementation rather than the default one. In ZIO 1.x, the default implementation of these services was provided by the environment. So when we wanted to use the default implementation, we didn't have to provide them explicitly at the end of the world. But in case we wanted to use an alternative implementation, we had to provide them explicitly. For example, to use the java implementation of ",(0,i.kt)("inlineCode",{parentName:"li"},"Clock"),", we had to provide the ",(0,i.kt)("inlineCode",{parentName:"li"},"Clock.javaClock")," layer:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.clock.Clock\n\nobject MainApp extends App {\n  def run(args: List[String]) =\n    clock.localDateTime\n      .debug("local date time")\n      .provideCustomLayer(\n        ZLayer.succeed(\n          java.time.Clock.systemDefaultZone()\n        ) >>> Clock.javaClock\n      )\n      .orDie\n      .exitCode\n}\n')),(0,i.kt)("p",null,"By removal of default services from the environment, their corresponding layers were removed. So we should call them directly as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    Clock.ClockJava(java.time.Clock.systemDefaultZone())\n      .currentDateTime\n      .debug("current date time")\n}\n')),(0,i.kt)("p",null,"The same approach applies to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Random")," service:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.x (ZLayer)"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Clock.javaClock")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Clock.ClockJava"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Random.scalaRandom")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Random.RandomScala"))))),(0,i.kt)("ol",{start:7},(0,i.kt)("li",{parentName:"ol"},"In ZIO 1.x, the ",(0,i.kt)("inlineCode",{parentName:"li"},"ZEnv")," was the type alias for all default services used in the ZIO environment. In ZIO 2.x, as the default services were removed from the environment, the ",(0,i.kt)("inlineCode",{parentName:"li"},"ZEnv")," type alias was removed. And we have the ",(0,i.kt)("inlineCode",{parentName:"li"},"DefaultServices.live")," to access the live implementation of default services.")),(0,i.kt)("h2",{id:"zio-app"},"ZIO App"),(0,i.kt)("h3",{id:"zioapp"},"ZIOApp"),(0,i.kt)("p",null,"In ZIO 1.x, we were used to writing ZIO applications using the ",(0,i.kt)("inlineCode",{parentName:"p"},"zio.App")," trait:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.App\nimport zio.Console._\n\nobject MyApp extends zio.App {\n  def run(args: List[String]) = \n    startMyApp(args).exitCode\n}\n")),(0,i.kt)("p",null,"Now in ZIO 2.x, the ",(0,i.kt)("inlineCode",{parentName:"p"},"zio.App")," trait is deprecated and, we have the ",(0,i.kt)("inlineCode",{parentName:"p"},"zio.ZIOAppDefault")," trait which is simpler than the former approach (Note that the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZApp")," is also deprecated, and we should use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIOAppDefault")," instead):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.ZIOAppDefault\nimport zio.Console._\n\nobject MyApp extends ZIOAppDefault {\n  def run =\n    for {\n      arguments <- getArgs\n      _         <- startMyApp(arguments) \n    } yield ()\n}\n")),(0,i.kt)("p",null,"In ZIO 1.x, ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," is the main function of our application, which will be passed the command-line arguments to our application:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def run(args: List[String]): URIO[R, ExitCode]\n")),(0,i.kt)("p",null,"While in most cases we don't write command-line applications, and we don't use it, in ZIO 2.x, we created the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIOAppArgs")," service and a helper method called ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIOApp#args")," which obtains access to the command-line arguments of our application:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait ZIOApp { self =>\n  final def args: ZIO[ZIOAppArgs, Nothing, Chunk[String]] = ZIO.service[ZIOAppArgs].map(_.args)\n}\n")),(0,i.kt)("h2",{id:"fiber"},"Fiber"),(0,i.kt)("p",null,"We deprecated the ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber.ID")," and moved it to the ",(0,i.kt)("inlineCode",{parentName:"p"},"zio")," package and called it the ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberId"),":"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.0"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.Fiber.ID")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.FiberID"))))),(0,i.kt)("h2",{id:"runtime-platform-and-executor"},"Runtime, Platform and Executor"),(0,i.kt)("h3",{id:"unsafe-marker"},"Unsafe Marker"),(0,i.kt)("p",null,"To run a ZIO workflow, we usually use ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIOAppDefault")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIOApp")," traits. These traits provide the ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," method which will run the workflow using their default ",(0,i.kt)("inlineCode",{parentName:"p"},"Runtime")," system. But when we want to work with a low-level API or want to integrate with a legacy code, we need to unsafely run the workflow."),(0,i.kt)("p",null,"In ZIO 1.x, we used the ",(0,i.kt)("inlineCode",{parentName:"p"},"zio.Runtime.unsafeRun")," method to run a ZIO workflow:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait Runtime[+R] {\n  def unsafeRun[E, A](zio: => ZIO[R, E, A]): A\n}\n")),(0,i.kt)("p",null,"For example, if we wanted to integrate a ZIO workflow with a legacy unsafe code, we used to write something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp {\n  val zioWorkflow: ZIO[Any, Nothing, Int] = ???\n  \n  def legacyApplication(input: Int): Unit = ???\n  \n  def zioApplication: Int = \n    Runtime.default.unsafeRun(zioWorkflow)\n  \n\n  def main(args: Array[String]): Unit = {\n    legacyApplication(zioApplication)\n  }\n\n}\n")),(0,i.kt)("p",null,"In ZIO 2.x, we added the ",(0,i.kt)("inlineCode",{parentName:"p"},"Unsafe")," data type to help developers to differentiate lower-level codes that are not purely functional from the higher-level codes which are always pure, total, and type safe. So the ",(0,i.kt)("inlineCode",{parentName:"p"},"Unsafe")," is just a marker capability to indicate that something is unsafe:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object Unsafe {\n  def unsafe[A](f: Unsafe => A): A = ???\n}\n\ntrait Runtime[+R] { self =>\n  def unsafe: UnsafeAPI\n  \n  trait UnsafeAPI {\n    def run[E, A](zio: ZIO[R, E, A])(implicit trace: Trace, unsafe: Unsafe): Exit[E, A]\n  }\n}\n")),(0,i.kt)("p",null,"So to migrate the previous code to ZIO 2.x, we need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Unsafe")," data type like below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"import zio._\n\nobject MainApp {\n  val zioWorkflow: ZIO[Any, Nothing, Int] = ???\n\n  def legacyApplication(input: Int): Unit = ???\n\n  def zioApplication: Int =\n-    Runtime.default.unsafeRun(zioWorkflow)\n+    Unsafe.unsafe { implicit unsafe =>\n+      Runtime.default.unsafe.run(zioWorkflow).getOrThrowFiberFailure()\n+    }\n\n  def main(args: Array[String]): Unit = {\n    legacyApplication(zioApplication)\n  }\n\n}\n")),(0,i.kt)("p",null,"This way it is easy to distinguish between ",(0,i.kt)("em",{parentName:"p"},"safe")," and ",(0,i.kt)("em",{parentName:"p"},"unsafe")," variants of the same operator. "),(0,i.kt)("p",null,"To run an unsafe operator, we need implicit value of ",(0,i.kt)("inlineCode",{parentName:"p"},"Unsafe")," in scope. This works particularly well in Scala 3 due to its support for implicit function types championed by Martin Odersky. In Scala 3 we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Unsafe.unsafely")," operator to create a block of code in which we can freely call unsafe operators:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'Unsafe.unsafely {\n  Runtime.default.unsafe.run(Console.printLine("Hello, World!"))\n}\n')),(0,i.kt)("p",null,"If we want to support Scala 2 we need to use a slightly more verbose syntax with ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," and a lambda that takes an implicit value of ",(0,i.kt)("inlineCode",{parentName:"p"},"Unsafe"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nUnsafe.unsafe { implicit unsafe =>\n  Runtime.default.unsafe.run(Console.printLine("Hello, World!"))\n}\n')),(0,i.kt)("p",null,"In summary, here are the rules for migrating from ZIO 1.x to ZIO 2.x corresponding to the unsafe operators:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null}),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.0"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Scala 2"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"runtime.unsafeRun(x)")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Unsafe.unsafe { implicit unsafe => runtime.unsafe.run(x).getOrThrowFiberFailure() }"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Scala 3"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"runtime.unsafeRun(x)")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Unsafe.unsafely { runtime.unsafe.run(x).getOrThrowFiberFailure() }"))))),(0,i.kt)("h3",{id:"unsafe-variants"},"Unsafe Variants"),(0,i.kt)("p",null,"In ZIO 1.x, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Runtime")," had several methods for running ZIO workflows unsafely:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait Runtime[+R] {\n  def unsafeRun[E, A](zio: => ZIO[R, E, A]): A\n  def unsafeRunTask[A](task: => RIO[R, A]): A\n  def unsafeRunSync[E, A](zio: => ZIO[R, E, A]): Exit[E, A]\n  def unsafeRunAsync[E, A](zio: => ZIO[R, E, A])(k: Exit[E, A] => Any): Unit\n  def unsafeRunAsyncCancelable[E, A](zio: => ZIO[R, E, A])(k: Exit[E, A] => Any): Fiber.Id => Exit[E, A]\n  def unsafeRunAsync_[E, A](zio: ZIO[R, E, A]): Unit\n  def unsafeRunToFuture[E <: Throwable, A](zio: ZIO[R, E, A]): CancelableFuture[A]\n}\n")),(0,i.kt)("p",null,"We can group these unsafe methods into two categories: synchronous and asynchronous. The synchronous operators are the ones that are used when we want to wait for the result of the workflow to be available. The asynchronous operators are used when we want to execute the workflow asynchronously by providing a callback function that will be called when the workflow is completed."),(0,i.kt)("p",null,"In the previous section, we described the new ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," method inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," object of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Runtime")," trait. We can use this method to unsafely run workflows synchronously. There is another method, called ",(0,i.kt)("inlineCode",{parentName:"p"},"fork"),", that can be used to unsafely run workflows asynchronously:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait Runtime {\n  def unsafe: UnsafeAPI\n  \n  trait UnsafeAPI {\n    def run[E, A](zio: ZIO[R, E, A])(implicit unsafe: Unsafe): Exit[E, A]\n\n    def fork[E, A](zio: ZIO[R, E, A])(implicit unsafe: Unsafe): Fiber.Runtime[E, A]\n  }\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"fork")," method returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber.Runtime")," that can be used to control the execution of the workflow. We have added a new ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," object to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber.Runtime")," class that has several unsafe methods including the ",(0,i.kt)("inlineCode",{parentName:"p"},"addObserver"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object Fiber {\n  sealed abstract class Runtime[+E, +A] extends Fiber[E, A] {\n    def unsafe: UnsafeAPI\n\n    trait UnsafeAPI {\n      def addObserver(observer: Exit[E, A] => Unit)(implicit unsafe: Unsafe): Unit\n    }\n  }\n}\n")),(0,i.kt)("p",null,"Using the ",(0,i.kt)("inlineCode",{parentName:"p"},"addObserver")," method, we can add a callback function of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Exit[E, A] => Unit")," to the underlying fiber. This callback function will be called when the fiber completes. Using these new functionalities, we can implement asynchronous unsafe operators like before. For example, assume we have the following code in ZIO 1.x:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// ZIO 1.x\nimport zio._\nimport zio.console._\nimport zio.duration._\n\nRuntime.default.unsafeRunAsync(\n  console.putStrLn("After 3 seconds I will return 5").delay(3.seconds).as(5)\n)(\n  _.fold(\n    e => println(s"Failure: $e"),\n    v => println(s"Success: $v")\n  )\n)\n')),(0,i.kt)("p",null,"We can rewrite it in ZIO 2.x as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// ZIO 2.x\nimport zio._\n\nUnsafe.unsafe { implicit unsafe =>\n  Runtime.default.unsafe\n    .fork(\n      Console\n        .printLine("After 3 seconds I will return 5")\n        .delay(3.second)\n        .as(5)\n    )\n    .unsafe\n    .addObserver(\n      _.fold(\n        e => println(s"Failure: $e"),\n        v => println(s"Success: $v")\n      )\n    )\n}\n')),(0,i.kt)("p",null,"Similarly, we can do the same for other unsafe operators. Here are some of them:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.0"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"runtime.unsafeRunSync(x)")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Unsafe.unsafe { implicit unsafe => runtime.unsafe.run(x) }"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"runtime.unsafeRunTask(x)")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Unsafe.unsafe { implicit unsafe => runtime.unsafe.run(x).getOrThrow() }"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"runtime.unsafeRunAsync_(x)")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Unsafe.unsafe { implicit unsafe => runtime.unsafe.fork(x) }"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"runtime.unsafeRunToFuture(x)")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Unsafe.unsafe { implicit unsafe => runtime.unsafe.runToFuture(x) }"))))),(0,i.kt)("h3",{id:"runtime-customization-using-layers"},"Runtime Customization using Layers"),(0,i.kt)("p",null,"In ZIO 2.x we deleted the ",(0,i.kt)("inlineCode",{parentName:"p"},"zio.internal.Platform")," data type, and instead, we use layers to customize the runtime. This allows us to use ZIO workflows in customizing our runtime (e.g. loading some configuration information to set up logging)."),(0,i.kt)("p",null,"In ZIO 1.x, we had the ",(0,i.kt)("inlineCode",{parentName:"p"},"Platform")," data type useful for providing custom execution configurations to the runtime:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Platform#withExecutor"),"\u2014 To provide a custom ",(0,i.kt)("inlineCode",{parentName:"li"},"Executor")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Platform#withTracing")," to config tracing functionality"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Platform#withSupervisor")," to provide a ",(0,i.kt)("inlineCode",{parentName:"li"},"Supervisor")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Platform#withScheduler")," to provide a ",(0,i.kt)("inlineCode",{parentName:"li"},"Scheduler")),(0,i.kt)("li",{parentName:"ul"},"etc.")),(0,i.kt)("p",null,"Here is an example of creating a custom ",(0,i.kt)("inlineCode",{parentName:"p"},"Runtime")," in ZIO 1.x:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.internal.Executor\n\nobject MainApp extends zio.App {\n  val customExecutor: Executor = ???\n\n  val myApp: UIO[Unit] =\n    ZIO.debug("Application started")\n\n  def run(args: List[String]): URIO[ZEnv, ExitCode] =\n    ZIO\n      .runtime[ZEnv]\n      .map { runtime =>\n        Unsafe.unsafe { implicit unsafe =>\n          runtime\n            .mapPlatform(_.withExecutor(customExecutor))\n            .unsafe\n            .run(myApp)\n            .getOrThrowFiberFailure()\n        }\n      }\n      .exitCode\n}\n')),(0,i.kt)("p",null,"In ZIO 2.x, the whole ",(0,i.kt)("inlineCode",{parentName:"p"},"Platform")," was deleted and instead, we have several out-of-the-box layers for runtime customization, defined in the companion object of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Runtime")," trait. Here are some of them:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Runtime.addLogger")," to add a logger"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Runtime.setExecutor")," to provide a custom ",(0,i.kt)("inlineCode",{parentName:"li"},"Executor")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Runtime.enableOpLog")," to log runtime information"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Runtime.enableRuntimeMetrics")," to track runtime metrics"),(0,i.kt)("li",{parentName:"ul"},"etc.")),(0,i.kt)("p",null,"Let's see how a previous example can be rewritten in ZIO 2.x:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val customExecutor: zio.Executor = ???\n\n  val myApp = \n    ZIO.debug("Application started")\n\n  def run =\n    myApp.provide(\n      Runtime.setExecutor(customExecutor)\n    )\n}\n')),(0,i.kt)("p",null,"Note that ZIO ecosystem libraries like ZMX may have their own layers that install all necessary functionality."),(0,i.kt)("h3",{id:"runtime-customization-using-zio-data-type"},"Runtime Customization Using ZIO Data Type"),(0,i.kt)("p",null,"To access information about the configuration of our ZIO program as we are running, there are some more specific operators that we can use, such as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.executor"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.executorWith")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.logger"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.loggerWith")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.isFatal"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.isFatalWith"))),(0,i.kt)("h3",{id:"runtime-configurations-are-scoped"},"Runtime Configurations are Scoped"),(0,i.kt)("p",null,"When we access a ",(0,i.kt)("inlineCode",{parentName:"p"},"Runtime")," using ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.runtime")," it will inherit all the configuration of the current workflow so if we use it to run effects they will be run with the same logger and so on:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val workflow1 = ZIO.debug("workflow1 is running") *> ZIO.log("This line will never get logged")\n  val workflow2 = ZIO.debug("workflow2 is running") *> ZIO.log("This line will get logged")\n  val workflow3 = ZIO.debug("workflow3 is running") *> ZIO.log("This line will never get logged")\n\n  def run =\n    ZIO.provideLayer(Runtime.removeDefaultLoggers) {\n      ZIO.runtime[Any].flatMap(_.run(workflow1)) *>\n        ZIO.provideLayer(Runtime.addLogger(Runtime.defaultLoggers.head)) {\n          ZIO.runtime[Any].flatMap(_.run(workflow2))\n        } *> workflow3\n    }\n}\n')),(0,i.kt)("h3",{id:"custom-runtime-for-mixed-applications"},"Custom Runtime for Mixed Applications"),(0,i.kt)("p",null,"In ZIO 2.x, to create a custom runtime in mixed applications we combine all the layers that do our customization and then perform the ",(0,i.kt)("inlineCode",{parentName:"p"},"Runtime.unsafe.fromLayer")," operation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject MainApp {\n  val sl4jlogger: ZLogger[String, Any] = ???\n\n  def legacyApplication(input: Int): Unit = ???\n\n  val zioWorkflow: ZIO[Any, Nothing, Int] = ???\n\n  def zioApplication(): Int =\n      Unsafe.unsafe { implicit unsafe =>\n        Runtime\n          .unsafe\n          .fromLayer(\n            Runtime.removeDefaultLoggers ++ Runtime.addLogger(sl4jlogger)\n          )\n          .unsafe\n          .run(zioWorkflow)\n          .getOrThrowFiberFailure()\n      }\n\n  def main(args: Array[String]): Unit = {\n    val result = zioApplication()\n    legacyApplication(result)\n  }  \n\n}\n")),(0,i.kt)("h3",{id:"executor"},"Executor"),(0,i.kt)("p",null,"We moved the ",(0,i.kt)("inlineCode",{parentName:"p"},"Executor")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"zio.internal")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"zio")," package:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.0"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.internal.Executor")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.Executor"))))),(0,i.kt)("h3",{id:"auto-blocking"},"Auto-Blocking"),(0,i.kt)("p",null,"In ZIO 1.x, we have two groups of constructors for importing ",(0,i.kt)("em",{parentName:"p"},"synchronous side effects"),", one for importing synchronous side effects, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"zio.effect")," and the other one for importing synchronous side effects that are known to be blocking, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"zio.blocking.effectBlocking"),"."),(0,i.kt)("p",null,"The first one uses an asynchronous thread pool to execute side effects, while the second one uses a blocking thread pool."),(0,i.kt)("p",null,"For performance reasons, the number of asynchronous threads is limited to a fixed number. So if the programmer mistakenly imports a blocking operation using the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.effect")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"zio.blocking.effectBlocking")," it might block all limited threads in the asynchronous pool, and then starvation might occur."),(0,i.kt)("p",null,"So if we run the following code if the ",(0,i.kt)("inlineCode",{parentName:"p"},"ioBoundWorkflow")," starts executing before the ",(0,i.kt)("inlineCode",{parentName:"p"},"cpuBoundWorkflow")," for some amount of time, all threads in the asynchronous thread pool will be blocked and the ",(0,i.kt)("inlineCode",{parentName:"p"},"cpuBoundWorkflow")," will never get executed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// ZIO 1.x\nimport zio._\nimport zio.duration.durationInt\n\nimport scala.annotation.tailrec\n\nobject MainApp extends App {\n\n  def fib(n: Int): BigInt = {\n    @tailrec\n    def go(n: BigInt, a: BigInt, b: BigInt): BigInt = {\n      if (n == 0) a\n      else go(n - 1, b, a + b)\n    }\n    go(n, 0, 1)\n  }\n\n  def ioBoundWorkflow =\n    ZIO.debug("Starting I/O bound workflow") *>\n      ZIO.foreachPar_(1 to 100)(_ => ZIO.effect(Thread.sleep(Long.MaxValue))) *>\n      ZIO.debug("Finished I/O bound workflow")\n\n  def cpuBoundWorkflow =\n    ZIO.debug("Starting CPU bound workflow") *>\n      ZIO.foreachPar_(1 to 100)(i => ZIO.effect(fib(i))) *>\n      ZIO.debug("Finished CPU bound workflow")\n\n  // the delay for the CPU bound workflow is not needed but we want to take \n  // a chance that all threads in the asynchronous thread pool will be blocked\n  def run(args: List[String]) =\n    (ioBoundWorkflow <&> cpuBoundWorkflow.delay(1.second)).exitCode\n}\n')),(0,i.kt)("p",null,"This is why we should import blocking synchronous side effects using the ",(0,i.kt)("inlineCode",{parentName:"p"},"zio.blocking.effectBlocking")," instead of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.effect"),"."),(0,i.kt)("p",null,"In ZIO 2.x, the same as in ZIO 1.x, we encourage separating blocking operations (I/O work operations) from the ordinary side effects (CPU work operations)."),(0,i.kt)("p",null,"But the one thing that makes ZIO 2.x more powerful than ZIO 1.x is that if the programmer accidentally imports a blocking synchronous side effect using the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.attempt")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.attemptBlocking")," the runtime scheduler will automatically detect blocking workflows and shift them to the blocking executor:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// ZIO 2.x\nimport zio._\n\nimport scala.annotation.tailrec\n\nobject MainApp extends ZIOAppDefault {\n\n  def fib(n: Int): BigInt = {\n    @tailrec\n    def go(n: BigInt, a: BigInt, b: BigInt): BigInt = {\n      if (n == 0) a\n      else go(n - 1, b, a + b)\n    }\n    go(n, 0, 1)\n  }\n\n  def ioBoundWorkflow =\n    ZIO.debug("Starting I/O bound workflow") *>\n      ZIO.foreachParDiscard(1 to 100)(_ =>\n        ZIO.attempt(Thread.sleep(Long.MaxValue))\n      ) *>\n      ZIO.debug("Finished I/O bound workflow")\n\n  def cpuBoundWorkflow =\n    ZIO.debug("Starting CPU bound workflow") *>\n      ZIO.foreachParDiscard(1 to 100)(i => ZIO.attempt(fib(i))) *>\n      ZIO.debug("Finished CPU bound workflow")\n\n  def run = ioBoundWorkflow <&> cpuBoundWorkflow.delay(1.second)\n}\n')),(0,i.kt)("p",null,"In the above example, although we imported the blocking operation wrongly, the runtime scheduler will detect that and prevent the blocking operation from being executed in the asynchronous thread pool. So the ",(0,i.kt)("inlineCode",{parentName:"p"},"cpuBoundWorkflow")," will be executed without any starvation problem."),(0,i.kt)("h2",{id:"zlayer"},"ZLayer"),(0,i.kt)("h3",{id:"constructing-layers"},"Constructing Layers"),(0,i.kt)("p",null,"In ZIO 1.x, when we want to write a service that depends on other services, we need to use ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer.fromService*")," variants with a lot of boilerplate:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val live: URLayer[FooService with BarService, BazService] =\n  ZLayer.fromServices[FooService.Service, BarService.Service, BazService.Service] {\n    (fooService: FooService.Service, barService: BarService.Service) =>\n      new BazService.Service {\n        override def baz: UIO[Unit] =\n          for {\n            _ <- fooService.foo\n            _ <- barService.bar\n          } yield ()\n      }\n  }\n")),(0,i.kt)("p",null,"ZIO 2.x deprecates all ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer.fromService*")," functions. Instead, we use a for comprehension:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait FooService {\n  def foo: UIO[Unit]\n}\n\ntrait BarService {\n  def bar: UIO[Unit]\n}\n\ntrait BazService {\n  def baz: UIO[Unit]\n}\n\ncase class BazServiceImpl(fooService: FooService, barService: BarService) extends BazService {\n  override def baz: UIO[Unit] =\n    for {\n      _ <- fooService.foo\n      _ <- barService.bar\n    } yield ()\n}\n\nobject LoggingLive {\n  val layer: ZLayer[FooService & BarService, Nothing, BazService] =\n    ZLayer {\n      for {\n        fooService <- ZIO.service[FooService]\n        barService <- ZIO.service[BarService]\n      } yield BazServiceImpl(fooService, barService)\n    }\n}\n")),(0,i.kt)("h3",{id:"accessing-a-service-from-the-environment"},"Accessing a Service from the Environment"),(0,i.kt)("p",null,"Assume we have a service named ",(0,i.kt)("inlineCode",{parentName:"p"},"Logging"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait Logging {\n  def log(line: String): UIO[Unit]\n}\n")),(0,i.kt)("p",null,"In ZIO 1.x, when we wanted to access a service from the environment, we used the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.access")," + ",(0,i.kt)("inlineCode",{parentName:"p"},"Has#get")," combination (",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.access(_.get)"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val logging: URIO[Logging, Logging] = ZIO.access(_.get)\n")),(0,i.kt)("p",null,"Also, to create accessor methods, we used the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def log(line: String): URIO[Logging, Unit] = ZIO.accessM(_.get.log(line))\n")),(0,i.kt)("p",null,"ZIO 2.x reduces one level of indirection by using ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.service")," operator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val logging : URIO[Logging, Logging] = ZIO.service\n")),(0,i.kt)("p",null,"And to write the accessor method in ZIO 2.x, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.serviceWithZIO")," operator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def log(line: String): URIO[Logging, Unit] = ZIO.serviceWithZIO(_.log(line))\n")),(0,i.kt)("h3",{id:"accessing-multiple-services-in-the-environment"},"Accessing Multiple Services in the Environment"),(0,i.kt)("p",null,"In ZIO 1.x, we could access multiple services using higher arity service accessors like ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.services"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  (fooService, barService) <- ZIO.services[FooService, BarService]\n  foo                      <- fooService.foo()\n  bar                      <- barService.bar()\n  _                        <- console.putStrLn(s"foo: $foo, bar: $bar")\n} yield ()\n')),(0,i.kt)("p",null,"They were ",(0,i.kt)("em",{parentName:"p"},"deprecated")," as we can achieve the same functionality using ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.service")," with for-comprehension syntax, which is more idiomatic and scalable way of accessing multiple services in the environment:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  fooService <- ZIO.service[FooService]\n  barService <- ZIO.service[BarService]\n  foo        <- fooService.foo()\n  bar        <- barService.bar()\n  _          <- Console.printLine(s"foo: $foo, bar: $bar")\n} yield ()\n')),(0,i.kt)("h3",{id:"building-the-dependency-graph"},"Building the Dependency Graph"),(0,i.kt)("p",null,"To create the dependency graph in ZIO 1.x, we should compose the required layer manually. As the ordering of layer compositions matters, and also we should care about composing layers in both vertical and horizontal manner, it would be a cumbersome job to create a dependency graph with a lot of boilerplates."),(0,i.kt)("p",null,"Assume we have the following dependency graph with two top-level dependencies:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"           DocRepo                ++          UserRepo\n      ____/   |   \\____                       /     \\\n     /        |        \\                     /       \\\n Logging  Database  BlobStorage          Logging   Database\n    |                    |                  |\n Console              Logging            Console\n                         |       \n                      Console    \n")),(0,i.kt)("p",null,"In ZIO 1.x, we had to compose these different layers together to create the whole application dependency graph:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val appLayer: URLayer[Any, DocRepo with UserRepo] =\n  (((Console.live >>> Logging.live) ++ Database.live ++ (Console.live >>> Logging.live >>> BlobStorage.live)) >>> DocRepo.live) ++\n    (((Console.live >>> Logging.live) ++ Database.live) >>> UserRepo.live)\n    \nval res: ZIO[Any, Nothing, Unit] = myApp.provideLayer(appLayer)\n")),(0,i.kt)("p",null,"As the development of our application progress, the number of layers will grow, and maintaining the dependency graph would be tedious and hard to debug."),(0,i.kt)("p",null,"For example, if we miss the ",(0,i.kt)("inlineCode",{parentName:"p"},"Logging.live")," dependency, the compile-time error would be very messy:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"myApp.provideLayer(\n  ((Database.live ++ BlobStorage.live) >>> DocRepo.live) ++\n    (Database.live >>> UserRepo.live)\n)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"type mismatch;\n found   : zio.URLayer[zio.Logging with zio.Database with zio.BlobStorage,zio.DocRepo]\n    (which expands to)  zio.ZLayer[zio.Logging with zio.Database with zio.BlobStorage,Nothing,zio.DocRepo]\n required: zio.ZLayer[zio.Database with zio.BlobStorage,?,?]\n    ((Database.live ++ BlobStorage.live) >>> DocRepo.live) ++\n")),(0,i.kt)("p",null,"In ZIO 2.x, we can automatically construct dependencies with friendly compile-time hints, using ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#provide")," operator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val res: ZIO[Any, Nothing, Unit] =\n  myApp.provide(\n    Logging.live,\n    Database.live,\n    BlobStorage.live,\n    DocRepo.live,\n    UserRepo.live\n  )\n")),(0,i.kt)("p",null,"The order of dependencies doesn't matter:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val res: ZIO[Any, Nothing, Unit] =\n  myApp.provide(\n    DocRepo.live,\n    BlobStorage.live,\n    Logging.live,\n    Database.live,\n    UserRepo.live\n  )\n")),(0,i.kt)("p",null,"If we miss some dependencies, it doesn't compile, and the compiler gives us the clue:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val app: ZIO[Any, Nothing, Unit] =\n  myApp.provide(\n    DocRepo.live,\n    BlobStorage.live,\n//    Logging.live,\n    Database.live,\n    UserRepo.live\n  )\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  ZLayer Wiring Error  \n\n\u276f missing Logging\n\u276f     for DocRepo.live\n\n\u276f missing Logging\n\u276f     for UserRepo.live\n")),(0,i.kt)("p",null,"We can also directly construct a layer using ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer.make"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val layer = ZLayer.make[DocRepo with UserRepo](\n  Logging.live,\n  DocRepo.live,\n  Database.live,\n  BlobStorage.live,\n  UserRepo.live\n)\n")),(0,i.kt)("p",null,"And also the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer.makeSome")," helps us to construct a layer which requires some service and produces some other services (",(0,i.kt)("inlineCode",{parentName:"p"},"URLayer[Int, Out]"),") using ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer.makeSome[In, Out]"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val layer = ZLayer.makeSome[Logging, DocRepo with UserRepo](\n  DocRepo.live,\n  Database.live,\n  BlobStorage.live,\n  UserRepo.live\n)\n")),(0,i.kt)("p",null,"In ZIO 1.x, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#provideSomeLayer")," provides environment partially:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val app: ZIO[Console, Nothing, Unit] =\n  myApp.provideSomeLayer[Console](\n    ((Logging.live ++ Database.live ++ (Console.live >>> Logging.live >>> BlobStorage.live)) >>> DocRepo.live) ++\n      (((Console.live >>> Logging.live) ++ Database.live) >>> UserRepo.live)\n  )\n")),(0,i.kt)("p",null,"In ZIO 2.x, we have a similar functionality but for injection, which is the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#provideSome[Rest](l1, l2, ...)")," operator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val app: ZIO[Any, Nothing, Unit] =\n  myApp.provideSome[Logging](\n    DocRepo.live,\n    Database.live,\n    BlobStorage.live,\n    UserRepo.live\n  )\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"In ZIO 2.x, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#provide")," method \u2014 together with its variant ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#provideSome")," \u2014 is a default and easier way of injecting dependencies to the environmental effect. We do not have to create the dependency graph manually, it will be built automatically. In contrast, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#provideLayer")," \u2014 and its variant ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#provideSomeLayer")," \u2014 is useful for low-level and custom cases.")),(0,i.kt)("h3",{id:"zlayer-debugging"},"ZLayer Debugging"),(0,i.kt)("p",null,"To debug ZLayer construction, we have two built-in layers, i.e., ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer.Debug.tree")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer.Debug.mermaid"),". For example, by including ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer.Debug.mermaid")," into our layer construction, the compiler generates the following debug information:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val layer = ZLayer.make[DocRepo with UserRepo](\n  Logging.live,\n  DocRepo.live,\n  Database.live,\n  BlobStorage.live,\n  UserRepo.live,\n  ZLayer.Debug.mermaid\n)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"[info]   ZLayer Wiring Graph  \n[info] \n[info] \u25c9 DocRepo.live\n[info] \u251c\u2500\u25d1 Logging.live\n[info] \u251c\u2500\u25d1 Database.live\n[info] \u2570\u2500\u25d1 BlobStorage.live\n[info]   \u2570\u2500\u25d1 Logging.live\n[info] \n[info] \u25c9 UserRepo.live\n[info] \u251c\u2500\u25d1 Logging.live\n[info] \u2570\u2500\u25d1 Database.live\n[info] \n[info] Mermaid Live Editor Link\n[info] https://mermaid-js.github.io/mermaid-live-editor/edit/#eyJjb2RlIjoiZ3JhcGhcbiAgICBDb25zb2xlLmxpdmVcbiAgICBCbG9iU3RvcmFnZS5saXZlIC0tPiBMb2dnaW5nLmxpdmVcbiAgICBMb2dnaW5nLmxpdmUgLS0+IENvbnNvbGUubGl2ZVxuICAgIFVzZXJSZXBvLmxpdmUgLS0+IExvZ2dpbmcubGl2ZVxuICAgIFVzZXJSZXBvLmxpdmUgLS0+IERhdGFiYXNlLmxpdmVcbiAgICBEb2NSZXBvLmxpdmUgLS0+IERhdGFiYXNlLmxpdmVcbiAgICBEb2NSZXBvLmxpdmUgLS0+IEJsb2JTdG9yYWdlLmxpdmVcbiAgICBEYXRhYmFzZS5saXZlXG4gICAgIiwibWVybWFpZCI6ICJ7XG4gIFwidGhlbWVcIjogXCJkZWZhdWx0XCJcbn0iLCAidXBkYXRlRWRpdG9yIjogdHJ1ZSwgImF1dG9TeW5jIjogdHJ1ZSwgInVwZGF0ZURpYWdyYW0iOiB0cnVlfQ==\n")),(0,i.kt)("h3",{id:"descriptive-zioapp-environment-compiler-errors"},"Descriptive ZIOApp Environment Compiler Errors"),(0,i.kt)("p",null,"In ZIO 1.x, if we mistakenly forget to provide some requirements, we have some complicated compile errors. Assume we have the following example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// ZIO 1.x\nimport zio._\n\ncase class Config(host: String, port: Int)\n\ntrait Logger {\n  def log(line: Any): Task[Unit]\n}\n\nobject MainApp extends App {\n  val myApp =\n    for {\n      config <- ZIO.service[Config]\n      logger <- ZIO.service[Logger]\n      _ <- logger.log(s"Application started with the following config: $config")\n    } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n')),(0,i.kt)("p",null,"This program needs ",(0,i.kt)("inlineCode",{parentName:"p"},"Config")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Logger")," layers, but we missed them. The compiler prints this mystic error, which is hard to reason about:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"type mismatch;\nfound   : zio.URIO[zio.Has[Config] with zio.Has[Logger] with zio.console.Console,zio.ExitCode]\n(which expands to)  zio.ZIO[zio.Has[Config] with zio.Has[Logger] with zio.Has[zio.console.Console.Service],Nothing,zio.ExitCode]\nrequired: zio.URIO[zio.ZEnv,zio.ExitCode]\n(which expands to)  zio.ZIO[zio.Has[zio.clock.Clock.Service] with zio.Has[zio.console.Console.Service] with zio.Has[zio.system.System.Service] with zio.Has[zio.random.Random.Service] with zio.Has[zio.blocking.Blocking.Service],Nothing,zio.ExitCode]\nmyApp.exitCode\n")),(0,i.kt)("p",null,"In ZIO 2.x, we have descriptive errors. Let's try the above example in ZIO 2.x:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ncase class Config(host: String, port: Int)\n\ntrait Logger {\n  def log(line: Any): Task[Unit]\n}\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      config <- ZIO.service[Config]\n      logger <- ZIO.service[Logger]\n      _ <- logger.log(s"Application started with the following config: $config")\n    } yield ()\n}\n')),(0,i.kt)("p",null,"This will print the following error message:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[error] \u2500\u2500\u2500\u2500 ZIO APP ERROR \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[error] \n[error]  Your effect requires a service that is not in the environment.\n[error]  Please provide a layer for the following type:\n[error] \n[error] \n[error]    1. Logger\n[error] \n[error] \n[error]  Call your effect's provide method with the layers you need.\n[error]  You can read more about layers and providing services here:\n[error]  \n[error]    https://zio.dev/version-1.x/dataypes/contextual/index\n[error] \n[error] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[error] \n[error]       logger <- ZIO.service[Logger]\n[error]              ^\n[error] one error found\n")),(0,i.kt)("p",null,"It also warns if we provide more layers than needed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ncase class Config(host: String, port: Int)\n\ntrait Logger {\n  def log(line: Any): Task[Unit]\n}\n\ncase class LoggerLive(console: Console) extends Logger {\n  override def log(line: Any): Task[Unit] =\n    console.printLine(line)\n}\n\nobject LoggerLive {\n  val layer =\n    ZLayer {\n      for {\n        console <- ZIO.service[Console]\n      } yield LoggerLive(console)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp = for {\n    config <- ZIO.service[Config]\n    _ <- Console.printLine(s"Application started with the following config: $config")\n  } yield ()\n\n  def run =\n    myApp.provide(\n      Random.live,\n      ZLayer.succeed(Config("localhost", 8080)),\n      LoggerLive.layer\n    )\n}\n')),(0,i.kt)("p",null,"It will print the following warning message:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[error] \u2500\u2500\u2500\u2500 ZLAYER WARNING \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[error] \n[error]  You have provided more than is required.\n[error]  You may remove the following 2 layers:\n[error]    \n[error]    1. Random.live\n[error]    2. LoggerLive.layer\n[error] \n[error]   \n[error] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[error] \n[error]     myApp.provide(\n[error]                  ^\n[error] one error found\n")),(0,i.kt)("h3",{id:"eliminators-for-environmental-effects"},"Eliminators for Environmental Effects"),(0,i.kt)("p",null,"In ZIO 2.x, layers become eliminators for environmental effects:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait Foo\ntrait Bar\n\nval fooLayer   : ZLayer[Any, Nothing, Foo]          = ZLayer.succeed(???)\nval fooWithBar : ZIO[Foo with Bar, Throwable, Unit] = ZIO.succeed(???)\nval bar        : ZIO[Bar, Any, Unit]                = fooLayer(fooWithBar)\n")),(0,i.kt)("p",null,"In this example, by applying the ",(0,i.kt)("inlineCode",{parentName:"p"},"fooLayer")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"fooWithBarWithBaz")," effect it will eliminate the contextual ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo")," service from the environment of the effect."),(0,i.kt)("p",null,"Furthermore, we can compose multiple layers together and then eliminate services from the environmental effects:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ntrait Foo\ntrait Bar\ntrait Baz\n\nobject MainApp extends ZIOAppDefault {\n\n  val needsFooAndBarAndBaz: ZIO[Foo & Bar & Baz, Nothing, Unit] =\n    for {\n      foo <- ZIO.service[Foo]\n      bar <- ZIO.service[Bar]\n      baz <- ZIO.service[Baz]\n      _ <- ZIO.debug(s"Foo: $foo, Bar: $bar, Baz: $baz")\n    } yield ()\n\n  val fooAndBarLayer: ULayer[Foo with Bar] =\n    ZLayer.succeed(new Foo {}) ++ ZLayer.succeed(new Bar {})\n\n  val needsBaz: ZIO[Baz, Nothing, Unit] =\n    fooAndBarLayer(needsFooAndBarAndBaz)\n\n  def run = needsBaz.provide(ZLayer.succeed(new Baz {}))\n\n}\n')),(0,i.kt)("p",null,"It helps us to provide contextual environments like the DSL below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait Connection\n\nval dbTransaction: ZLayer[Any, Throwable, Connection] = ZLayer.succeed(???)\nval effect: ZIO[Connection, Throwable, Unit] = ZIO.succeed(???)\n\nval result: ZIO[Any, Throwable, Unit] =\n  dbTransaction {\n    effect\n  }\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"dbTransaction")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer[Any, Throwable, Connection]")," which can eliminate the ",(0,i.kt)("inlineCode",{parentName:"p"},"Connection")," service from the ",(0,i.kt)("inlineCode",{parentName:"p"},"effect"),"."),(0,i.kt)("h3",{id:"service-pattern"},"Service Pattern"),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"Service Pattern"),', formerly called "Module Pattern", is one of the most important changes in ZIO 2.x. Let\'s take a look at services in ZIO 1.x before discussing changes. '),(0,i.kt)("p",null,"Assume we have already defined the ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Bar")," services using ",(0,i.kt)("em",{parentName:"p"},"Service Pattern 1.0")," as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// ZIO 1.x\nobject foo {\n  type Foo = Has[Foo.Service]\n\n  object Foo {\n    trait Service {\n      def foo: UIO[String]\n    }\n  }\n}\n\nobject bar {\n  type Bar = Has[Bar.Service]\n\n  object Bar {\n    trait Service {\n      def bar: UIO[String]\n    }\n  }\n}\n")),(0,i.kt)("p",null,"Here is a ",(0,i.kt)("inlineCode",{parentName:"p"},"Baz")," service that uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Bar")," services:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// ZIO 1.x\nobject baz {\n  // Defining the service type by wrapping the service interface with Has[_] data type\n  type Baz = Has[Baz.Service]\n\n  // Companion object that holds service interface and its live implementation\n  object Baz {\n    trait Service {\n      def baz(input: String): UIO[Unit]\n    }\n    \n    // Live implementation of the Foo service\n    val live: ZLayer[Foo with Bar, Nothing, Baz] =\n      ZLayer.fromServices[Foo.Service, Bar.Service, Baz.Service] {\n        (fooSrv: Foo.Service, barSrv: Bar.Service) =>\n          new Baz.Service {\n            override def baz(input: String): UIO[Unit] =\n              for {\n                _ <- fooSrv.foo(input)\n                _ <- barSrv.bar(input)\n              } yield ()\n          }\n      }\n  }\n\n  // Accessor Methods\n  def baz(input: String): URIO[Baz, Unit] =\n    ZIO.accessM(_.get.baz(input))\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Baz")," service is a service which depends on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Bar")," services."),(0,i.kt)("p",null,"ZIO 2.x introduces the ",(0,i.kt)("em",{parentName:"p"},"Service Pattern 2.0")," which is much more concise and has more ergonomics. Let's see how the ",(0,i.kt)("inlineCode",{parentName:"p"},"Baz")," service can be implemented using this new pattern."),(0,i.kt)("p",null,"Assume we have already defined the ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Bar")," services, as below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// ZIO 2.x\n\ntrait Foo {\n  def foo(input: String): UIO[Unit]\n}\n\ntrait Bar {\n  def bar(input: String): UIO[Unit]\n}\n")),(0,i.kt)("p",null,"Now, here is the implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Baz")," service based on the ",(0,i.kt)("em",{parentName:"p"},"Service Pattern 2.0"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// ZIO 2.x\n\nimport zio._\n\n// Defining the Service Interface\ntrait Baz {\n  def baz(input: String): UIO[Unit]\n}\n\n// Accessor Methods Inside the Companion Object\nobject Baz {\n  def baz(input: String): URIO[Baz, Unit] =\n    ZIO.serviceWithZIO(_.baz(input))\n}\n\n// Implementation of the Service Interface\ncase class BazLive(fooSrv: Foo, barSrv: Bar) extends Baz {\n  override def baz(input: String): UIO[Unit] =\n    for {\n      _ <- fooSrv.foo(input)\n      _ <- barSrv.bar(input) \n    } yield ()\n}\n\n// Converting the Service Implementation into the ZLayer\nobject BazLive {\n  val layer: URLayer[Foo & Bar, Baz] =\n    ZLayer {\n      for {\n        fooSrv <- ZIO.service[Foo]\n        barSrv <- ZIO.service[Bar]\n      } yield BazLive(fooSrv, barSrv)\n    }\n}\n")),(0,i.kt)("p",null,"As we see, we have the following changes:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Deprecation of Type Alias for ",(0,i.kt)("inlineCode",{parentName:"strong"},"Has")," Wrappers")," \u2014 In ",(0,i.kt)("em",{parentName:"p"},"Service Pattern 1.0")," although the type aliases were to prevent using ",(0,i.kt)("inlineCode",{parentName:"p"},"Has[ServiceName]")," boilerplate everywhere, they were confusing, and led to doubly nested ",(0,i.kt)("inlineCode",{parentName:"p"},"Has[Has[ServiceName]]"),". So the ",(0,i.kt)("em",{parentName:"p"},"Service Pattern 2.0")," doesn't anymore encourage using type aliases. Also, they were removed from all built-in ZIO services. So the ",(0,i.kt)("inlineCode",{parentName:"p"},"type Foo = Has[Foo.Service]")," is removed and the ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo.Service")," will just be ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Introducing Constructor-based Dependency Injection")," \u2014 In ",(0,i.kt)("em",{parentName:"p"},"Service Pattern 1.0")," when we wanted to create a layer that depends on other services, we had to use ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer.fromService*")," constructors. The problem with those constructors is that there are too many of them, each one is useful for a specific use-case, but people had trouble figuring out which one to use. "),(0,i.kt)("p",{parentName:"li"},"In ",(0,i.kt)("em",{parentName:"p"},"Service Pattern 2.0")," we don't worry about all these different ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer")," constructors. The recommendation is to  ",(0,i.kt)("strong",{parentName:"p"},"provide dependencies as interfaces through the case class constructor"),", and then we have direct access to all of the dependencies to implement the service. Finally, to create the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer")," we use a for comprehension.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Separated Interface")," \u2014 In ",(0,i.kt)("em",{parentName:"p"},"Service Pattern 2.0"),", ZIO supports the ",(0,i.kt)("em",{parentName:"p"},"Separated Interface")," pattern which encourages keeping the implementation of an interface decoupled from the client and its definition."),(0,i.kt)("p",{parentName:"li"}," As our application grows, where we define our layers matters more. ",(0,i.kt)("em",{parentName:"p"},"Separated Interface")," is a very useful pattern while we are developing a complex application. It helps us to reduce the coupling between application components. "),(0,i.kt)("p",{parentName:"li"}," Following two changes in ",(0,i.kt)("em",{parentName:"p"},"Service Pattern")," we can define the service definition in one package but its implementations in other packages:"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Flattened Structure")," \u2014 In the new pattern, everything is at the top level in a file. So the developer is not limited to package service definition and service implementation in one package."),(0,i.kt)("admonition",{parentName:"li",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Service Pattern 2.0 supports the idea of ",(0,i.kt)("em",{parentName:"p"},"Separated Interface"),", but it doesn't enforce us grouping them into different packages and modules. The decision is up to us, based on the complexity and requirements of our application."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Decoupling Interfaces from Implementation")," \u2014 Assume we have a complex application, and our interface is ",(0,i.kt)("inlineCode",{parentName:"p"},"Baz")," with different implementations that potentially depend on entirely different modules. Putting layers in the service definition means anyone depending on the service definition needs to depend on all the dependencies of all the implementations, which is not a good practice."),(0,i.kt)("p",{parentName:"li"},"In ",(0,i.kt)("em",{parentName:"p"},"Service Pattern 2.0"),", layers are defined in the implementation's companion object, not in the interface's companion object. So instead of calling ",(0,i.kt)("inlineCode",{parentName:"p"},"Baz.live")," to access the live implementation we call ",(0,i.kt)("inlineCode",{parentName:"p"},"BazLive.layer"),".")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Accessor Methods")," \u2014 The new pattern reduced one level of indirection on writing accessor methods. So instead of accessing the environment (",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.access/ZIO.accessM"),") and then retrieving the service from the environment (",(0,i.kt)("inlineCode",{parentName:"p"},"Has#get"),") and then calling the service method, ",(0,i.kt)("em",{parentName:"p"},"Service Pattern 2.0")," introduced ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.serviceWith")," that is a more concise way of writing accessor methods. For example, instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.accessM(_.get.baz(input))")," we write ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.serviceWithZIO(_.baz(input))"),"."))),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Service Pattern 1.0")," was somewhat complicated and had some boilerplate. ",(0,i.kt)("em",{parentName:"p"},"Service Pattern 2.0")," is much more familiar for people coming from an object-oriented world. It is simpler and easier to learn for newcomers."),(0,i.kt)("h3",{id:"other-changes"},"Other Changes"),(0,i.kt)("p",null,"Here is list of other deprecated methods:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZLayer.fromEffect")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZLayer.fromZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZLayer.fromEffectMany")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZLayer.fromZIOMany"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZLayer.fromFunctionM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZLayer.fromFunctionZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZLayer.fromFunctionManyM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZLayer.fromFunctionManyZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZLayer.identity")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZLayer.service"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZLayer.requires")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZLayer.service"))))),(0,i.kt)("h2",{id:"scopes"},"Scopes"),(0,i.kt)("p",null,"ZIO 2.x introduced a new data type called ",(0,i.kt)("inlineCode",{parentName:"p"},"Scope"),". Scopes are a huge simplification to resource management in ZIO 2.0 that brings new levels of simplicity, power, and performance. They are a replacement for the old ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," data type in ZIO 1.x."),(0,i.kt)("h3",{id:"zmanaged"},"ZManaged"),(0,i.kt)("p",null,"In ZIO 1.x, we used a data type called ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," to provide resource safety. Although inspired by the Managed data type from Haskell, ZIO Managed innovated in a number of ways over both Haskell and Cats Effect Resource:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," supported interruptible acquisition, which is useful for concurrent data structures like semaphores, where it is safe to interrupt acquisition because the cleanup can determine (by inspecting the in-memory state) whether the acquisition succeeded or not.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," supported parallel operations, all with the most desirable semantics possible. For example, if we acquired resources in parallel, then they would be released in parallel, and if anything went wrong, of course, the acquisition would be aborted and resources released.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," has an API almost identical to ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO"),", by design, so our knowledge of ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," transfers to ",(0,i.kt)("inlineCode",{parentName:"p"},"Managed"),". The main difference is that in ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"flatMap")," lets us ",(0,i.kt)("em",{parentName:"p"},"use and keep open a resource"),", while ",(0,i.kt)("inlineCode",{parentName:"p"},"use")," lets us ",(0,i.kt)("em",{parentName:"p"},"use and release the resource (going back to ",(0,i.kt)("inlineCode",{parentName:"em"},"ZIO"),")"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"In addition, ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," has new constructors, so we can create them from a pair of acquire/release actions, or from just a finalizer (which would be invoked during finalization)."))),(0,i.kt)("p",null,"Despite the innovation and numerous benefits, however, ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," presents some serious drawbacks:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"First, ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," is yet another thing to teach to developers. Many new ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," developers try to avoid using ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged"),", because they are not sure exactly what it's for or how it differs from ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO"),". Those who use it, sometimes wonder when to use ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," versus ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Second, all the methods on ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," must be manually and painstakingly re-implemented on ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged"),", but with much more complex implementations due to the complications of handling resource-safety in the presence of concurrency. In practice, ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," still has more methods than ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Third, ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," is a layer over ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO"),", and is slower than ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," itself, because of the additional complications and wrapping. Unlike other approaches, ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," uses an executable encoding, so it's able to avoid double-interpretation, but it still has measurable overhead over ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO"),"."))),(0,i.kt)("p",null,"Despite the drawbacks of ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged"),", the benefits of concurrent resource safety are significant, so we documented, supported, and tried to optimize ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," over the life of ZIO 1.x, not having a suitable alternative."),(0,i.kt)("h3",{id:"scopes-1"},"Scopes"),(0,i.kt)("p",null,"The concept of scopes has been implicit in ZIO since before ZIO 1.0, including in ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),', interruptibility, and thread pool shifting. In each of these cases we "do something" at the beginning of the scope (e.g. acquire a resource, set a ',(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),', change the interruptibility of the thread pool) and "do something else" (release the resource, restore the ',(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),", restore the interruptibility or thread pool) at the end of the scope."),(0,i.kt)("p",null,"However, scopes have not been first-class values, which has required the use of other data types such as ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," to represent this concept. With ZIO 2.0, all of this is radically changing for the better! Thanks to other ZIO 2.0 innovations, including the ",(0,i.kt)("a",{parentName:"p",href:"#deletion-of-has-data-type"},"removal of ",(0,i.kt)("inlineCode",{parentName:"a"},"Has"))," (which bakes a compositional environment directly into the ZIO data type), we have found a way to delete ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," entirely, while preserving all of its benefits!"),(0,i.kt)("p",null,"ZIO 2.x addresses this by introducing the concept of a Scope as a first class value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait Scope {\n  def addFinalizerExit(finalizer: Exit[Any, Any] => UIO[Any]): UIO[Unit]\n  def close(exit: Exit[Any, Any]): UIO[Unit]\n}\n")),(0,i.kt)("p",null,"That is, a ",(0,i.kt)("inlineCode",{parentName:"p"},"Scope")," is something that we can add finalizers to and eventually close, running all of the finalizers in the scope. Operations that acquire resources add their finalizers directly to the current scope, stored in ZIO Environment. So we found that the ZIO Environment is now powerful enough to provide resource-safety by itself!"),(0,i.kt)("p",null,"For example, an operation that opens a file might have this type signature:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def openFile(name: String): ZIO[Scope, IOException, FileInputStream] =\n  ZIO.acquireRelease(acquire)(release)\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"openFile")," workflow requires a ",(0,i.kt)("inlineCode",{parentName:"p"},"Scope")," to be run and its implementation will add a finalizer to the scope that will close the file. So, in combination with the environment, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"Scope")," to represent resources."),(0,i.kt)("p",null,"This allows us to work with the resource and compose it with other resources, much like we do with ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged"),". Then, when we are ready to close the scope we use ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.scoped")," to provide the scope and eliminate it from the environment, much the same way we do with ",(0,i.kt)("inlineCode",{parentName:"p"},"use")," on ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"ZIO.scoped {\n  openFile(name).flatMap(file => useFile(file))  // ZIO[Scoped, IOException, Unit]\n}                                                // ZIO[Any, IOException, Unit]\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.scoped")," eliminates ",(0,i.kt)("inlineCode",{parentName:"p"},"Scope")," from the environment, leaving the rest of the environment unchanged. It converts the type of enclosed effect from ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO[Scoped, IOException, Unit]")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO[Any, IOException, Unit]"),". So, we can think of it as an algebraic effect handler that handles the ",(0,i.kt)("inlineCode",{parentName:"p"},"Scope")," effect by eliminating it from the set of algebraic effects being used. This is another use case of ",(0,i.kt)("a",{parentName:"p",href:"#eliminators-for-environmental-effects"},"eliminators for environmental effect"),"."),(0,i.kt)("p",null,"This simple, beautiful, and powerful design gives us bulletproof parallel and concurrent operators that may acquire resources with well-defined and optimal semantics in successful and failure scenarios. All the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," semantics arise for free atop ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO"),"."),(0,i.kt)("p",null,"Scopes are simple because they don't require us to learn any new data types. Scopes are powerful because ZIO has more operators than ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged"),", and is always ",(0,i.kt)("em",{parentName:"p"},"up to date")," with the latest and greatest. Scopes are fast because there are no layers atop ZIO."),(0,i.kt)("p",null,"In addition to providing simpler, more powerful, and faster resource management, the replacement of Managed with scopes is going to tremendously simplify the ZIO API: there will not be any more ",(0,i.kt)("inlineCode",{parentName:"p"},"toManaged"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"mapManaged"),", etc, variants. Layers will always be constructed with ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO"),"."),(0,i.kt)("h3",{id:"migration-from-zmanaged-to-scope"},"Migration from ",(0,i.kt)("inlineCode",{parentName:"h3"},"ZManaged")," to ",(0,i.kt)("inlineCode",{parentName:"h3"},"Scope")),(0,i.kt)("h4",{id:"deferred-migration"},"Deferred Migration"),(0,i.kt)("p",null,"For reasons of backward compatibility, ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," won't actually be deleted, but rather, moved to a separate library called ",(0,i.kt)("inlineCode",{parentName:"p"},"zio-managed")," that our ZIO 2.0 application can depend on. However, ZIO Core, including ZIO Streams and ZIO Test, will no longer use ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged"),"."),(0,i.kt)("p",null,"So, if we have a lot of code that used ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," and we are not ready to deal with it right now we can still use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," data type and compile our code. We can add the ",(0,i.kt)("inlineCode",{parentName:"p"},"zio-managed")," dependency into the ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio-managed" % "<2.x version>"\n')),(0,i.kt)("p",null,"And then by adding ",(0,i.kt)("inlineCode",{parentName:"p"},"import zio.managed._")," we can access all ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," capabilities including extension methods on ZIO data types. This helps us to compile the ZIO 1.x code base which uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," data type. Then we can smoothly refactor it to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Scope")," data type instead."),(0,i.kt)("h4",{id:"immediate-migration"},"Immediate Migration"),(0,i.kt)("p",null,"Migration to ",(0,i.kt)("inlineCode",{parentName:"p"},"Scope")," is easy and straightforward. As the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," data type is removed from ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," and all usages in ZIO Core, ZIO Stream, and ZIO Test are reimplemented in terms of ",(0,i.kt)("inlineCode",{parentName:"p"},"Scope"),". We should follow these steps to migrate the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged")," codebase to ",(0,i.kt)("inlineCode",{parentName:"p"},"Scope"),":"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Replace all references to ",(0,i.kt)("inlineCode",{parentName:"li"},"ZManaged[R, E, A]")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO[R with Scope, E, A]"),".")),(0,i.kt)("p",null,"Example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"object HttpClient {\n-   def make(): ZManaged[Config, IOException, HttpClient] = ???\n+   def make(): ZIO[Config with Scope, IOException, HttpClient] = ???\n}\n")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"Replace all references to ",(0,i.kt)("inlineCode",{parentName:"li"},"resource.use(f)")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.scoped(resource.flatMap(f))"),":")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"- resource.use(f)\n+ ZIO.scoped {\n+  resource.flatMap(f) \n+ }\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},'- ZManaged\n-  .fromAutoCloseable(zio.blocking.effectBlockingIO(scala.io.Source.fromFile("file.txt")))\n-  .use(x => ZIO.succeed(x.getLines().length))\n+ ZIO.scoped {\n+   ZIO\n+    .fromAutoCloseable(ZIO.attemptBlockingIO(scala.io.Source.fromFile("file.txt")))\n+    .flatMap(x => ZIO.succeed(x.getLines().length))\n+ }\n')),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},"Replace all ",(0,i.kt)("inlineCode",{parentName:"li"},"ZManaged")," constructors with ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.acquireRelease")," or one of its variants:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"- ZManaged.make(acquire)(release)\n+ ZIO.acquireRelease(acquire)(release)\n")),(0,i.kt)("p",null,"Example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},'- ZManaged.fromAutoCloseable(\n-   zio.blocking.effectBlockingIO(new FileInputStream("file.txt")) \n- )\n+ ZIO.fromAutoCloseable(\n+   ZIO.attemptBlockingIO(new FileInputStream("file.txt")) \n+ )\n')),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},"Replace all usages of ",(0,i.kt)("inlineCode",{parentName:"li"},"ZLayer(resource)")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"resource.toLayer")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"ZLayer.scoped(resource)"),", all references to ",(0,i.kt)("inlineCode",{parentName:"li"},"ZStream.managed(resource)")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"ZStream.scoped(resource)"),", and so on for similar constructors:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"- ZLayer {\n-   resource // with type of ZManaged[R, E, A]\n- }\n+ ZLayer.scoped {\n+   resource // with type of ZIO[R with Scope, E, A]\n+ }\n\n- resource.toLayer\n+ ZLayer.scoped(resource)\n\n- ZStream.managed(resource)\n+ ZStream.scoped(resource)\n")),(0,i.kt)("ol",{start:5},(0,i.kt)("li",{parentName:"ol"},"Delete all uses of ",(0,i.kt)("inlineCode",{parentName:"li"},"toManaged_"),":")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"- effect.toManaged_\n+ effect \n")),(0,i.kt)("ol",{start:6},(0,i.kt)("li",{parentName:"ol"},"Replace all uses of ",(0,i.kt)("inlineCode",{parentName:"li"},"toManaged(finalizer)")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"withFinalizer(finalizer)"),":")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"- effect.toManaged(finalizer)\n+ effect.withFinalizer(finalizer)\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"val effect: ZIO[Any, IOException, FileInputStream] = ???\n- effect.toManaged(is => ZIO.succeed(is.close))\n+ effect.withFinalizer(is => ZIO.succeed(is.close()))\n")),(0,i.kt)("p",null,"Finally, let's try a full example of converting a ZManaged codebase to the Scoped one. Assume we have written the following ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer")," function in ZIO 1.x using ",(0,i.kt)("inlineCode",{parentName:"p"},"ZManaged"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.blocking._\n\nimport java.io._\n\ndef close(resource: Closeable): URIO[Blocking, Unit] =\n  effectBlockingIO(resource.close()).orDie\n\ndef is(file: String): ZManaged[Blocking, IOException, FileInputStream] =\n  ZManaged.make(effectBlockingIO(new FileInputStream(file)))(close)\n\ndef os(file: String): ZManaged[Blocking, IOException, FileOutputStream] =\n  ZManaged.make(effectBlockingIO(new FileOutputStream(file)))(close)\n\ndef copy(\n    from: FileInputStream,\n    to: FileOutputStream\n): ZIO[Blocking, IOException, Unit] =\n  effectBlockingIO {\n    val buf = new Array[Byte](1024)\n    var length = 0\n    length = from.read(buf)\n\n    while (length > 0) {\n      to.write(buf, 0, length)\n      length = from.read(buf)\n    }\n  }\n\ndef transfer(from: String, to: String): ZIO[Blocking, IOException, Unit] = {\n  val resource = for {\n    from <- is(from)\n    to   <- os(to)\n    _    <- copy(from, to).toManaged_\n  } yield ()\n  resource.useNow\n}\n")),(0,i.kt)("p",null,"As of ZIO 2.x, we should rewrite it as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nimport java.io._\n\ndef close(resource: Closeable): UIO[Unit] =\n  ZIO.attempt(resource.close()).orDie\n\ndef is(file: String): ZIO[Scope, IOException, FileInputStream] =\n  ZIO.acquireRelease(ZIO.attemptBlockingIO(new FileInputStream(file)))(close)\n\ndef os(file: String): ZIO[Scope, IOException, FileOutputStream] =\n  ZIO.acquireRelease(ZIO.attemptBlockingIO(new FileOutputStream(file)))(close)\n\ndef copy(\n    from: FileInputStream,\n    to: FileOutputStream\n): IO[IOException, Unit] =\n  ZIO.attemptBlockingIO(???)\n\ndef transfer(from: String, to: String): IO[Throwable, Unit] =\n  ZIO.scoped {\n    for {\n      from <- is(from)\n      to   <- os(to)\n      _    <- copy(from, to)\n    } yield ()\n  }\n")),(0,i.kt)("p",null,"As we can see, the migration is quite straightforward, and it doesn't require much extra work."),(0,i.kt)("h2",{id:"simplification-of-concurrent-data-types"},"Simplification of Concurrent Data Types"),(0,i.kt)("p",null,"Even though highly polymorphic versions of ZIO concurrent data structures (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"ZRef"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ZQueue"),") were elegant, they were used rarely. There was also some cost associated with polymorphism, such as errors, readability, and maintainability."),(0,i.kt)("p",null,"Therefore, we simplified these data structures by specializing them in their more monomorphic versions without significant loss of features:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.x (removed)"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZRef[+EA, +EB, -A, +B]")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Ref[A]"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZTRef[+EA, +EB, -A, +B]")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TRef[A]"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZRefM[-RA, -RB, +EA, +EB, -A, +B]")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Ref.Synchronized[A]"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZQueue[-RA, -RB, +EA, +EB, -A, +B]")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Queue[A]"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZHub[-RA, -RB, +EA, +EB, -A, +B]")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Hub[A]"))))),(0,i.kt)("h2",{id:"ref"},"Ref"),(0,i.kt)("p",null,"ZIO 2.x unifies ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"RefM"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"RefM")," becomes a subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref")," that has additional capabilities (i.e. the ability to perform effects within the operations) at some cost to performance:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"RefM")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Ref.Synchronized"))))),(0,i.kt)("p",null,"As the ",(0,i.kt)("inlineCode",{parentName:"p"},"RefM")," is renamed to ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref.Synchronized"),"; now the ",(0,i.kt)("inlineCode",{parentName:"p"},"Synchronized")," is a subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref"),". This change allows a ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref.Synchronized")," to be used anywhere a ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref")," is currently being used."),(0,i.kt)("p",null,"To perform the migration, after renaming these types to the newer ones (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"RefM")," renamed to ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref.Synchronized"),") we should perform the following method renames:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"RefM#dequeueRef")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.stream.SubscriptionRef#changes"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"RefM#getAndUpdate")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Ref.Synchronized#getAndUpdateZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"RefM#getAndUpdateSome")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Ref.Synchronized#getAndUpdateSomeZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"RefM#modify")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Ref.Synchronized#modifyZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"RefM#modifySome")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Ref.Synchronized#modifySomeZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"RefM#update")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Ref.Synchronized#updateZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"RefM#updateAndGet")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Ref.Synchronized#updateAndGetZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"RefM#updateSome")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Ref.Synchronized#updateSomeZIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"RefM#updateSomeAndGet")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Ref.Synchronized#updateSomeAndGetZIO"))))),(0,i.kt)("h2",{id:"semaphore-and-tsemaphore"},"Semaphore and TSemaphore"),(0,i.kt)("p",null,"There is a slight change on ",(0,i.kt)("inlineCode",{parentName:"p"},"TSemaphore#withPermit")," method. In ZIO 2.x, instead of accepting ",(0,i.kt)("inlineCode",{parentName:"p"},"STM")," values, it accepts only ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," values and returns the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," value."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"th"},"withPermit")),(0,i.kt)("th",{parentName:"tr",align:null},"Input"),(0,i.kt)("th",{parentName:"tr",align:null},"Output"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ZIO 1.x"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"STM[E, B]")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"STM[E, B]"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ZIO 2.x"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO[R, E, A]")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO[R, E, A]"))))),(0,i.kt)("h2",{id:"queue"},"Queue"),(0,i.kt)("p",null,"In ZIO 2.x, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Queue")," uses ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk")," consistently with other ZIO APIs like ZIO Streams. This will avoid unnecessary conversions between collection types, particularly for streaming applications where streams use ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk")," internally, but bulk take operations previously returned a ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," on ",(0,i.kt)("inlineCode",{parentName:"p"},"Queue"),"."),(0,i.kt)("p",null,"Here is a list of affected APIs: ",(0,i.kt)("inlineCode",{parentName:"p"},"takeAll"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"takeUpTo"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"takeBetween"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"takeN"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafePollAll"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafePollN"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafeOfferAll"),". Let's see an example:"),(0,i.kt)("p",null,"ZIO 1.x:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val taken: UIO[List[Int]] = for {\n  queue <- Queue.bounded[Int](100)\n  _     <- queue.offer(10)\n  _     <- queue.offer(20)\n  list  <- queue.takeUpTo(5)\n} yield list\n")),(0,i.kt)("p",null,"ZIO 2.x:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val taken: UIO[Chunk[Int]] = for {\n  queue <- Queue.bounded[Int](100)\n  _     <- queue.offer(10)\n  _     <- queue.offer(20)\n  chunk <- queue.takeUpTo(5)\n} yield chunk\n")),(0,i.kt)("h2",{id:"zio-test"},"ZIO Test"),(0,i.kt)("h3",{id:"zspec"},"ZSpec"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ZSpec")," data type has been renamed to ",(0,i.kt)("inlineCode",{parentName:"p"},"Spec"),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZSpec")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Spec"))))),(0,i.kt)("p",null,"So without any special effort, whenever we use ",(0,i.kt)("inlineCode",{parentName:"p"},"ZSpec")," we should change it to ",(0,i.kt)("inlineCode",{parentName:"p"},"Spec"),", e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},'- val myspec: ZSpec[Any, Nothing] =\n+ val myspec: Spec[Any, Nothing] =\n  test("my spec") {\n    assertTrue(true)\n  }\n')),(0,i.kt)("h3",{id:"sharing-layers-between-specs"},"Sharing Layers between Specs"),(0,i.kt)("p",null,'In ZIO 1.x, in order to share costly layers between specs, you needed a "Master" spec that would invoke test code from individual Spec classes.\nIn ZIO 2.x, sharing layers is much simpler.\nUse ',(0,i.kt)("inlineCode",{parentName:"p"},"ZIOSpec[YourSharedType]")," and plug your layer into the ",(0,i.kt)("inlineCode",{parentName:"p"},"bootstrap")," field."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\nclass SharedService()\n\nobject Layers {\n  val sharedLayer = \n    ZLayer.succeed(new SharedService())\n}\n\nobject UseSharedLayerA extends ZIOSpec[SharedService]{\n  override def spec =\n    test("use the shared layer in test A") {\n      assertCompletes\n    }\n\n  override def bootstrap= Layers.sharedLayer\n}\n\nobject UseSharedLayerB extends ZIOSpec[SharedService]{\n  override def spec =\n    test("use the shared layer in test B") {\n      assertCompletes\n    }\n\n  override def bootstrap = Layers.sharedLayer\n}\n')),(0,i.kt)("p",null,"Then use the standard"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"sbt test\n")),(0,i.kt)("p",null,"in order to run the tests."),(0,i.kt)("p",null,"Note - If you assign the results of a function call to ",(0,i.kt)("inlineCode",{parentName:"p"},"bootstrap"),", like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nclass SharedService()\n\nobject LayerBuilder {\n  def createLayer() = ZLayer.succeed(new SharedService())\n}\n\nobject NotUsingSharedLayerA extends ZIOSpec[SharedService]{\n  override def spec =\n    test("use the shared layer in test A") {\n      assertCompletes\n    }\n\n  override def bootstrap = LayerBuilder.createLayer()\n}\n\nobject NotUsingSharedLayerB extends ZIOSpec[SharedService]{\n  override def spec =\n    test("use the shared layer in test B") {\n      assertCompletes\n    }\n\n  override def bootstrap = LayerBuilder.createLayer()\n}\n')),(0,i.kt)("p",null,"These Specs will ",(0,i.kt)("em",{parentName:"p"},"not")," share the same instance, as they are different references."),(0,i.kt)("h3",{id:"smart-constructors"},"Smart Constructors"),(0,i.kt)("p",null,"By introducing smart constructors, we do not longer have the ",(0,i.kt)("inlineCode",{parentName:"p"},"testM")," function to create effectful test suits. Instead, we should use the ",(0,i.kt)("inlineCode",{parentName:"p"},"test")," function:"),(0,i.kt)("p",null,"ZIO 1.x:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'suite("Ref") {\n  testM("updateAndGet") {\n    val result = Ref.make(0).flatMap(_.updateAndGet(_ + 1))\n    assertM(result)(Assertion.equalTo(1))\n  }\n}\n')),(0,i.kt)("p",null,"ZIO 2.x:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'suite("Ref") {\n  test("updateAndGet") {\n    val result = Ref.make(0).flatMap(_.updateAndGet(_ + 1))\n    assertZIO(result)(Assertion.equalTo(1))\n  }\n}\n')),(0,i.kt)("p",null,"In ZIO 2.x, when creating a test suite, it's not important whether we are testing pure or effectful code. ",(0,i.kt)("inlineCode",{parentName:"p"},"testM")," was removed, and we can unifromly use ",(0,i.kt)("inlineCode",{parentName:"p"},"test")," in both cases."),(0,i.kt)("h3",{id:"unification-of-assertion-and-assertionm"},"Unification of ",(0,i.kt)("inlineCode",{parentName:"h3"},"Assertion")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"AssertionM")),(0,i.kt)("p",null,"In ZIO 2.x, ",(0,i.kt)("inlineCode",{parentName:"p"},"Assertion")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"AssertionM")," were unified to a single type, ",(0,i.kt)("inlineCode",{parentName:"p"},"Assertion"),", so ",(0,i.kt)("inlineCode",{parentName:"p"},"AssertionM")," was removed. In ZIO 2.x, instead of writing effectful assertions (",(0,i.kt)("inlineCode",{parentName:"p"},"AssertionM"),") and then asserting workflows, we should perform workflows and then simply assert the result of the workflow."),(0,i.kt)("p",null,"Assume we have written the following test in ZIO 1.x:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'testM("Effectful Assertion ZIO 1.x") {\n  def myEffectfulAssertion[Int](reference: Int): AssertionM[Int] = ???\n\n  val sut = ZIO.effect(???)\n  assertM(sut)(effectfulAssertion(5))\n}\n')),(0,i.kt)("p",null,"We can extract effectful operations from the effectful assertion and then perform the assertion like below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'test("Effectful Assertion ZIO 2.x") {\n  def myAssertion[Int](reference: Int): Assertion[Int] = ???\n  \n  val res = for {\n    sut <- ZIO.effect(???)\n    res <- extractedOperations(sut)\n  } yield assert(res)(myAssertion(5))\n}\n')),(0,i.kt)("h3",{id:"smart-assertion"},"Smart Assertion"),(0,i.kt)("p",null,"ZIO 2.x introduced a new test method, named ",(0,i.kt)("inlineCode",{parentName:"p"},"assertTrue")," which allows us to assert an expected behavior using ordinary Scala expressions that return ",(0,i.kt)("inlineCode",{parentName:"p"},"Boolean")," values instead of specialized assertion operators."),(0,i.kt)("p",null,"So instead of writing following test assertions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val list   = List(1, 2, 3, 4, 5)\nval number = 3\nval option = Option.empty[Int]\n\nsuite("ZIO 1.x Test Assertions")(\n  test("contains")(assert(list)(Assertion.contains(5))),\n  test("forall")(assert(list)(Assertion.forall(Assertion.assertion("even")(actual => actual % 2 == 0)))),\n  test("less than")(assert(number)(Assertion.isLessThan(0))),\n  test("isSome")(assert(option)(Assertion.equalTo(Some(3))))\n)\n')),(0,i.kt)("p",null,"We can write them like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'suite("ZIO 2.x SmartAssertions")(\n  test("contains")(assertTrue(list.contains(5))),\n  test("forall")(assertTrue(list.forall(_ % 2 == 0))),\n  test("less than")(assertTrue(number < 0)),\n  test("isSome")(assertTrue(option.get == 3))\n)\n')),(0,i.kt)("p",null,"Smart Assertions are extremely expressive, so when a test fails:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"They highlight the exact section of the syntax with the path leading up to the left-hand side of the assertion that causes the failure."),(0,i.kt)("li",{parentName:"ul"},"They have the strong and nice diffing capability which shows where our expectation varies."),(0,i.kt)("li",{parentName:"ul"},"When using partial functions in test cases there is no problem with the happy path, but if something goes wrong, it is a little annoying to find what went wrong. But smart assertions are descriptive, e.g. when we call ",(0,i.kt)("inlineCode",{parentName:"li"},"Option#get")," to an optional value that is ",(0,i.kt)("inlineCode",{parentName:"li"},"None")," the test fails with a related error message: ",(0,i.kt)("inlineCode",{parentName:"li"},"Option was None")),(0,i.kt)("li",{parentName:"ul"},"They have lots of domain specific errors that talk to us in a language that we understand.")),(0,i.kt)("h3",{id:"compositional-specs"},"Compositional Specs"),(0,i.kt)("p",null,"In ZIO 1.x, we cannot compose specs directly, although we can combine all children's specs via the suite itself:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val fooSuite = suite("Foo")(fooSpec)\nval barSuite = suite("Bar")(barSpec)\nval bazSuite = suite("Baz")(bazSpec)\n\nval bigSuite = suite("big suite")(fooSuite, barSuite, bazSuite)\n')),(0,i.kt)("p",null,"Now in ZIO 2.x, we can compose two suites using ",(0,i.kt)("em",{parentName:"p"},"binary composition operator")," without having to unnecessarily nest them inside another suite just for purpose of composition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val bigSuite = fooSuite + barSuite + bazSuite\n")),(0,i.kt)("h2",{id:"zio-streams"},"ZIO Streams"),(0,i.kt)("p",null,"ZIO Streams 2.x does not include any significant API changes. Almost the same code we have for ZIO Stream 1.x will continue working, so we don't need to relearn any APIs. Even though a good level of source compatibility has been maintained, some API elements have been changed."),(0,i.kt)("p",null,"So far, before ZIO 2.0, ZIO Stream has included three main abstractions:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"ZStream"))," \u2014 represents the source of elements"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"ZSink"))," \u2014 represents consumers of elements that can be composed together to create composite consumers"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"ZTransducer"))," \u2014 represents generalized stateful and effectful stream processing")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"ZIO Streams 1.x",src:n(23496).Z,width:"554",height:"146"})),(0,i.kt)("p",null,"In ZIO 2.0, we added an underlying abstraction called ",(0,i.kt)("inlineCode",{parentName:"p"},"Channel"),". Channels are underlying both ",(0,i.kt)("inlineCode",{parentName:"p"},"Stream")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Sink"),", so it's an abstraction that unifies everything in ZIO Streams."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"ZChannel",src:n(19562).Z,width:"601",height:"193"})),(0,i.kt)("p",null,"Channels are nexuses of I/O operations, which support both reading and writing:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Channel")," can write some elements to the ",(0,i.kt)("em",{parentName:"p"},"output"),", and it can terminate with some sort of ",(0,i.kt)("em",{parentName:"p"},"done")," value. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Channel")," uses this ",(0,i.kt)("em",{parentName:"p"},"done")," value to notify the downstream ",(0,i.kt)("inlineCode",{parentName:"p"},"Channel")," that its emission of elements finished. In ZIO 2.x, ",(0,i.kt)("inlineCode",{parentName:"p"},"ZStream")," is encoded as the output side of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Channel"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Channel")," can read from its input, and it can also terminate with some sort of ",(0,i.kt)("em",{parentName:"p"},"done")," value that is an upstream result. A ",(0,i.kt)("inlineCode",{parentName:"p"},"Channel")," has an ",(0,i.kt)("em",{parentName:"p"},"input type"),", and an ",(0,i.kt)("em",{parentName:"p"},"input done type"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"Channel")," uses the ",(0,i.kt)("em",{parentName:"p"},"done")," value to determine when the upstream ",(0,i.kt)("inlineCode",{parentName:"p"},"Channel")," finishes its emission. In ZIO 2.x, ",(0,i.kt)("inlineCode",{parentName:"p"},"ZSink")," is encoded as the input side of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Channel"),"."))),(0,i.kt)("p",null,"So we can say that streams are the output side and sinks are the input side of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Channel"),". What about the middle part? In ZIO 1.x, this used to be known as the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZTransducer"),". Transducers were great for writing high-performance codecs (e.g. compression). They were really just a specialization of sinks. We have added transducers because things were not sufficiently efficient using sinks. If we were to write streaming codecs using sinks, they could be quite slow."),(0,i.kt)("p",null,"In ZIO 2.x, we removed the transducers. Instead, we realized we need something else for the middle part, and now it's called a ",(0,i.kt)("inlineCode",{parentName:"p"},"Pipeline")," in ZIO 2.x. Pipelines accept a stream as input and return the transformed stream as output."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"ZIO Streams 2.x",src:n(79007).Z,width:"554",height:"146"})),(0,i.kt)("p",null,"Pipelines are basically an abstraction for composing a bunch of operations together that can be later applied to a stream. For example, we can create a pipeline that reads bytes, decodes them to a UTF-8 string, splits that into lines, and then splits on commas. That is a very simple CSV parsing pipeline which we can later use by piping other streams into it. "),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO Streams 1.x"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO Streams 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZChannel"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZStream")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZStream")," (backed by ",(0,i.kt)("inlineCode",{parentName:"td"},"ZChannel"),")")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZSink")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZSink")," (backed by ",(0,i.kt)("inlineCode",{parentName:"td"},"ZChannel"),")")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZTransducer")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZPipeline"))))),(0,i.kt)("h2",{id:"zio-schedules"},"ZIO Schedules"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Schedule.jittered")," in ZIO 1 is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"Schedule.jittered(0.0, 1.0)"),". In ZIO 2 this changed to ",(0,i.kt)("inlineCode",{parentName:"p"},"Schedule.jittered(0.8, 1.2)"),"."),(0,i.kt)("p",null,"In ZIO 1 the average throughput of the updated schedule was twice the original schedule. In ZIO 2 the average throughput of the updated schedule is the same as the original schedule."),(0,i.kt)("p",null,"The new behavior is more in line with the definition of 'jitter' as used in signal processing.\nEven so, ",(0,i.kt)("a",{parentName:"p",href:"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/"},"research")," shows that ",(0,i.kt)("inlineCode",{parentName:"p"},"Schedule.jittered(0.0, 1.0)")," is better for retrying."),(0,i.kt)("h2",{id:"zio-services"},"ZIO Services"),(0,i.kt)("p",null,"There are two significant changes in ZIO Services:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"All ZIO services moved to the ",(0,i.kt)("inlineCode",{parentName:"p"},"zio")," package:"),(0,i.kt)("table",{parentName:"li"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.blocking.Blocking")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#blocking-service"},"Removed"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.clock.Clock")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.Clock"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.console.Console")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.Console"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.random.Random")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.Random"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.system.System")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.System"))))),(0,i.kt)("p",{parentName:"li"},"And their live implementations renamed and moved to a new path:"),(0,i.kt)("table",{parentName:"li"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.Clock.Service.live")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.Clock.ClockLive"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.Console.Service.live")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.Console.ConsoleLive"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.System.Service.live")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.System.SystemLive"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.Random.Service.live")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.Random.RandomLive"))))))),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"In ZIO 2.0 all type aliases like ",(0,i.kt)("inlineCode",{parentName:"li"},"type Foo = Has[Foo.Service]")," were removed. So when accessing services instead of ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.service[Foo.Service]")," we now do ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.service[Foo]"),".")),(0,i.kt)("h3",{id:"blocking-service"},"Blocking Service"),(0,i.kt)("p",null,"Since there is rarely a need to use a separate blocking thread pool, ZIO 2.0 created ",(0,i.kt)("em",{parentName:"p"},"one global blocking pool"),", and removed the Blocking service from ",(0,i.kt)("inlineCode",{parentName:"p"},"ZEnv")," and the built-in services."),(0,i.kt)("p",null,"All blocking operations were moved to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," data type:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zio.blocking.Blocking.*")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.*"))))),(0,i.kt)("p",null,"With some renaming:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.x (",(0,i.kt)("inlineCode",{parentName:"th"},"zio.blocking.Blocking.*"),")"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x (",(0,i.kt)("inlineCode",{parentName:"th"},"ZIO.*"),")"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"effectBlocking")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlocking"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"effectBlockingCancelable")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlockingCancelable"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"effectBlockingIO")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlockingIO"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"effectBlockingInterrupt")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.attemptBlockingInterrupt"))))),(0,i.kt)("p",null,"Now we have all the blocking operations under the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," data type as below:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.attemptBlocking")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.attemptBlockingCancelable")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.attemptBlockingIO")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.attemptBlockingInterrupt")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.blocking")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.blockingExecutor"))),(0,i.kt)("p",null,"We can also provide a user-defined blocking executor in ZIO 2.x with the ",(0,i.kt)("inlineCode",{parentName:"p"},"Runtime#withBlockingExecutor")," operator that constructs a new ",(0,i.kt)("inlineCode",{parentName:"p"},"Runtime")," with the specified blocking executor."),(0,i.kt)("h3",{id:"clock-service"},"Clock Service"),(0,i.kt)("p",null,"There is a slight change in the Clock service; the return value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"currentDateTime"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"localDateTime")," methods changed from ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"UIO"),", so they do not longer throw ",(0,i.kt)("inlineCode",{parentName:"p"},"DateTimeException"),":"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Method Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Return Type (ZIO 1.x)"),(0,i.kt)("th",{parentName:"tr",align:null},"Return Type (ZIO 2.x)"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"currentDateTime")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"IO[OffsetDateTime]")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"UIO[OffsetDateTime]"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"localDateTime")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"IO[LocalDateTime]")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"UIO[LocalDateTime]"))))),(0,i.kt)("p",null,"In ZIO 2.0, without changing any API, the ",(0,i.kt)("em",{parentName:"p"},"retrying"),", ",(0,i.kt)("em",{parentName:"p"},"repetition"),", and ",(0,i.kt)("em",{parentName:"p"},"scheduling")," logic moved into the ",(0,i.kt)("inlineCode",{parentName:"p"},"Clock")," service."),(0,i.kt)("p",null,"Working with these three time-related APIs, always made us require ",(0,i.kt)("inlineCode",{parentName:"p"},"Clock")," as our environment. So by moving these primitives into the ",(0,i.kt)("inlineCode",{parentName:"p"},"Clock")," service, now we can directly call them via the ",(0,i.kt)("inlineCode",{parentName:"p"},"Clock")," service. This change solves a common anti-pattern in ZIO 1.0, whereby a middleware that uses ",(0,i.kt)("inlineCode",{parentName:"p"},"Clock")," via this retrying, repetition, or scheduling logic must provide the ",(0,i.kt)("inlineCode",{parentName:"p"},"Clock")," layer on every method invocation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'trait Journal {\n  def append(log: String): ZIO[Any, Throwable, Unit]\n}\n\ntrait Logger {\n  def log(line: String): UIO[Unit]\n}\n\ncase class JournalLoggerLive(clock: Clock, journal: Journal) extends Logger {\n  override def log(line: String): UIO[Unit] = {\n    for {\n      current <- clock.currentDateTime\n      _ <- journal.append(s"$current--$line")\n        .retry(Schedule.exponential(2.seconds))\n        .provideEnvironment(ZEnvironment(clock))\n        .orDie\n    } yield ()\n  }\n}\n')),(0,i.kt)("p",null,"In ZIO 2.0, we can implement the logger service with a better ergonomic:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class JournalLoggerLive(clock: Clock, journal: Journal) extends Logger {\n  override def log(line: String): UIO[Unit] = {\n    for {\n      current <- clock.currentDateTime\n      _       <- journal.append(s"$current--$line").retry(Schedule.exponential(2.seconds)).orDie\n    } yield ()\n  }\n}\n')),(0,i.kt)("p",null,"Note that the ZIO API didn't change, but the ",(0,i.kt)("inlineCode",{parentName:"p"},"Clock")," trait became a bigger one, having more clock-related methods."),(0,i.kt)("h3",{id:"console-service"},"Console Service"),(0,i.kt)("p",null,"Method names in the ",(0,i.kt)("em",{parentName:"p"},"Console")," service were renamed to more readable names:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 1.x"),(0,i.kt)("th",{parentName:"tr",align:null},"ZIO 2.x"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"putStr")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"print"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"putStrErr")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"printError"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"putStrLn")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"printLine"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"putStrLnErr")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"printLineError"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"getStrLn")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"readLine"))))),(0,i.kt)("h2",{id:"other-new-features"},"Other New Features"),(0,i.kt)("h3",{id:"smart-constructors-1"},"Smart Constructors"),(0,i.kt)("p",null,"Every data type in ZIO (",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ZStream"),", etc.) has a variety of constructor functions that are designed to ",(0,i.kt)("em",{parentName:"p"},"up convert")," some weaker type into the target type. Typically, these converter functions are named ",(0,i.kt)("inlineCode",{parentName:"p"},"fromXYZ"),", e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.fromEither"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ZStream.fromZIO"),", etc."),(0,i.kt)("p",null,"While these are precise, ZIO 2.0 provides the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.from")," constructor which can intelligently choose the most likely constructor based on the input type. So instead of writing ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.fromEither(Right(3))")," we can easily write ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.from(Right(3))"),". Let's try some of them:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.stream.ZStream\n\nZIO.fromOption(Some("Ok!"))\nZIO.from(Some("Ok!"))\n\nZIO.fromEither(Right(3))\nZIO.from(Right(3))\n\nZIO.fromFiber(Fiber.succeed("Ok!"))\nZIO.from(Fiber.succeed("Ok!"))\n\nZStream.fromIterable(List(1,2,3))  \nZStream.from(List(1,1,3))\n\nZStream.fromChunk(Chunk(1,2,3))\nZStream.from(Chunk(1,2,3))\n\nZStream.fromIterableZIO(ZIO.succeed(List(1,2,3)))\nZStream.from(ZIO.succeed(List(1,2,3)))\n')),(0,i.kt)("h3",{id:"zstate"},"ZState"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ZState")," is a new data type that ZIO 2.0 introduced:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait ZState[S] {\n  def get: UIO[S]\n  def set(s: S): UIO[Unit]\n  def update(f: S => S): UIO[Unit]\n}\n")),(0,i.kt)("p",null,"We can ",(0,i.kt)("inlineCode",{parentName:"p"},"set"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"get"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"update")," the state which is part of the ZIO environment using ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.setState"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.getState"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.updateState")," operations:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nobject ZStateExample extends zio.ZIOAppDefault {\n  final case class MyState(counter: Int)\n\n  val app = for {\n    _     <- ZIO.updateState[MyState](state => state.copy(counter = state.counter + 1))\n    count <- ZIO.getStateWith[MyState](_.counter)\n    _     <- Console.printLine(count)\n  } yield count\n\n  def run = app.provide(ZState.initial(MyState(0)))\n}\n")),(0,i.kt)("h3",{id:"hub"},"Hub"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Hub")," is a new concurrent data structure like ",(0,i.kt)("inlineCode",{parentName:"p"},"Queue"),". While ",(0,i.kt)("inlineCode",{parentName:"p"},"Queue")," solves the problem of ",(0,i.kt)("em",{parentName:"p"},"distributing")," messages to multiple consumers, ",(0,i.kt)("inlineCode",{parentName:"p"},"Hub")," solves the problem of ",(0,i.kt)("em",{parentName:"p"},"broadcasting")," the same message to multiple consumers."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Hub",src:n(96574).Z,width:"925",height:"364"})),(0,i.kt)("p",null,"Here is an example of broadcasting messages to multiple subscribers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  hub <- Hub.bounded[String](requestedCapacity = 2)\n  s1 = hub.subscribe\n  s2 = hub.subscribe\n  _ <- ZIO.scoped {\n    s1.zip(s2).flatMap { case (left, right) =>\n      for {\n        _ <- hub.publish("Hello from a hub!")\n        _ <- left.take.flatMap(Console.printLine(_))\n        _ <- right.take.flatMap(Console.printLine(_))\n      } yield ()\n    }\n  }\n} yield ()\n')),(0,i.kt)("p",null,"Visit the ",(0,i.kt)("a",{parentName:"p",href:"/reference/concurrency/hub"},"Hub")," page to learn more about it."),(0,i.kt)("h3",{id:"zio-aspects"},"ZIO Aspects"),(0,i.kt)("p",null,"We introduced ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIOAspect")," which enables us to modify the existing ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," effect with some additional aspects like debugging, tracing, retrying, and logging:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val myApp: ZIO[Random, Nothing, String] =\n  ZIO.ifZIO(\n    Random.nextIntBounded(10) @@ ZIOAspect.debug map (_ % 2 == 0)\n  )(\n    onTrue = ZIO.succeed("Hello!"), \n    onFalse = ZIO.succeed("Good Bye!")) @@ ZIOAspect.debug @@ ZIOAspect.logged("result")\n    \n// Sample Output:     \n// 2\n// Hello!\n// timestamp=2021-09-05T15:32:56.705901Z level=INFO thread=#2 message="result: Hello!" file=ZIOAspect.scala line=74 class=zio.ZIOAspect$$anon$4 method=apply\n')),(0,i.kt)("h3",{id:"debugging"},"Debugging"),(0,i.kt)("p",null,"ZIO 2.x introduces the ",(0,i.kt)("inlineCode",{parentName:"p"},"debug")," method that is useful when we want to print something to the console for debugging purposes without introducing additional environmental requirements or error types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val myApp: ZIO[Random, Nothing, String] =\n  ZIO\n    .ifZIO(\n      Random.nextIntBounded(10) debug("random") map (_ % 2 == 0)\n    )(\n      onTrue = ZIO.succeed("Hello!"),\n      onFalse = ZIO.succeed("Good Bye!")\n    )\n    .debug("result")\n// Sample Output\n// random: 2\n// result: Hello!\n')),(0,i.kt)("h3",{id:"logging"},"Logging"),(0,i.kt)("p",null,"ZIO 2.x supports a lightweight built-in logging facade that standardizes the interface for logging functionality. So it doesn't replace existing logging libraries, but also we can plug it into one of the existing logging backends."),(0,i.kt)("p",null,"We can easily log using the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.log")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.log("Application started!")\n')),(0,i.kt)("p",null,"To log with a specific log-level, we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO.logLevel")," combinator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.logLevel(LogLevel.Warning) {\n  ZIO.log("The response time exceeded its threshold!")\n}\n')),(0,i.kt)("p",null,"Or we can use the following functions directly:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.logDebug")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.logError")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.logFatal")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.logInfo")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.logWarning"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.logError("File does not exist: ~/var/www/favicon.ico")\n')),(0,i.kt)("p",null,"It also supports logging spans:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.logSpan("myspan") {\n  ZIO.sleep(1.second) *> ZIO.log("The job is finished!")\n}\n')),(0,i.kt)("p",null,"ZIO Logging calculates the running duration of that span, and includes that in the logging data associating to its span label."),(0,i.kt)("h3",{id:"compile-time-execution-tracing"},"Compile-time Execution Tracing"),(0,i.kt)("p",null,"ZIO 1.x's execution trace is not as useful as it could be, because it contains tracing information for internal ZIO operators that is not very helpful, when trying to understand, where an error occurred."),(0,i.kt)("p",null,"Let's say we have the following application in ZIO 1.x:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.console.Console\n\nobject TracingExample extends zio.App {\n\n  def doSomething(input: Int): ZIO[Console, String, Unit] =\n    for {\n      _ <- console.putStrLn(s"Do something $input").orDie // line number 8\n      _ <- ZIO.fail("Boom!")\n      _ <- console.putStrLn("Finished my job").orDie\n    } yield ()\n\n  def myApp: ZIO[Console, String, Unit] =\n    for {\n      _ <- console.putStrLn("Hello!").orDie\n      _ <- doSomething(5)\n      _ <- console.putStrLn("Bye Bye!").orDie\n    } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n')),(0,i.kt)("p",null,"The output would be something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Hello!\nDo something 5\nFiber failed.\nA checked error was not handled.\nBoom!\n\nFiber:Id(1634884059941,1) was supposed to continue to:\n  a future continuation at TracingExample$.myApp(TracingExample.scala:16)\n  a future continuation at zio.ZIO.exitCode(ZIO.scala:606)\n\nFiber:Id(1634884059941,1) execution trace:\n  at TracingExample$.doSomething(TracingExample.scala:8)\n  at zio.ZIO.orDieWith(ZIO.scala:1118)\n  at zio.ZIO.refineOrDieWith(ZIO.scala:1497)\n  at zio.console.package$Console$Service$.putStrLn(package.scala:44)\n  at zio.console.package$.putStrLn(package.scala:88)\n  at TracingExample$.myApp(TracingExample.scala:15)\n  at zio.ZIO.orDieWith(ZIO.scala:1118)\n  at zio.ZIO.refineOrDieWith(ZIO.scala:1497)\n  at zio.console.package$Console$Service$.putStrLn(package.scala:44)\n  at zio.console.package$.putStrLn(package.scala:88)\n\nFiber:Id(1634884059941,1) was spawned by:\n\nFiber:Id(1634884059516,0) was supposed to continue to:\n  a future continuation at zio.App.main(App.scala:59)\n  a future continuation at zio.App.main(App.scala:58)\n\nFiber:Id(1634884059516,0) ZIO Execution trace: <empty trace>\n\nFiber:Id(1634884059516,0) was spawned by: <empty trace>\n")),(0,i.kt)("p",null,"The execution trace is informative, but it doesn't lead us to the exact point, where the failure happened. It's a little hard to see what is going on here. "),(0,i.kt)("p",null,"Let's rewrite the previous example in ZIO 2.x:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject TracingExample extends ZIOAppDefault {\n\n  def doSomething(input: Int): ZIO[Any, String, Unit] =\n    for {\n      _ <- Console.printLine(s"Do something $input").orDie\n      _ <- ZIO.fail("Boom!") // line number 8\n      _ <- Console.printLine("Finished my job").orDie\n    } yield ()\n\n  def myApp: ZIO[Any, String, Unit] =\n    for {\n      _ <- Console.printLine("Hello!").orDie\n      _ <- doSomething(5)   // line number 15\n      _ <- Console.printLine("Bye Bye!").orDie\n    } yield ()\n\n  def run = myApp\n}\n')),(0,i.kt)("p",null,"The output is more descriptive than in ZIO 1.x. It is similar to a Java stacktrace:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Hello!\nDo something 5\ntimestamp=2021-12-19T08:25:09.372926403Z level=ERROR thread=#zio-fiber-1639902309 message="Exception in thread "zio-fiber-1639902309" java.lang.String: Boom!\n    at zio.examples.TracingExample.doSomething(TracingExample.scala:8)\n    at zio.examples.TracingExample.myApp(TracingExample.scala:15)"\n')),(0,i.kt)("p",null,"As we see, the first line of the execution trace points to the exact location in the source code which causes the failure (",(0,i.kt)("inlineCode",{parentName:"p"},'ZIO.fail("Boom!")'),") that is line number 8."),(0,i.kt)("p",null,"In ZIO 2.x, tracing is not optional, and unlike in ZIO 1.x, it is impossible to disable async tracing, either globally, or for specific effects. ZIO now always generates async stack traces, and it is impossible to turn this feature off, either at the global level or at the level of individual effects. Since nearly all users were running ZIO with tracing turned on, this change should have minimal impact on ZIO applications."),(0,i.kt)("p",null,"Another improvement about ZIO tracing is its performance. Tracing in ZIO 1.x slows down the application performance by two times. In ZIO 1.x, we wrap and unwrap every combinator at runtime to be able to trace the execution. While it is happening on the runtime, it takes a lot of allocations which all need to be garbage collected afterwards adding a huge amount of complexity at runtime."),(0,i.kt)("p",null,"Some users turned off tracing to achieve better performance, but that results in losing the ability to trace the application, when something breaks."),(0,i.kt)("p",null,"In ZIO 2.x, we moved execution tracing from the runtime to the compile-time. This is done by capturing tracing information from the source code at compile time using macros. Most tracing information is pre-allocated at startup, and never needs to be garbage collected. As a result, we end up with much better performance in execution tracing."))}c.isMDXComponent=!0},96574:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/hub-e82fffbd91cd37dc4a3aac858d6744e4.svg"},23496:(e,t,n)=>{n.d(t,{Z:()=>a});const a="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjwhLS0gR2VuZXJhdGVkIGJ5IE1pY3Jvc29mdCBWaXNpbywgU1ZHIEV4cG9ydCB6aW8tc3RyZWFtcy0xLnN2ZyBQYWdlLTEgLS0+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sbnM6ZXY9Imh0dHA6Ly93d3cudzMub3JnLzIwMDEveG1sLWV2ZW50cyIKCQl4bWxuczp2PSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3Zpc2lvLzIwMDMvU1ZHRXh0ZW5zaW9ucy8iIHdpZHRoPSI1Ljc2NzM2aW4iIGhlaWdodD0iMS41MTczNmluIgoJCXZpZXdCb3g9IjAgMCA0MTUuMjUgMTA5LjI1IiB4bWw6c3BhY2U9InByZXNlcnZlIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiIGNsYXNzPSJzdDYiPgoJPHY6ZG9jdW1lbnRQcm9wZXJ0aWVzIHY6bGFuZ0lEPSIxMDMzIiB2OnZpZXdNYXJrdXA9ImZhbHNlIj4KCQk8djp1c2VyRGVmcz4KCQkJPHY6dWQgdjpuYW1lVT0ibXN2Tm9BdXRvQ29ubmVjdCIgdjp2YWw9IlZUMCgxKToyNiIvPgoJCTwvdjp1c2VyRGVmcz4KCTwvdjpkb2N1bWVudFByb3BlcnRpZXM+CgoJPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCTwhW0NEQVRBWwoJCS5zdDEge2ZpbGw6dXJsKCNncmFkMC00KTtzdHJva2U6IzAwMDAwMDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLXdpZHRoOjEuMjV9CgkJLnN0MiB7ZmlsbDojMDAwMDAwO2ZvbnQtZmFtaWx5OkNhbGlicmk7Zm9udC1zaXplOjEuNWVtfQoJCS5zdDMge21hcmtlci1lbmQ6dXJsKCNtcmtyNC0yMCk7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS13aWR0aDoxfQoJCS5zdDQge2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utb3BhY2l0eToxO3N0cm9rZS13aWR0aDowLjI4NDA5MDkwOTA5MDkxfQoJCS5zdDUge2ZpbGw6bm9uZTtzdHJva2U6bm9uZTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLXdpZHRoOjAuNzV9CgkJLnN0NiB7ZmlsbDpub25lO2ZpbGwtcnVsZTpldmVub2RkO2ZvbnQtc2l6ZToxMnB4O292ZXJmbG93OnZpc2libGU7c3Ryb2tlLWxpbmVjYXA6c3F1YXJlO3N0cm9rZS1taXRlcmxpbWl0OjN9CgldXT4KCTwvc3R5bGU+CgoJPGRlZnMgaWQ9IlBhdHRlcm5zX0FuZF9HcmFkaWVudHMiPgoJCTxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZDAtNCIgeDE9IjAiIHkxPSIwIiB4Mj0iMSIgeTI9IjAiIGdyYWRpZW50VHJhbnNmb3JtPSJyb3RhdGUoOTAgMC41IDAuNSkiPgoJCQk8c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmZmZmYiIHN0b3Atb3BhY2l0eT0iMSIvPgoJCQk8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNkOGQ4ZDgiIHN0b3Atb3BhY2l0eT0iMSIvPgoJCTwvbGluZWFyR3JhZGllbnQ+Cgk8L2RlZnM+Cgk8ZGVmcyBpZD0iTWFya2VycyI+CgkJPGcgaWQ9ImxlbmQ0Ij4KCQkJPHBhdGggZD0iTSAyIDEgTCAwIDAgTCAyIC0xIEwgMiAxICIgc3R5bGU9InN0cm9rZTpub25lIi8+CgkJPC9nPgoJCTxtYXJrZXIgaWQ9Im1ya3I0LTIwIiBjbGFzcz0ic3Q0IiB2OmFycm93VHlwZT0iNCIgdjphcnJvd1NpemU9IjIiIHY6c2V0YmFjaz0iNy4wNCIgcmVmWD0iLTcuMDQiIG9yaWVudD0iYXV0byIKCQkJCW1hcmtlclVuaXRzPSJzdHJva2VXaWR0aCIgb3ZlcmZsb3c9InZpc2libGUiPgoJCQk8dXNlIHhsaW5rOmhyZWY9IiNsZW5kNCIgdHJhbnNmb3JtPSJzY2FsZSgtMy41MiwtMy41MikgIi8+CgkJPC9tYXJrZXI+Cgk8L2RlZnM+Cgk8ZyB2Om1JRD0iMCIgdjppbmRleD0iMSIgdjpncm91cENvbnRleHQ9ImZvcmVncm91bmRQYWdlIj4KCQk8dGl0bGU+UGFnZS0xPC90aXRsZT4KCQk8djpwYWdlUHJvcGVydGllcyB2OmRyYXdpbmdTY2FsZT0iMSIgdjpwYWdlU2NhbGU9IjEiIHY6ZHJhd2luZ1VuaXRzPSIxOSIgdjpzaGFkb3dPZmZzZXRYPSI5IiB2OnNoYWRvd09mZnNldFk9Ii05Ii8+CgkJPHY6bGF5ZXIgdjpuYW1lPSJDb21tb24gSWNvbnMiIHY6aW5kZXg9IjAiLz4KCQk8djpsYXllciB2Om5hbWU9IkNvbm5lY3RvciIgdjppbmRleD0iMSIvPgoJCTx2OmxheWVyIHY6bmFtZT0iQ29udGFpbmVyIiB2OmluZGV4PSIyIi8+CgkJPGcgaWQ9InNoYXBlMS0xIiB2Om1JRD0iMSIgdjpncm91cENvbnRleHQ9InNoYXBlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxOC42MjUsLTE4LjYyNSkiPgoJCQk8dGl0bGU+U2hlZXQuMTwvdGl0bGU+CgkJCTxkZXNjPlpTdHJlYW08L2Rlc2M+CgkJCTx2OnRleHRCbG9jayB2Om1hcmdpbnM9InJlY3QoNCw0LDQsNCkiLz4KCQkJPHY6dGV4dFJlY3QgY3g9IjU0IiBjeT0iNzMuMjUiIHdpZHRoPSIxMDguMDEiIGhlaWdodD0iNzIiLz4KCQkJPHJlY3QgeD0iMCIgeT0iMzcuMjUiIHdpZHRoPSIxMDgiIGhlaWdodD0iNzIiIHJ4PSI5IiByeT0iOSIgY2xhc3M9InN0MSIvPgoJCQk8dGV4dCB4PSIyMy41MiIgeT0iNzguNjUiIGNsYXNzPSJzdDIiIHY6bGFuZ0lEPSIxMDMzIj48djpwYXJhZ3JhcGggdjpob3JpekFsaWduPSIxIi8+PHY6dGFiTGlzdC8+WlN0cmVhbTwvdGV4dD4JCTwvZz4KCQk8ZyBpZD0ic2hhcGUyLTYiIHY6bUlEPSIyIiB2Omdyb3VwQ29udGV4dD0ic2hhcGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1My42MjUsLTE4LjYyNSkiPgoJCQk8dGl0bGU+U2hlZXQuMjwvdGl0bGU+CgkJCTxkZXNjPlpUcmFuc2R1Y2VyPC9kZXNjPgoJCQk8djp0ZXh0QmxvY2sgdjptYXJnaW5zPSJyZWN0KDQsNCw0LDQpIi8+CgkJCTx2OnRleHRSZWN0IGN4PSI1NCIgY3k9IjczLjI1IiB3aWR0aD0iMTA4LjAxIiBoZWlnaHQ9IjcyIi8+CgkJCTxyZWN0IHg9IjAiIHk9IjM3LjI1IiB3aWR0aD0iMTA4IiBoZWlnaHQ9IjcyIiByeD0iOSIgcnk9IjkiIGNsYXNzPSJzdDEiLz4KCQkJPHRleHQgeD0iOC44MiIgeT0iNzguNjUiIGNsYXNzPSJzdDIiIHY6bGFuZ0lEPSIxMDMzIj48djpwYXJhZ3JhcGggdjpob3JpekFsaWduPSIxIi8+PHY6dGFiTGlzdC8+WlRyYW5zZHVjZXI8L3RleHQ+CQk8L2c+CgkJPGcgaWQ9InNoYXBlNS0xMCIgdjptSUQ9IjUiIHY6Z3JvdXBDb250ZXh0PSJzaGFwZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjg4LjYyNSwtMTguNjI1KSI+CgkJCTx0aXRsZT5TaGVldC41PC90aXRsZT4KCQkJPGRlc2M+WlNpbms8L2Rlc2M+CgkJCTx2OnRleHRCbG9jayB2Om1hcmdpbnM9InJlY3QoNCw0LDQsNCkiLz4KCQkJPHY6dGV4dFJlY3QgY3g9IjU0IiBjeT0iNzMuMjUiIHdpZHRoPSIxMDguMDEiIGhlaWdodD0iNzIiLz4KCQkJPHJlY3QgeD0iMCIgeT0iMzcuMjUiIHdpZHRoPSIxMDgiIGhlaWdodD0iNzIiIHJ4PSI5IiByeT0iOSIgY2xhc3M9InN0MSIvPgoJCQk8dGV4dCB4PSIzNC43NyIgeT0iNzguNjUiIGNsYXNzPSJzdDIiIHY6bGFuZ0lEPSIxMDMzIj48djpwYXJhZ3JhcGggdjpob3JpekFsaWduPSIxIi8+PHY6dGFiTGlzdC8+WlNpbms8L3RleHQ+CQk8L2c+CgkJPGcgaWQ9Imdyb3VwMTgtMTQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI2MS42MjUsLTQ1LjYyNSkiIHY6bUlEPSIxOCIgdjpncm91cENvbnRleHQ9Imdyb3VwIj4KCQkJPHRpdGxlPlNoZWV0LjE4PC90aXRsZT4KCQkJPGcgaWQ9InNoYXBlMTctMTUiIHY6bUlEPSIxNyIgdjpncm91cENvbnRleHQ9InNoYXBlIiB2OmxheWVyTWVtYmVyPSIxIj4KCQkJCTx0aXRsZT5EeW5hbWljIGNvbm5lY3RvcjwvdGl0bGU+CgkJCQk8cGF0aCBkPSJNMCAxMDAuMjUgTDE5Ljk2IDEwMC4yNSIgY2xhc3M9InN0MyIvPgoJCQk8L2c+CgkJPC9nPgoJCTxnIGlkPSJncm91cDE5LTIxIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjcuMDc1LC00Ny40MjUpIiB2Om1JRD0iMTkiIHY6Z3JvdXBDb250ZXh0PSJncm91cCI+CgkJCTx0aXRsZT5TaGVldC4xOTwvdGl0bGU+CgkJCTxnIGlkPSJzaGFwZTIwLTIyIiB2Om1JRD0iMjAiIHY6Z3JvdXBDb250ZXh0PSJzaGFwZSIgdjpsYXllck1lbWJlcj0iMSI+CgkJCQk8dGl0bGU+RHluYW1pYyBjb25uZWN0b3I8L3RpdGxlPgoJCQkJPHBhdGggZD0iTTAgMTAwLjI1IEwxOS45NiAxMDAuMjUiIGNsYXNzPSJzdDMiLz4KCQkJPC9nPgoJCTwvZz4KCQk8ZyBpZD0ic2hhcGUyMS0yNyIgdjptSUQ9IjIxIiB2Omdyb3VwQ29udGV4dD0ic2hhcGUiPgoJCQk8dGl0bGU+U2hlZXQuMjE8L3RpdGxlPgoJCQk8cmVjdCB4PSIwIiB5PSIxLjI0OTk5IiB3aWR0aD0iNDE0IiBoZWlnaHQ9IjEwOCIgY2xhc3M9InN0NSIvPgoJCTwvZz4KCTwvZz4KPC9zdmc+Cg=="},79007:(e,t,n)=>{n.d(t,{Z:()=>a});const a="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjwhLS0gR2VuZXJhdGVkIGJ5IE1pY3Jvc29mdCBWaXNpbywgU1ZHIEV4cG9ydCB6aW8tc3RyZWFtcy0yLnguc3ZnIFBhZ2UtMSAtLT4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWxuczpldj0iaHR0cDovL3d3dy53My5vcmcvMjAwMS94bWwtZXZlbnRzIgoJCXhtbG5zOnY9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vdmlzaW8vMjAwMy9TVkdFeHRlbnNpb25zLyIgd2lkdGg9IjUuNzY3MzZpbiIgaGVpZ2h0PSIxLjUxNzM2aW4iCgkJdmlld0JveD0iMCAwIDQxNS4yNSAxMDkuMjUiIHhtbDpzcGFjZT0icHJlc2VydmUiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiIgY2xhc3M9InN0NSI+Cgk8djpkb2N1bWVudFByb3BlcnRpZXMgdjpsYW5nSUQ9IjEwMzMiIHY6dmlld01hcmt1cD0iZmFsc2UiPgoJCTx2OnVzZXJEZWZzPgoJCQk8djp1ZCB2Om5hbWVVPSJtc3ZOb0F1dG9Db25uZWN0IiB2OnZhbD0iVlQwKDEpOjI2Ii8+CgkJPC92OnVzZXJEZWZzPgoJPC92OmRvY3VtZW50UHJvcGVydGllcz4KCgk8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJPCFbQ0RBVEFbCgkJLnN0MSB7ZmlsbDp1cmwoI2dyYWQwLTUpO3N0cm9rZTojMDAwMDAwO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utd2lkdGg6MS4yNX0KCQkuc3QyIHtmaWxsOiMwMDAwMDA7Zm9udC1mYW1pbHk6Q2FsaWJyaTtmb250LXNpemU6MS41ZW19CgkJLnN0MyB7bWFya2VyLWVuZDp1cmwoI21ya3I0LTIxKTtzdHJva2U6IzAwMDAwMDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLXdpZHRoOjF9CgkJLnN0NCB7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS1vcGFjaXR5OjE7c3Ryb2tlLXdpZHRoOjAuMjg0MDkwOTA5MDkwOTF9CgkJLnN0NSB7ZmlsbDpub25lO2ZpbGwtcnVsZTpldmVub2RkO2ZvbnQtc2l6ZToxMnB4O292ZXJmbG93OnZpc2libGU7c3Ryb2tlLWxpbmVjYXA6c3F1YXJlO3N0cm9rZS1taXRlcmxpbWl0OjN9CgldXT4KCTwvc3R5bGU+CgoJPGRlZnMgaWQ9IlBhdHRlcm5zX0FuZF9HcmFkaWVudHMiPgoJCTxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZDAtNSIgeDE9IjAiIHkxPSIwIiB4Mj0iMSIgeTI9IjAiIGdyYWRpZW50VHJhbnNmb3JtPSJyb3RhdGUoOTAgMC41IDAuNSkiPgoJCQk8c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmZmZmYiIHN0b3Atb3BhY2l0eT0iMSIvPgoJCQk8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNkOGQ4ZDgiIHN0b3Atb3BhY2l0eT0iMSIvPgoJCTwvbGluZWFyR3JhZGllbnQ+Cgk8L2RlZnM+Cgk8ZGVmcyBpZD0iTWFya2VycyI+CgkJPGcgaWQ9ImxlbmQ0Ij4KCQkJPHBhdGggZD0iTSAyIDEgTCAwIDAgTCAyIC0xIEwgMiAxICIgc3R5bGU9InN0cm9rZTpub25lIi8+CgkJPC9nPgoJCTxtYXJrZXIgaWQ9Im1ya3I0LTIxIiBjbGFzcz0ic3Q0IiB2OmFycm93VHlwZT0iNCIgdjphcnJvd1NpemU9IjIiIHY6c2V0YmFjaz0iNy4wNCIgcmVmWD0iLTcuMDQiIG9yaWVudD0iYXV0byIKCQkJCW1hcmtlclVuaXRzPSJzdHJva2VXaWR0aCIgb3ZlcmZsb3c9InZpc2libGUiPgoJCQk8dXNlIHhsaW5rOmhyZWY9IiNsZW5kNCIgdHJhbnNmb3JtPSJzY2FsZSgtMy41MiwtMy41MikgIi8+CgkJPC9tYXJrZXI+Cgk8L2RlZnM+Cgk8ZyB2Om1JRD0iMCIgdjppbmRleD0iMSIgdjpncm91cENvbnRleHQ9ImZvcmVncm91bmRQYWdlIj4KCQk8dGl0bGU+UGFnZS0xPC90aXRsZT4KCQk8djpwYWdlUHJvcGVydGllcyB2OmRyYXdpbmdTY2FsZT0iMSIgdjpwYWdlU2NhbGU9IjEiIHY6ZHJhd2luZ1VuaXRzPSIxOSIgdjpzaGFkb3dPZmZzZXRYPSI5IiB2OnNoYWRvd09mZnNldFk9Ii05Ii8+CgkJPHY6bGF5ZXIgdjpuYW1lPSJDb25uZWN0b3IiIHY6aW5kZXg9IjAiLz4KCQk8ZyBpZD0iZ3JvdXAxLTEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE4LjYyNSwtMTguNjI1KSIgdjptSUQ9IjEiIHY6Z3JvdXBDb250ZXh0PSJncm91cCI+CgkJCTx0aXRsZT5TaGVldC4xPC90aXRsZT4KCQkJPGcgaWQ9InNoYXBlMi0yIiB2Om1JRD0iMiIgdjpncm91cENvbnRleHQ9InNoYXBlIj4KCQkJCTx0aXRsZT5TaGVldC4yPC90aXRsZT4KCQkJCTxkZXNjPlpTdHJlYW08L2Rlc2M+CgkJCQk8djp0ZXh0QmxvY2sgdjptYXJnaW5zPSJyZWN0KDQsNCw0LDQpIi8+CgkJCQk8djp0ZXh0UmVjdCBjeD0iNTQiIGN5PSI3My4yNSIgd2lkdGg9IjEwOC4wMSIgaGVpZ2h0PSI3MiIvPgoJCQkJPHJlY3QgeD0iMCIgeT0iMzcuMjUiIHdpZHRoPSIxMDgiIGhlaWdodD0iNzIiIHJ4PSI5IiByeT0iOSIgY2xhc3M9InN0MSIvPgoJCQkJPHRleHQgeD0iMjMuNTIiIHk9Ijc4LjY1IiBjbGFzcz0ic3QyIiB2OmxhbmdJRD0iMTAzMyI+PHY6cGFyYWdyYXBoIHY6aG9yaXpBbGlnbj0iMSIvPjx2OnRhYkxpc3QvPlpTdHJlYW08L3RleHQ+CQkJPC9nPgoJCQk8ZyBpZD0ic2hhcGUzLTciIHY6bUlEPSIzIiB2Omdyb3VwQ29udGV4dD0ic2hhcGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNSwwKSI+CgkJCQk8dGl0bGU+U2hlZXQuMzwvdGl0bGU+CgkJCQk8ZGVzYz5aUGlwZWxpbmU8L2Rlc2M+CgkJCQk8djp0ZXh0QmxvY2sgdjptYXJnaW5zPSJyZWN0KDQsNCw0LDQpIi8+CgkJCQk8djp0ZXh0UmVjdCBjeD0iNTQiIGN5PSI3My4yNSIgd2lkdGg9IjEwOC4wMSIgaGVpZ2h0PSI3MiIvPgoJCQkJPHJlY3QgeD0iMCIgeT0iMzcuMjUiIHdpZHRoPSIxMDgiIGhlaWdodD0iNzIiIHJ4PSI5IiByeT0iOSIgY2xhc3M9InN0MSIvPgoJCQkJPHRleHQgeD0iMjAuNTMiIHk9Ijc4LjY1IiBjbGFzcz0ic3QyIiB2OmxhbmdJRD0iMTAzMyI+PHY6cGFyYWdyYXBoIHY6aG9yaXpBbGlnbj0iMSIvPjx2OnRhYkxpc3QvPlpQaXBlbGluZTwvdGV4dD4JCQk8L2c+CgkJCTxnIGlkPSJzaGFwZTQtMTEiIHY6bUlEPSI0IiB2Omdyb3VwQ29udGV4dD0ic2hhcGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI3MCwwKSI+CgkJCQk8dGl0bGU+U2hlZXQuNDwvdGl0bGU+CgkJCQk8ZGVzYz5aU2luazwvZGVzYz4KCQkJCTx2OnRleHRCbG9jayB2Om1hcmdpbnM9InJlY3QoNCw0LDQsNCkiLz4KCQkJCTx2OnRleHRSZWN0IGN4PSI1NCIgY3k9IjczLjI1IiB3aWR0aD0iMTA4LjAxIiBoZWlnaHQ9IjcyIi8+CgkJCQk8cmVjdCB4PSIwIiB5PSIzNy4yNSIgd2lkdGg9IjEwOCIgaGVpZ2h0PSI3MiIgcng9IjkiIHJ5PSI5IiBjbGFzcz0ic3QxIi8+CgkJCQk8dGV4dCB4PSIzNC43NyIgeT0iNzguNjUiIGNsYXNzPSJzdDIiIHY6bGFuZ0lEPSIxMDMzIj48djpwYXJhZ3JhcGggdjpob3JpekFsaWduPSIxIi8+PHY6dGFiTGlzdC8+WlNpbms8L3RleHQ+CQkJPC9nPgoJCQk8ZyBpZD0iZ3JvdXA1LTE1IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNDMsLTI3KSIgdjptSUQ9IjUiIHY6Z3JvdXBDb250ZXh0PSJncm91cCI+CgkJCQk8dGl0bGU+U2hlZXQuNTwvdGl0bGU+CgkJCQk8ZyBpZD0ic2hhcGU2LTE2IiB2Om1JRD0iNiIgdjpncm91cENvbnRleHQ9InNoYXBlIiB2OmxheWVyTWVtYmVyPSIwIj4KCQkJCQk8dGl0bGU+RHluYW1pYyBjb25uZWN0b3I8L3RpdGxlPgoJCQkJCTxwYXRoIGQ9Ik0wIDEwMC4yNSBMMTkuOTYgMTAwLjI1IiBjbGFzcz0ic3QzIi8+CgkJCQk8L2c+CgkJCTwvZz4KCQkJPGcgaWQ9Imdyb3VwNy0yMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTA4LjQ1LC0yOC44KSIgdjptSUQ9IjciIHY6Z3JvdXBDb250ZXh0PSJncm91cCI+CgkJCQk8dGl0bGU+U2hlZXQuNzwvdGl0bGU+CgkJCQk8ZyBpZD0ic2hhcGU4LTIzIiB2Om1JRD0iOCIgdjpncm91cENvbnRleHQ9InNoYXBlIiB2OmxheWVyTWVtYmVyPSIwIj4KCQkJCQk8dGl0bGU+RHluYW1pYyBjb25uZWN0b3I8L3RpdGxlPgoJCQkJCTxwYXRoIGQ9Ik0wIDEwMC4yNSBMMTkuOTYgMTAwLjI1IiBjbGFzcz0ic3QzIi8+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+Cjwvc3ZnPgo="},19562:(e,t,n)=>{n.d(t,{Z:()=>a});const a="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjwhLS0gR2VuZXJhdGVkIGJ5IE1pY3Jvc29mdCBWaXNpbywgU1ZHIEV4cG9ydCB6aW8tc3RyZWFtcy16Y2hhbm5lbC5zdmcgUGFnZS0xIC0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmV2PSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMiCgkJeG1sbnM6dj0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS92aXNpby8yMDAzL1NWR0V4dGVuc2lvbnMvIiB3aWR0aD0iNi4yNjA0MmluIiBoZWlnaHQ9IjIuMDEwNDJpbiIKCQl2aWV3Qm94PSIwIDAgNDUwLjc1IDE0NC43NSIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIiBjbGFzcz0ic3Q1Ij4KCTx2OmRvY3VtZW50UHJvcGVydGllcyB2OmxhbmdJRD0iMTAzMyIgdjp2aWV3TWFya3VwPSJmYWxzZSI+CgkJPHY6dXNlckRlZnM+CgkJCTx2OnVkIHY6bmFtZVU9Im1zdk5vQXV0b0Nvbm5lY3QiIHY6dmFsPSJWVDAoMSk6MjYiLz4KCQk8L3Y6dXNlckRlZnM+Cgk8L3Y6ZG9jdW1lbnRQcm9wZXJ0aWVzPgoKCTxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgk8IVtDREFUQVsKCQkuc3QxIHtmaWxsOm5vbmU7c3Ryb2tlOm5vbmU7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS13aWR0aDowLjc1fQoJCS5zdDIge2ZpbGw6I2ZjZWJkZDtzdHJva2U6IzAwMDAwMDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLXdpZHRoOjEuMjV9CgkJLnN0MyB7ZmlsbDojMDAwMDAwO2ZvbnQtZmFtaWx5OkNhbGlicmk7Zm9udC1zaXplOjEuNWVtfQoJCS5zdDQge2ZpbGw6dXJsKCNncmFkMC0xMSk7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS13aWR0aDoxLjI1fQoJCS5zdDUge2ZpbGw6bm9uZTtmaWxsLXJ1bGU6ZXZlbm9kZDtmb250LXNpemU6MTJweDtvdmVyZmxvdzp2aXNpYmxlO3N0cm9rZS1saW5lY2FwOnNxdWFyZTtzdHJva2UtbWl0ZXJsaW1pdDozfQoJXV0+Cgk8L3N0eWxlPgoKCTxkZWZzIGlkPSJQYXR0ZXJuc19BbmRfR3JhZGllbnRzIj4KCQk8bGluZWFyR3JhZGllbnQgaWQ9ImdyYWQwLTExIiB4MT0iMCIgeTE9IjAiIHgyPSIxIiB5Mj0iMCIgZ3JhZGllbnRUcmFuc2Zvcm09InJvdGF0ZSg5MCAwLjUgMC41KSI+CgkJCTxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iI2ZmZmZmZiIgc3RvcC1vcGFjaXR5PSIxIi8+CgkJCTxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2Q4ZDhkOCIgc3RvcC1vcGFjaXR5PSIxIi8+CgkJPC9saW5lYXJHcmFkaWVudD4KCTwvZGVmcz4KCTxnIHY6bUlEPSIwIiB2OmluZGV4PSIxIiB2Omdyb3VwQ29udGV4dD0iZm9yZWdyb3VuZFBhZ2UiPgoJCTx0aXRsZT5QYWdlLTE8L3RpdGxlPgoJCTx2OnBhZ2VQcm9wZXJ0aWVzIHY6ZHJhd2luZ1NjYWxlPSIxIiB2OnBhZ2VTY2FsZT0iMSIgdjpkcmF3aW5nVW5pdHM9IjE5IiB2OnNoYWRvd09mZnNldFg9IjkiIHY6c2hhZG93T2Zmc2V0WT0iLTkiLz4KCQk8djpsYXllciB2Om5hbWU9IkNvbm5lY3RvciIgdjppbmRleD0iMCIvPgoJCTxnIGlkPSJncm91cDQtMSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjgwLC02NCkiIHY6bUlEPSI0IiB2Omdyb3VwQ29udGV4dD0iZ3JvdXAiPgoJCQk8dGl0bGU+U2hlZXQuNDwvdGl0bGU+CgkJPC9nPgoJCTxnIGlkPSJncm91cDYtMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTQ1LjQ1LC02NS44KSIgdjptSUQ9IjYiIHY6Z3JvdXBDb250ZXh0PSJncm91cCI+CgkJCTx0aXRsZT5TaGVldC42PC90aXRsZT4KCQk8L2c+CgkJPGcgaWQ9InNoYXBlOC0zIiB2Om1JRD0iOCIgdjpncm91cENvbnRleHQ9InNoYXBlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxOC4zNzUsLTE4LjM3NSkiPgoJCQk8dGl0bGU+U2hlZXQuODwvdGl0bGU+CgkJCTxyZWN0IHg9IjAiIHk9IjM2Ljc1IiB3aWR0aD0iNDE0IiBoZWlnaHQ9IjEwOCIgY2xhc3M9InN0MSIvPgoJCTwvZz4KCQk8ZyBpZD0ic2hhcGU5LTUiIHY6bUlEPSI5IiB2Omdyb3VwQ29udGV4dD0ic2hhcGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE4LjE4NzUsLTE4KSI+CgkJCTx0aXRsZT5TaGVldC45PC90aXRsZT4KCQkJPGRlc2M+WkNoYW5uZWw8L2Rlc2M+CgkJCTx2OnRleHRCbG9jayB2Om1hcmdpbnM9InJlY3QoNCw0LDQsNCkiLz4KCQkJPHY6dGV4dFJlY3QgY3g9IjIwNy4yODEiIGN5PSI5MS4wMzEyIiB3aWR0aD0iNDE0LjU3IiBoZWlnaHQ9IjEwNy40MzgiLz4KCQkJPHJlY3QgeD0iMCIgeT0iMzcuMzEyNSIgd2lkdGg9IjQxNC41NjIiIGhlaWdodD0iMTA3LjQzOCIgcng9IjkiIHJ5PSI5IiBjbGFzcz0ic3QyIi8+CgkJCTx0ZXh0IHg9IjE3My4yMyIgeT0iOTYuNDMiIGNsYXNzPSJzdDMiIHY6bGFuZ0lEPSIxMDMzIj48djpwYXJhZ3JhcGggdjpob3JpekFsaWduPSIxIi8+PHY6dGFiTGlzdC8+WkNoYW5uZWw8L3RleHQ+CQk8L2c+CgkJPGcgaWQ9InNoYXBlMy04IiB2Om1JRD0iMyIgdjpncm91cENvbnRleHQ9InNoYXBlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMDcsLTM3KSI+CgkJCTx0aXRsZT5TaGVldC4zPC90aXRsZT4KCQkJPGRlc2M+WlNpbms8L2Rlc2M+CgkJCTx2OnRleHRCbG9jayB2Om1hcmdpbnM9InJlY3QoNCw0LDQsNCkiLz4KCQkJPHY6dGV4dFJlY3QgY3g9IjU0IiBjeT0iMTA4Ljc1IiB3aWR0aD0iMTA4LjAxIiBoZWlnaHQ9IjcyIi8+CgkJCTxyZWN0IHg9IjAiIHk9IjcyLjc1IiB3aWR0aD0iMTA4IiBoZWlnaHQ9IjcyIiByeD0iOSIgcnk9IjkiIGNsYXNzPSJzdDQiLz4KCQkJPHRleHQgeD0iMzQuNzciIHk9IjExNC4xNSIgY2xhc3M9InN0MyIgdjpsYW5nSUQ9IjEwMzMiPjx2OnBhcmFncmFwaCB2Omhvcml6QWxpZ249IjEiLz48djp0YWJMaXN0Lz5aU2luazwvdGV4dD4JCTwvZz4KCQk8ZyBpZD0ic2hhcGUxLTEzIiB2Om1JRD0iMSIgdjpncm91cENvbnRleHQ9InNoYXBlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzNywtMzcpIj4KCQkJPHRpdGxlPlNoZWV0LjE8L3RpdGxlPgoJCQk8ZGVzYz5aU3RyZWFtPC9kZXNjPgoJCQk8djp0ZXh0QmxvY2sgdjptYXJnaW5zPSJyZWN0KDQsNCw0LDQpIi8+CgkJCTx2OnRleHRSZWN0IGN4PSI1NCIgY3k9IjEwOC43NSIgd2lkdGg9IjEwOC4wMSIgaGVpZ2h0PSI3MiIvPgoJCQk8cmVjdCB4PSIwIiB5PSI3Mi43NSIgd2lkdGg9IjEwOCIgaGVpZ2h0PSI3MiIgcng9IjkiIHJ5PSI5IiBjbGFzcz0ic3Q0Ii8+CgkJCTx0ZXh0IHg9IjIzLjUyIiB5PSIxMTQuMTUiIGNsYXNzPSJzdDMiIHY6bGFuZ0lEPSIxMDMzIj48djpwYXJhZ3JhcGggdjpob3JpekFsaWduPSIxIi8+PHY6dGFiTGlzdC8+WlN0cmVhbTwvdGV4dD4JCTwvZz4KCTwvZz4KPC9zdmc+Cg=="}}]);