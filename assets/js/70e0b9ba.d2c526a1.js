"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[51751],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(n),u=i,m=d["".concat(s,".").concat(u)]||d[u]||f[u]||a;return n?r.createElement(m,l(l({ref:t},c),{},{components:n})):r.createElement(m,l({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,l=new Array(a);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<a;p++)l[p]=n[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},38407:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>f,frontMatter:()=>a,metadata:()=>o,toc:()=>p});var r=n(87462),i=(n(67294),n(3905));const a={id:"overview_basic_concurrency",title:"Basic Concurrency"},l=void 0,o={unversionedId:"overview/overview_basic_concurrency",id:"version-1.0.18/overview/overview_basic_concurrency",title:"Basic Concurrency",description:"ZIO has low-level support for concurrency using fibers. While fibers are very powerful, they are low-level. To improve productivity, ZIO provides high-level operations built on fibers.",source:"@site/versioned_docs/version-1.0.18/overview/basic_concurrency.md",sourceDirName:"overview",slug:"/overview/overview_basic_concurrency",permalink:"/1.0.18/overview/overview_basic_concurrency",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/overview/basic_concurrency.md",tags:[],version:"1.0.18",frontMatter:{id:"overview_basic_concurrency",title:"Basic Concurrency"},sidebar:"overview_sidebar",previous:{title:"Handling Resources",permalink:"/1.0.18/overview/overview_handling_resources"},next:{title:"Testing Effects",permalink:"/1.0.18/overview/overview_testing_effects"}},s={},p=[{value:"Fibers",id:"fibers",level:2},{value:"The Fiber Data Type",id:"the-fiber-data-type",level:3},{value:"Forking Effects",id:"forking-effects",level:3},{value:"Joining Fibers",id:"joining-fibers",level:3},{value:"Awaiting Fibers",id:"awaiting-fibers",level:3},{value:"Interrupting Fibers",id:"interrupting-fibers",level:3},{value:"Composing Fibers",id:"composing-fibers",level:3},{value:"Parallelism",id:"parallelism",level:2},{value:"Racing",id:"racing",level:2},{value:"Timeout",id:"timeout",level:2},{value:"Next Steps",id:"next-steps",level:2}],c={toc:p},d="wrapper";function f(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"ZIO has low-level support for concurrency using ",(0,i.kt)("em",{parentName:"p"},"fibers"),". While fibers are very powerful, they are low-level. To improve productivity, ZIO provides high-level operations built on fibers."),(0,i.kt)("p",null,"When you can, you should always use high-level operations, rather than working with fibers directly. For the sake of completeness, this section introduces both fibers and some of the high-level operations built on them."),(0,i.kt)("h2",{id:"fibers"},"Fibers"),(0,i.kt)("p",null,"ZIO's concurrency is built on ",(0,i.kt)("em",{parentName:"p"},"fibers"),', which are lightweight "green threads" implemented by the ZIO runtime system.'),(0,i.kt)("p",null,"Unlike operating system threads, fibers consume almost no memory, have growable and shrinkable stacks, don't waste resources blocking, and will be garbage collected automatically if they are suspended and unreachable."),(0,i.kt)("p",null,"Fibers are scheduled by the ZIO runtime and will cooperatively yield to each other, which enables multitasking, even when operating in a single-threaded environment (like JavaScript, or even the JVM when configured with one thread)."),(0,i.kt)("p",null,"All effects in ZIO are executed by ",(0,i.kt)("em",{parentName:"p"},"some")," fiber. If you did not create the fiber, then the fiber was created by some operation you are using (if the operation is concurrent or parallel), or by the ZIO runtime system."),(0,i.kt)("p",null,'Even if you only write "single-threaded" code, with no parallel or concurrent operations, then there will be at least one fiber: the "main" fiber that executes your effect.'),(0,i.kt)("h3",{id:"the-fiber-data-type"},"The Fiber Data Type"),(0,i.kt)("p",null,"Every ZIO fiber is responsible for executing some effect, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber"),' data type in ZIO represents a "handle" on that running computation. The ',(0,i.kt)("inlineCode",{parentName:"p"},"Fiber")," data type is most similar to Scala's ",(0,i.kt)("inlineCode",{parentName:"p"},"Future")," data type."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber[E, A]")," data type in ZIO has two type parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"E")," Failure Type"),". The fiber may fail with a value of this type."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"A")," Success Type"),". The fiber may succeed with a value of this type.")),(0,i.kt)("p",null,"Fibers do not have an ",(0,i.kt)("inlineCode",{parentName:"p"},"R")," type parameter, because they model effects that are already running, and which already had their required environment provided to them."),(0,i.kt)("h3",{id:"forking-effects"},"Forking Effects"),(0,i.kt)("p",null,"The most fundamental way of creating a fiber is to take an existing effect and ",(0,i.kt)("em",{parentName:"p"},"fork")," it. Conceptually, ",(0,i.kt)("em",{parentName:"p"},"forking")," an effect begins executing the effect on a new fiber, giving you a reference to the newly-created ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber"),"."),(0,i.kt)("p",null,"The following code creates a single fiber, which executes ",(0,i.kt)("inlineCode",{parentName:"p"},"fib(100)"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def fib(n: Long): UIO[Long] = UIO {\n  if (n <= 1) UIO.succeed(n)\n  else fib(n - 1).zipWith(fib(n - 2))(_ + _)\n}.flatten\n\nval fib100Fiber: UIO[Fiber[Nothing, Long]] = \n  for {\n    fiber <- fib(100).fork\n  } yield fiber\n")),(0,i.kt)("h3",{id:"joining-fibers"},"Joining Fibers"),(0,i.kt)("p",null,"One of the methods on ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber#join"),", which returns an effect. The effect returned by ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber#join")," will succeed or fail as per the fiber:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  fiber   <- IO.succeed("Hi!").fork\n  message <- fiber.join\n} yield message\n')),(0,i.kt)("h3",{id:"awaiting-fibers"},"Awaiting Fibers"),(0,i.kt)("p",null,"Another method on ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber#await"),", which returns an effect containing an ",(0,i.kt)("inlineCode",{parentName:"p"},"Exit")," value, which provides full information on how the fiber completed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  fiber <- IO.succeed("Hi!").fork\n  exit  <- fiber.await\n} yield exit\n')),(0,i.kt)("h3",{id:"interrupting-fibers"},"Interrupting Fibers"),(0,i.kt)("p",null,"A fiber whose result is no longer needed may be ",(0,i.kt)("em",{parentName:"p"},"interrupted"),", which immediately terminates the fiber, safely releasing all resources and running all finalizers."),(0,i.kt)("p",null,"Like ",(0,i.kt)("inlineCode",{parentName:"p"},"await"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber#interrupt")," returns an ",(0,i.kt)("inlineCode",{parentName:"p"},"Exit")," describing how the fiber completed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  fiber <- IO.succeed("Hi!").forever.fork\n  exit  <- fiber.interrupt\n} yield exit\n')),(0,i.kt)("p",null,"By design, the effect returned by ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber#interrupt")," does not resume until the fiber has completed. If this behavior is not desired, you can ",(0,i.kt)("inlineCode",{parentName:"p"},"fork")," the interruption itself:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  fiber <- IO.succeed("Hi!").forever.fork\n  _     <- fiber.interrupt.fork // I don\'t care!\n} yield ()\n')),(0,i.kt)("h3",{id:"composing-fibers"},"Composing Fibers"),(0,i.kt)("p",null,"ZIO lets you compose fibers with ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber#zip")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber#zipWith"),". "),(0,i.kt)("p",null,"These methods combine two fibers into a single fiber that produces the results of both. If either fiber fails, then the composed fiber will fail."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  fiber1 <- IO.succeed("Hi!").fork\n  fiber2 <- IO.succeed("Bye!").fork\n  fiber   = fiber1.zip(fiber2)\n  tuple  <- fiber.join\n} yield tuple\n')),(0,i.kt)("p",null,"Another way fibers compose is with ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber#orElse"),". If the first fiber succeeds, the composed fiber will succeed with its result; otherwise, the composed fiber will complete with the exit value of the second fiber (whether success or failure)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  fiber1 <- IO.fail("Uh oh!").fork\n  fiber2 <- IO.succeed("Hurray!").fork\n  fiber   = fiber1.orElse(fiber2)\n  message  <- fiber.join\n} yield message\n')),(0,i.kt)("h2",{id:"parallelism"},"Parallelism"),(0,i.kt)("p",null,"ZIO provides many operations for performing effects in parallel. These methods are all named with a ",(0,i.kt)("inlineCode",{parentName:"p"},"Par")," suffix that helps you identify opportunities to parallelize your code."),(0,i.kt)("p",null,"For example, the ordinary ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#zip")," method zips two effects together, sequentially. But there is also a ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#zipPar")," method, which zips two effects together in parallel."),(0,i.kt)("p",null,"The following table summarizes some of the sequential operations and their corresponding parallel versions:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"right"},(0,i.kt)("strong",{parentName:"th"},"Description")),(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("strong",{parentName:"th"},"Sequential")),(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("strong",{parentName:"th"},"Parallel")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"Zips two effects into one"),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#zip")),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#zipPar"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"Zips two effects into one"),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#zipWith")),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#zipWithPar"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"Zips multiple effects into one"),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#tupled")),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO#tupledPar"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"Collects from many effects"),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.collectAll")),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.collectAllPar"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"Effectfully loop over values"),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.foreach")),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.foreachPar"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"Reduces many values"),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.reduceAll")),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.reduceAllPar"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"Merges many values"),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.mergeAll")),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ZIO.mergeAllPar"))))),(0,i.kt)("p",null,"For all the parallel operations, if one effect fails, then others will be interrupted, to minimize unnecessary computation."),(0,i.kt)("p",null,"If the fail-fast behavior is not desired, potentially failing effects can be first converted into infallible effects using the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#either")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#option")," methods."),(0,i.kt)("h2",{id:"racing"},"Racing"),(0,i.kt)("p",null,"ZIO lets you race multiple effects in parallel, returning the first successful result:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  winner <- IO.succeed("Hello").race(IO.succeed("Goodbye"))\n} yield winner\n')),(0,i.kt)("p",null,"If you want the first success or failure, rather than the first success, then you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"left.either race right.either"),", for any effects ",(0,i.kt)("inlineCode",{parentName:"p"},"left")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"right"),"."),(0,i.kt)("h2",{id:"timeout"},"Timeout"),(0,i.kt)("p",null,"ZIO lets you timeout any effect using the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#timeout")," method, which returns a new effect that succeeds with an ",(0,i.kt)("inlineCode",{parentName:"p"},"Option"),". A value of ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," indicates the timeout elapsed before the effect completed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.duration._\n\nIO.succeed("Hello").timeout(10.seconds)\n')),(0,i.kt)("p",null,"If an effect times out, then instead of continuing to execute in the background, it will be interrupted so no resources will be wasted."),(0,i.kt)("h2",{id:"next-steps"},"Next Steps"),(0,i.kt)("p",null,"If you are comfortable with basic concurrency, then the next step is to learn about ",(0,i.kt)("a",{parentName:"p",href:"/1.0.18/overview/overview_testing_effects"},"testing effects"),"."))}f.isMDXComponent=!0}}]);