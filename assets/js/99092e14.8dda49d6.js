"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[659],{3905:(e,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>k});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),m=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},s=function(e){var n=m(e.components);return a.createElement(p.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),d=m(t),u=r,k=d["".concat(p,".").concat(u)]||d[u]||c[u]||l;return t?a.createElement(k,i(i({ref:n},s),{},{components:t})):a.createElement(k,i({ref:n},s))}));function k(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=u;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[d]="string"==typeof e?e:r,i[1]=o;for(var m=2;m<l;m++)i[m]=t[m];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},88516:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>m});var a=t(87462),r=(t(67294),t(3905));const l={id:"built-in-generators",title:"Built-in Generators"},i=void 0,o={unversionedId:"reference/test/property-testing/built-in-generators",id:"reference/test/property-testing/built-in-generators",title:"Built-in Generators",description:"In the companion object of the Gen data type, there are tons of generators for various data types.",source:"@site/docs/reference/test/property-testing/built-in-generators.md",sourceDirName:"reference/test/property-testing",slug:"/reference/test/property-testing/built-in-generators",permalink:"/reference/test/property-testing/built-in-generators",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/property-testing/built-in-generators.md",tags:[],version:"current",frontMatter:{id:"built-in-generators",title:"Built-in Generators"},sidebar:"reference-sidebar",previous:{title:"How Generators Work?",permalink:"/reference/test/property-testing/how-generators-work"},next:{title:"Shrinking",permalink:"/reference/test/property-testing/shrinking"}},p={},m=[{value:"Primitive Types Generators",id:"primitive-types-generators",level:2},{value:"Character Generators",id:"character-generators",level:2},{value:"String Generators",id:"string-generators",level:2},{value:"Generating Fixed Values",id:"generating-fixed-values",level:2},{value:"Generating from Fixed Values",id:"generating-from-fixed-values",level:2},{value:"Collection Generators",id:"collection-generators",level:2},{value:"Bounded Generator",id:"bounded-generator",level:2},{value:"Suspended Generator",id:"suspended-generator",level:2},{value:"Unfold Generator",id:"unfold-generator",level:2},{value:"From a ZIO Effect",id:"from-a-zio-effect",level:2},{value:"From a Random Effect",id:"from-a-random-effect",level:2},{value:"Uniform and Non-uniform Generators",id:"uniform-and-non-uniform-generators",level:2},{value:"Generating Date/Time Types",id:"generating-datetime-types",level:2},{value:"Function Generators",id:"function-generators",level:2},{value:"Generating ZIO Values",id:"generating-zio-values",level:2},{value:"Generating Compound Types",id:"generating-compound-types",level:2},{value:"Sized Generators",id:"sized-generators",level:2}],s={toc:m},d="wrapper";function c(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In the companion object of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen")," data type, there are tons of generators for various data types."),(0,r.kt)("h2",{id:"primitive-types-generators"},"Primitive Types Generators"),(0,r.kt)("p",null,"ZIO Test provides generators for primitive types such as ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.int"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.string"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.boolean"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.float"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.double"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.bigInt"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.byte"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.bigdecimal"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.long"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.char"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.short"),"."),(0,r.kt)("p",null,"Let's create an ",(0,r.kt)("inlineCode",{parentName:"p"},"Int")," generator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.test._\n\nval intGen: Gen[Any, Int] = Gen.int\n")),(0,r.kt)("h2",{id:"character-generators"},"Character Generators"),(0,r.kt)("p",null,"In addition to ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.char"),", ZIO Test offers a variety of specialized character generators:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.alphaChar")," \u2014 e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"Z, z, A, t, o, e, K, E, y, N")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.alphaNumericChar")," \u2014 e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"b, O, X, B, 4, M, k, 9, a, p")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.asciiChar")," \u2014 e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"\x10, >, \x04, \x1e, \x02, 2, k, \x16, \x0f, \x03")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.unicodeChar")," \u2014 e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"\uf9ba, \ue53f, \uc637, \ufa0d, \ue8d4, \ubbb2, \ufe53, \u766e, \uf62c, \u1723)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.numericChar")," \u2014 e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"1, 0, 1, 5, 6, 9, 4, 4, 5, 2")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.printableChar")," \u2014 e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"H, J, (, Q, n, g, 4, G, 9, l")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.whitespaceChars")," \u2014 e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"\x1c, \x1f, \u2006, \v, \x1f, \u2003, \u2004,  , \u1680, ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.hexChar")," \u2014 e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"3, F, b, 5, 9, e, 2, 8, b, e")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.hexCharLower")," \u2014 e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"f, c, 4, 4, c, 2, 5, 4, f, 3")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.hexCharUpper")," \u2014 e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"4, 8, 9, 8, C, 9, F, A, E, C"))),(0,r.kt)("h2",{id:"string-generators"},"String Generators"),(0,r.kt)("p",null,"Besides the primitive string generator, ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.string"),", ZIO Test also provides the following specialized generators:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.stringBounded")," \u2014 A generator of strings whose size falls within the specified bounds:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"Gen.stringBounded(1, 5)(Gen.alphaChar)\n  .runCollectN(10)\n  .debug\n// Sample Output: List(b, YJXzY, Aro, y, WMPbj, Abxt, kJep, LKN, kUtr, xJ)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.stringN")," \u2014 A generator of strings of fixed size:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"Gen.stringN(5)(Gen.alphaChar)\n  .runCollectN(10)\n  .debug\n// Sample Output: List(BuywQ, tXCEy, twZli, ffLwI, BPEbz, OKYTi, xeDJW, iDUVn, cuMCr, keQAA)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.string1")," \u2014 A generator of strings of at least one character.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.alphaNumericString")," \u2014 A generator of alphanumeric characters.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.alphaNumericStringBounded")," \u2014 A generator of alphanumeric strings whose size falls within the specified bounds.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.iso_8859_1")," \u2014 A generator of strings that can be encoded in the ISO-8859-1 character set.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.asciiString")," \u2014 A generator of US-ASCII characters."))),(0,r.kt)("h2",{id:"generating-fixed-values"},"Generating Fixed Values"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.const")," \u2014 A constant generator of the specified value."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"Gen.const(true).runCollectN(5)\n// Output: List(true, true, true, true, true)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.constSample")," \u2014 A constant generator of the specified sample:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0}," Gen.constSample(Sample.noShrink(false)).runCollectN(5)\n// Output: List(true, true, true, true, true)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.unit")," \u2014 A constant generator of the unit value.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.throwable")," \u2014 A generator of throwables."))),(0,r.kt)("p",null,"Note that there is an empty generator called ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.empty"),", which generates no values and returns nothing. We can think of that as a generator of empty stream, ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen(Stream.empty)"),"."),(0,r.kt)("h2",{id:"generating-from-fixed-values"},"Generating from Fixed Values"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.elements")," \u2014 Constructs a non-deterministic generator that only generates randomly from the fixed values:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import java.time._\n\nGen.elements(\n  DayOfWeek.MONDAY,\n  DayOfWeek.TUESDAY,\n  DayOfWeek.WEDNESDAY,\n  DayOfWeek.THURSDAY,\n  DayOfWeek.FRIDAY,\n  DayOfWeek.SATURDAY,\n  DayOfWeek.SUNDAY\n).runCollectN(3).debug\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.fromIterable")," \u2014 Constructs a deterministic generator that only generates the specified fixed values:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'Gen.fromIterable(List("red", "green", "blue"))\n  .runCollectN(10)\n  .debug\n')),(0,r.kt)("h2",{id:"collection-generators"},"Collection Generators"),(0,r.kt)("p",null,"ZIO Test has generators for collection data types such as ",(0,r.kt)("em",{parentName:"p"},"sets"),", ",(0,r.kt)("em",{parentName:"p"},"lists"),", ",(0,r.kt)("em",{parentName:"p"},"vectors"),", ",(0,r.kt)("em",{parentName:"p"},"chunks"),", and ",(0,r.kt)("em",{parentName:"p"},"maps"),". These data types share similar APIs. The following example illustrates how the generator of sets works:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"// A sized generator of sets\nGen.setOf(Gen.alphaChar)\n// Sample Output: Set(Y, M, c), Set(), Set(g, x, Q), Set(s), Set(f, J, b, R)\n\n// A sized generator of non-empty sets\nGen.setOf1(Gen.alphaChar)    \n// Sample Output: Set(Y), Set(L, S), Set(i), Set(H), Set(r, Z, z)\n\n// A generator of sets whose size falls within the specified bounds.\nGen.setOfBounded(1, 3)(Gen.alphaChar)\n// Sample Output: Set(Q), Set(q, J), Set(V, t, h), Set(c), Set(X, O)\n\n// A generator of sets of the specified size.\nGen.setOfN(2)(Gen.alphaChar)\n")),(0,r.kt)("h2",{id:"bounded-generator"},"Bounded Generator"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.bounded")," constructor is a generator whose size falls within the specified bounds:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"Gen.bounded(2, 5)(Gen.stringN(_)(Gen.alphaChar))\n  .runCollectN(5)\n")),(0,r.kt)("h2",{id:"suspended-generator"},"Suspended Generator"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.suspend")," constructs a generator lazily. This is useful to avoid infinite recursion when creating generators that refer to themselves."),(0,r.kt)("h2",{id:"unfold-generator"},"Unfold Generator"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"unfoldGen")," takes the initial state and depending on the previous state, it determines what will be the next generated value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def unfoldGen[R, S, A](s: S)(f: S => Gen[R, (S, A)]): Gen[R, List[A]]\n")),(0,r.kt)("p",null,"Assume we want to test the built-in scala stack (",(0,r.kt)("inlineCode",{parentName:"p"},"scala.collection.mutable.Stack"),"). One way to do that is to create an acceptable series of push and pop commands, and then check that the stack doesn't throw any exception by executing these commands:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait Command\ncase object Pop                    extends Command\nfinal case class Push(value: Char) extends Command\n\nval genPop:  Gen[Any, Command]    = Gen.const(Pop)\ndef genPush: Gen[Any, Command] = Gen.alphaChar.map(Push)\n\nval genCommands: Gen[Any, List[Command]] =\n  Gen.unfoldGen(0) { n =>\n    if (n <= 0)\n      genPush.map(command => (n + 1, command))\n    else\n      Gen.oneOf(\n        genPop.map(command => (n - 1, command)),\n        genPush.map(command => (n + 1, command))\n      )\n  }\n")),(0,r.kt)("p",null,"We are now ready to test the generated list of commands:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test.{ test, _ }\n\ntest("unfoldGen") {\n  check(genCommands) { commands =>\n    val stack = scala.collection.mutable.Stack.empty[Int]\n    commands.foreach {\n      case Pop => stack.pop()\n      case Push(value) => stack.push(value)\n    }\n    assertCompletes\n  }\n}\n')),(0,r.kt)("h2",{id:"from-a-zio-effect"},"From a ZIO Effect"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.fromZIO")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val gen: Gen[Any, Int] = Gen.fromZIO(Random.nextInt) \n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.fromZIOSample")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val gen: Gen[Any, Int] =\n  Gen.fromZIOSample(\n    Random.nextInt.map(Sample.shrinkIntegral(0))\n  )\n")))),(0,r.kt)("h2",{id:"from-a-random-effect"},"From a Random Effect"),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.fromRandom")," \u2014 Constructs a generator from a function that uses randomness:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val gen: Gen[Any, Int] = Gen.fromRandom(_.nextInt) \n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.fromRandomSample")," \u2014 Constructs a generator from a function that uses randomness to produce a sample:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val gen: Gen[Any, Int] =\n  Gen.fromRandomSample(\n    _.nextIntBounded(20).map(Sample.shrinkIntegral(0))\n  )\n")))),(0,r.kt)("h2",{id:"uniform-and-non-uniform-generators"},"Uniform and Non-uniform Generators"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.uniform")," \u2014 A generator of uniformly distributed doubles between ","[0, 1]",".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.weighted")," \u2014 A generator which chooses one of the given generators according to their weights. For example, the following generator will generate 90% true and 10% false values:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val trueFalse = Gen.weighted((Gen.const(true), 9), (Gen.const(false), 1))\ntrueFalse.runCollectN(10).debug\n// Sample Output: List(false, false, false, false, false, false, false, false, true, false)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.exponential")," \u2014 A generator of exponentially distributed doubles with mean ",(0,r.kt)("inlineCode",{parentName:"p"},"1"),":"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"Gen.exponential.map(x => math.round(x * 100) / 100.0)\n  .runCollectN(10)\n  .debug\n// Sample Output: List(0.22, 3.02, 1.96, 1.13, 0.81, 0.92, 1.7, 1.47, 1.55, 0.46)\n")))),(0,r.kt)("h2",{id:"generating-datetime-types"},"Generating Date/Time Types"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Date/Time Types"),(0,r.kt)("th",{parentName:"tr",align:null},"Generators"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"java.time.DayOfWeek")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.dayOfWeek"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"java.time.Month")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.month"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"java.time.Year")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.year"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"java.time.Instant")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.instant"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"java.time.MonthDay")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.monthDay"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"java.time.YearMonth")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.yearMonth"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"java.time.ZoneId")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.zoneId"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"java.time.ZoneOffset")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.zoneOffset"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"java.time.ZonedDateTime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.zonedDateTime"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"java.time.OffsetTime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.offsetTime"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"java.time.OffsetDateTime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.offsetDateTime"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"java.time.Period")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.period"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"java.time.LocalDate")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.localDate"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"java.time.LocalDateTime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.localDateTime"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"java.time.LocalTime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.localTime"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"zio.duration.Duration")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Gen.finiteDuration"))))),(0,r.kt)("h2",{id:"function-generators"},"Function Generators"),(0,r.kt)("p",null,"To test some properties, we need to generate functions. There are two types of function generators:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.function")," \u2014 It takes a generator of type ",(0,r.kt)("inlineCode",{parentName:"p"},"B")," and produces a generator of functions from ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"B"),":"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def function[R, A, B](gen: Gen[R, B]): Gen[R, A => B]\n")))),(0,r.kt)("p",null,"Two ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," values will be considered to be equal, and thus will be guaranteed to generate the same ",(0,r.kt)("inlineCode",{parentName:"p"},"B")," value, if they have the same\n",(0,r.kt)("inlineCode",{parentName:"p"},"hashCode"),"."),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.functionWith")," \u2014 It takes a generator of type ",(0,r.kt)("inlineCode",{parentName:"p"},"B")," and also a hash function for ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," values, and produces a generator of functions from ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"B"),":"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def functionWith[R, A, B](gen: Gen[R, B])(hash: A => Int): Gen[R, A => B]\n")))),(0,r.kt)("p",null,"Two ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," values will be considered to be equal, and thus will be guaranteed to generate the same ",(0,r.kt)("inlineCode",{parentName:"p"},"B")," value, if they have the same hash. This is useful when ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," does not implement ",(0,r.kt)("inlineCode",{parentName:"p"},"hashCode")," in a way that is consistent with equality."),(0,r.kt)("p",null,"Accordingly, ZIO Test provides a variety of function generators for ",(0,r.kt)("inlineCode",{parentName:"p"},"Function2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Function3"),", ..., and also the ",(0,r.kt)("inlineCode",{parentName:"p"},"PartialFunction"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.function2")," \u2014  Gen","[R, C]"," => Gen","[R, (A, B) => C]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.functionWith2")," \u2014 Gen","[R, B]"," => ((A, B) => Int) => Gen","[R, (A, B) => C]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.partialFunction")," \u2014 Gen","[R, B]"," => Gen[R, PartialFunction","[A, B]","]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Gen.partialFunctionWith")," \u2014 Gen","[R, B]"," => (A => Int) => Gen[R, PartialFunction","[A, B]","]")),(0,r.kt)("p",null,"Let's write a test for ",(0,r.kt)("inlineCode",{parentName:"p"},"ZIO.foldLeft")," operator. This operator has the following signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def foldLeft[R, E, S, A](in: => Iterable[A])(zero: => S)(f: (S, A) => ZIO[R, E, S]): ZIO[R, E, S]\n")),(0,r.kt)("p",null,"We want to test the following property:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"\u2200 (in, zero, f) => ZIO.foldLeft(in)(zero)(f) == ZIO(List.foldLeft(in)(zero)(f))\n")),(0,r.kt)("p",null,"To test this property, we have an input of type ",(0,r.kt)("inlineCode",{parentName:"p"},"(Int, Int) => Int"),". So we need a Function2 generator of integers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val func2: Gen[Any, (Int, Int) => Int] = Gen.function2(Gen.int)\n")),(0,r.kt)("p",null,"Now we can test this property:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test.{test, _}\n\ntest("ZIO.foldLeft should have the same result with List.foldLeft") {\n  check(Gen.listOf(Gen.int), Gen.int, func2) { case (in, zero, f) =>\n    assertZIO(\n      ZIO.foldLeft(in)(zero)((s, a) => ZIO.attempt(f(s, a)))\n    )(Assertion.equalTo(\n      in.foldLeft(zero)((s, a) => f(s, a)))\n    )\n  }\n}\n')),(0,r.kt)("h2",{id:"generating-zio-values"},"Generating ZIO Values"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Successful effects (",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.successes"),"):"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val gen: Gen[Any, UIO[Int]] = Gen.successes(Gen.int(-10, 10))\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Failed effects (",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.failures"),"):"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val gen: Gen[Any, IO[String, Nothing]] = Gen.failures(Gen.string)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Died effects (",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.died"),"):"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val gen: Gen[Any, UIO[Nothing]] = Gen.died(Gen.throwable)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Cause values (",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.causes"),"):"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val causes: Gen[Any, Cause[String]] = \n  Gen.causes(Gen.string, Gen.throwable)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Chained effects (",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.chined"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.chainedN"),"): A generator of effects that are the result of chaining the specified effect with itself a random number of times."))),(0,r.kt)("p",null,"Let's see some example of chained ZIO effects:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"import zio._\nval effect1 = ZIO(2).flatMap(x => ZIO(x * 2))\nval effect2 = ZIO(1) *> ZIO(2)\n")),(0,r.kt)("p",null,"By using ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.chaned")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.chanedN")," generator, we can create generators of chained effects:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val chained : Gen[Any, ZIO[Any, Nothing, Int]] = \n  Gen.chained(Gen.successes(Gen.int))\n  \nval chainedN: Gen[Any, ZIO[Any, Nothing, Int]] = \n  Gen.chainedN(5)(Gen.successes(Gen.int))\n")),(0,r.kt)("ol",{start:6},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Concurrent effects (",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.concurrent"),"): A generator of effects that are the result of applying concurrency combinators to the specified effect that are guaranteed not to change its value."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val random  : Gen[Any, UIO[Int]] = Gen.successes(Gen.int).flatMap(Gen.concurrent)\nval constant: Gen[Any, UIO[Int]]    = Gen.concurrent(ZIO(3))\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Parallel effects (",(0,r.kt)("inlineCode",{parentName:"p"},"Gen.parallel"),"): A generator of effects that are the result of applying parallelism combinators to the specified effect that are guaranteed not to change its value."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},'val random: Gen[Any, UIO[String]] =\n  Gen.successes(Gen.string).flatMap(Gen.parallel)\n  \nval constant: Gen[Any, UIO[String]] =\n  Gen.parallel(ZIO("Hello"))\n')))),(0,r.kt)("h2",{id:"generating-compound-types"},"Generating Compound Types"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"tuples \u2014 We can combine generators using for-comprehension syntax and tuples:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val tuples: Gen[Any, (Int, Double)] =\n  for {\n    a <- Gen.int\n    b <- Gen.double\n  } yield (a, b)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.oneOf")," \u2014 It takes variable number of generators and select one of them:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"sealed trait Color\ncase object Red extends Color\ncase object Blue extends Color\ncase object Green extends Color\n\nGen.oneOf(Gen.const(Red), Gen.const(Blue), Gen.const(Green))\n// Sample Output: Green, Green, Red, Green, Red\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.option")," \u2014 A generator of ",(0,r.kt)("em",{parentName:"p"},"optional")," values:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val intOptions: Gen[Any, Option[Int]] = Gen.option(Gen.int)\nval someInts:   Gen[Any, Option[Int]] = Gen.some(Gen.int)\nval nons:       Gen[Any, Option[Nothing]]     = Gen.none\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.either")," \u2014 A generator of ",(0,r.kt)("em",{parentName:"p"},"either")," values:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val char: Gen[Any, Either[Char, Char]] =\n  Gen.either(Gen.numericChar, Gen.alphaChar)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.collectAll")," \u2014 Composes the specified generators to create a ",(0,r.kt)("em",{parentName:"p"},"cartesian product of elements")," with the specified function:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val gen: ZIO[Any, Nothing, List[List[Int]]] =\n  Gen.collectAll(\n    List(\n      Gen.fromIterable(List(1, 2)),\n      Gen.fromIterable(List(3)),\n      Gen.fromIterable(List(4, 5))\n    )\n  ).runCollect\n// Output:\n// List(\n//  List(1, 3, 4),\n//  List(1, 3, 5),\n//  List(2, 3, 4),\n//  List(2, 3, 5)\n//)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.concatAll")," \u2014 Combines the specified deterministic generators to return a new deterministic generator that generates all the values generated by the specified generators:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"val gen: ZIO[Any, Nothing, List[Int]] =\n  Gen.concatAll(\n    List(\n      Gen.fromIterable(List(1, 2)),\n      Gen.fromIterable(List(3)),\n      Gen.fromIterable(List(4, 5))\n    )\n  ).runCollect\n// Output: List(1, 2, 3, 4, 5)\n")))),(0,r.kt)("h2",{id:"sized-generators"},"Sized Generators"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.sized")," \u2014 A sized generator takes a function from ",(0,r.kt)("inlineCode",{parentName:"p"},"Int")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen[R, A]")," and creates a generator by applying a size to that function:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"Gen.sized(Gen.int(0, _))\n  .runCollectN(10)\n  .provideCustomLayer(Sized.live(5))\n  .debug\n// Sample Output: List(5, 4, 1, 2, 0, 4, 2, 0, 1, 2)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.size")," \u2014 A generator which accesses the ",(0,r.kt)("em",{parentName:"p"},"size")," from the environment and generates that:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"Gen.size\n  .runCollectN(5)\n  .provideCustomLayer(Sized.live(100))\n  .debug\n// Output: List(100, 100, 100, 100, 100)\n")))),(0,r.kt)("p",null,"There are also three sized generators, named ",(0,r.kt)("em",{parentName:"p"},"small"),", ",(0,r.kt)("em",{parentName:"p"},"medium")," and ",(0,r.kt)("em",{parentName:"p"},"large"),", that use an exponential distribution of size values:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.small")," \u2014 The values generated will be strongly concentrated towards the lower end of the range but a few larger values will still be generated:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"Gen.small(Gen.const(_))\n  .runCollectN(10)\n  .provideCustomLayer(Sized.live(1000))\n  .debug\n// Output: List(6, 39, 73, 3, 57, 51, 40, 12, 110, 46)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.medium")," \u2014 The majority of sizes will be towards the lower end of the range but some larger sizes will be generated as well:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"Gen.medium(Gen.const(_))\n  .runCollectN(10)\n  .provideCustomLayer(Sized.live(1000))\n  .debug\n// Output: List(93, 42, 58, 228, 42, 5, 12, 214, 106, 79)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Gen.large")," \u2014 Uses a uniform distribution of size values. A large number of larger sizes will be generated:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:compile-only","mdoc:compile-only":!0},"Gen.large(Gen.const(_))\n  .runCollectN(10)\n  .provideCustomLayer(Sized.live(1000))\n  .debug\n// Output: List(797, 218, 596, 278, 301, 779, 165, 486, 695, 788)\n")))))}c.isMDXComponent=!0}}]);