"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[49274],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},g=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),g=i,h=u["".concat(s,".").concat(g)]||u[g]||f[g]||a;return n?r.createElement(h,o(o({ref:t},c),{},{components:n})):r.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=g;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<a;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}g.displayName="MDXCreateElement"},75291:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>f,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var r=n(87462),i=(n(67294),n(3905));const a={id:"index",title:"Introduction to ZIO Profiling",sidebar_label:"ZIO Profiling"},o=void 0,l={unversionedId:"zio-profiling/index",id:"zio-profiling/index",title:"Introduction to ZIO Profiling",description:"ZIO Profiling is a collection of different profilers for better understanding the runtime behavior of ZIO programs.",source:"@site/docs/zio-profiling/index.md",sourceDirName:"zio-profiling",slug:"/zio-profiling/",permalink:"/zio-profiling/",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-profiling/index.md",tags:[],version:"current",frontMatter:{id:"index",title:"Introduction to ZIO Profiling",sidebar_label:"ZIO Profiling"},sidebar:"ecosystem-sidebar",previous:{title:"Other",permalink:"/zio-process/other"},next:{title:"Resources",permalink:"/zio-profiling/resources"}},s={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Installation",id:"installation",level:2},{value:"Profiling an application and displaying a flamegraph",id:"profiling-an-application-and-displaying-a-flamegraph",level:2},{value:"Causal Profiling",id:"causal-profiling",level:2},{value:"Compiler Plugin",id:"compiler-plugin",level:2},{value:"Jmh Support",id:"jmh-support",level:2}],c={toc:p},u="wrapper";function f(e){let{components:t,...a}=e;return(0,i.kt)(u,(0,r.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"ZIO Profiling is a collection of different profilers for better understanding the runtime behavior of ZIO programs."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/zio/zio/wiki/Project-Stages"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/Project%20Stage-Concept-orange.svg",alt:"Concept"}))," ",(0,i.kt)("img",{parentName:"p",src:"https://github.com/zio/zio-profiling/workflows/CI/badge.svg",alt:"CI Badge"})," ",(0,i.kt)("a",{parentName:"p",href:"https://oss.sonatype.org/content/repositories/releases/dev/zio/zio-profiling_2.13/"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/nexus/r/https/oss.sonatype.org/dev.zio/zio-profiling_2.13.svg?label=Sonatype%20Release",alt:"Sonatype Releases"}))," ",(0,i.kt)("a",{parentName:"p",href:"https://oss.sonatype.org/content/repositories/snapshots/dev/zio/zio-profiling_2.13/"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/nexus/s/https/oss.sonatype.org/dev.zio/zio-profiling_2.13.svg?label=Sonatype%20Snapshot",alt:"Sonatype Snapshots"}))," ",(0,i.kt)("a",{parentName:"p",href:"https://javadoc.io/doc/dev.zio/zio-profiling-docs_2.13"},(0,i.kt)("img",{parentName:"a",src:"https://javadoc.io/badge2/dev.zio/zio-profiling-docs_2.13/javadoc.svg",alt:"javadoc"}))," ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zio/zio-profiling"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/github/stars/zio/zio-profiling?style=social",alt:"ZIO Profiling"}))),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Normal cpu profilers cannot really be used to profile code using an effect system. Profilers operating on a thread level will only see that threads are spending time in the evaluation loop of the effect system, producing profiles that are not useful for application developers."),(0,i.kt)("p",null,"Instead, profiling a program written using an effect system requires a profiler that is aware of the effect system and can report where the effects were constructed / which user code the effect system is spending time on. ZIO profiling aims to be that library for the ZIO effect system."),(0,i.kt)("p",null,"The library focuses exclusively on cpu profiling. For heap profiling please consider using other tools such as async-profiler or VisualVM."),(0,i.kt)("h2",{id:"installation"},"Installation"),(0,i.kt)("p",null,"ZIO Profiling requires you to add both the main library and optionally the compiler plugin to your build.sbt:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio-profiling" % "0.2.1"\nlibraryDependencies += compilerPlugin("dev.zio" %% "zio-profiling-tagging-plugin" % "0.2.1")\n')),(0,i.kt)("h2",{id:"profiling-an-application-and-displaying-a-flamegraph"},"Profiling an application and displaying a flamegraph"),(0,i.kt)("p",null,"For this example we are going to use the sampling profiler to measure the cpu time used by parts of a zio program.\nAll needed definitions can be imported using:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.profiling.sampling._\n")),(0,i.kt)("p",null,"The program we want to instrument simulates performing a short and then a long computation concurrently:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val fast = ZIO.succeed(Thread.sleep(400))\n\nval slow = ZIO.succeed(Thread.sleep(600))\n\nval program = fast <&> slow\n")),(0,i.kt)("p",null,"In order to profile the program, we wrap it with the ",(0,i.kt)("inlineCode",{parentName:"p"},"profile")," method of the sampling profiler. Once the effect has completed\nthis will yield the profiling result. We can either manipulate the result in Scala or render it in a number of standard\nformats. In this case we are going to write it out in a format supported by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/brendangregg/FlameGraph"},"https://github.com/brendangregg/FlameGraph"),", so we\ncan visualize it as a flamegraph."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'SamplingProfiler\n  .profile(program)\n  .flatMap(_.stackCollapseToFile("profile.folded"))\n')),(0,i.kt)("p",null,"The resulting file can be converted to a svg using the flamegraph.pl script (",(0,i.kt)("a",{target:"_blank",href:n(97549).Z},"preview"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"flamegraph.pl ./examples/profile.folded > profile.svg\n")),(0,i.kt)("h2",{id:"causal-profiling"},"Causal Profiling"),(0,i.kt)("p",null,"ZIO Profiling includes experimental support for causal profiling inspired by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/plasma-umass/coz"},"coz"),"."),(0,i.kt)("p",null,"Usage is similar to the sampling profiler, but instead of displaying the time spent running the program it will give recommendations\nwhich parts of the program to focus on during performance tuning for biggest effect. It achieves this by iteratively artificially speeding\nup parts of the program (by slowing down all parts running concurrently) and measuring the effect on overall runtime."),(0,i.kt)("p",null,"Check out the paper linked in the coz repository for more details about the idea."),(0,i.kt)("p",null,"We can bring the causal profiler into scope with the following import:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.profiling.causal._\n")),(0,i.kt)("p",null,"This time we are using a slightly more complicated example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val fast = ZIO.succeed(Thread.sleep(40))\n\nval slow1 = ZIO.succeed(Thread.sleep(20))\n\nval slow2 = ZIO.succeed(Thread.sleep(60))\n\nval slow = slow1 <&> slow2\n\nval program = (fast <&> slow) *>\n  CausalProfiler.progressPoint("iteration done")\n\nCausalProfiler(iterations = 100)\n  .profile(program.forever)\n  .flatMap(_.renderToFile("profile.coz"))\n')),(0,i.kt)("p",null,"We also need to weave the ",(0,i.kt)("inlineCode",{parentName:"p"},"progressPoint")," effect into our program. It will be used by the causal profiler to measure progress\nof the overall program."),(0,i.kt)("p",null,"Finally, we can run the program using the causal profiler (notice the use of ",(0,i.kt)("inlineCode",{parentName:"p"},"program.forever")," -- the profiler will automatically interrupt the program, until then it has to keep running)\nand save the result to a file."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'CausalProfiler(iterations = 100)\n  .profile(prog.forever)\n  .flatMap(_.renderToFile("profile.coz"))\n')),(0,i.kt)("p",null,"The file can be viewed using the ",(0,i.kt)("a",{parentName:"p",href:"https://plasma-umass.org/coz/"},"Coz Visualizer")," (",(0,i.kt)("a",{target:"_blank",href:n(38506).Z},"preview"),").\nAs you can see, the profiler correctly tells you that you can get up to a 33% speedup by optimizing the ",(0,i.kt)("inlineCode",{parentName:"p"},"slow2")," effect,\nbut it's impossible to get a speedup any other way."),(0,i.kt)("h2",{id:"compiler-plugin"},"Compiler Plugin"),(0,i.kt)("p",null,"In order to produce actionable output, a profiler not only needs to know which line of code is currently running, but also how that location was reached."),(0,i.kt)("p",null,"Most profilers rely on the function call hierarchy to determine this information, but the call stack is not really useful for programs using functional effect systems. The reason for this is that the normal function calls are only used to build up the program as a datastructure -- not execute it."),(0,i.kt)("hr",null),(0,i.kt)("p",null,"It's possible to restore the proper callstack while the effects are actually getting executed (this is the approach taken by the zio.Trace machinery), but that is not the approach taken by ZIO Profiling."),(0,i.kt)("p",null,"Instead, zio-profiling tracks the current 'callstack' of your program using FiberRefs. For this approach to work every effect should be manually annotated using ",(0,i.kt)("inlineCode",{parentName:"p"},"zio.profiling.CostCenter.withChildCostCenter"),", which will result in a hierarchy of effect tags at runtime."),(0,i.kt)("p",null,"As this requires modification of large parts of user programs and is bad UX, zio-profiling ships with a compiler plugin (zio-profiling-tagging-plugin) that automates this. Every ",(0,i.kt)("inlineCode",{parentName:"p"},"def")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"val")," that returns a zio effect will be rewritten to be properly tagged. Consider this example for the rewrite that happens:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val testEffect = ZIO.unit\n\n// gets rewritten to\n\nval testEffect = CostCenter.withChildCostCenter("foo.Foo.testEffect(Foo.scala:12)")(ZIO.unit)\n')),(0,i.kt)("p",null,"To enable the compiler plugin, add the following to the sbt module ",(0,i.kt)("strong",{parentName:"p"},"containing the code you want to profile"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'compilerPlugin("dev.zio" %% "zio-profiling-tagging-plugin" % "0.2.1")\n\n')),(0,i.kt)("h2",{id:"jmh-support"},"Jmh Support"),(0,i.kt)("p",null,"ZIO Profiling offers an integration with the Java Microbenchmark Harness (JMH). In order to profile a jmh benchmark, first ensure that the sources are properly tagged using the tagging plugin. Next, add a dependency to the jmh module to your benchmarking module:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio-profiling-jmh" % "0.2.1"\n')),(0,i.kt)("p",null,"In your actual benchmarks, ensure that you are running ZIO effects using the methods in ",(0,i.kt)("inlineCode",{parentName:"p"},"zio.profiling.jmh.BenchmarkUtils"),". A possible benchmark might look like this"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'package zio.redis.benchmarks.lists\n\nimport org.openjdk.jmh.annotations._\nimport zio.profiling.jmh.BenchmarkUtils\nimport zio.redis._\nimport zio.redis.benchmarks._\nimport zio.{Scope => _, _}\n\nimport java.util.concurrent.TimeUnit\n\n@State(Scope.Thread)\n@BenchmarkMode(Array(Mode.Throughput))\n@OutputTimeUnit(TimeUnit.SECONDS)\n@Measurement(iterations = 15)\n@Warmup(iterations = 15)\n@Fork(2)\nclass BlMoveBenchmarks extends BenchmarkRuntime {\n\n  @Param(Array("500"))\n  var count: Int = _\n\n  private var items: List[String] = _\n\n  private val key = "test-list"\n\n  private def execute(query: ZIO[Redis, RedisError, Unit]): Unit =\n    BenchmarkUtils.unsafeRun(query.provideLayer(BenchmarkRuntime.Layer))\n\n  @Setup(Level.Trial)\n  def setup(): Unit = {\n    items = (0 to count).toList.map(_.toString)\n    execute(ZIO.serviceWithZIO[Redis](_.rPush(key, items.head, items.tail: _*).unit))\n  }\n\n  @TearDown(Level.Trial)\n  def tearDown(): Unit =\n    execute(ZIO.serviceWithZIO[Redis](_.del(key).unit))\n\n  @Benchmark\n  def zio(): Unit = execute(\n    ZIO.foreachDiscard(items)(_ =>\n      ZIO.serviceWithZIO[Redis](_.blMove(key, key, Side.Left, Side.Right, 1.second).returning[String])\n    )\n  )\n}\n')),(0,i.kt)("p",null,"Once the benchmark is set up properly, you can specify the profiler from the jmh command line. Using sbt-jmh, it might look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Jmh/run -i 3 -wi 3 -f1 -t1 -prof zio.profiling.jmh.JmhZioProfiler zio.redis.benchmarks.lists.BlMoveBenchmarks.zio\n")),(0,i.kt)("p",null,"The profiler output will be written to a file in the directory the JVM has been invoked from."))}f.isMDXComponent=!0},38506:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/files/example_causal_profile-6a3eabcc31a4105c0dc877acc95a0520.png"},97549:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/files/example_sampling_profile-4d4524da9bfbbdf983eac2f2fc075225.svg"}}]);