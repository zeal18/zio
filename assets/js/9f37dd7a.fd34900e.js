"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[21767],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>g});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var d=o.createContext({}),l=function(e){var n=o.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=l(e.components);return o.createElement(d.Provider,{value:n},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,d=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=l(t),m=a,g=p["".concat(d,".").concat(m)]||p[m]||u[m]||r;return t?o.createElement(g,i(i({ref:n},c),{},{components:t})):o.createElement(g,i({ref:n},c))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=m;var s={};for(var d in n)hasOwnProperty.call(n,d)&&(s[d]=n[d]);s.originalType=e,s[p]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<r;l++)i[l]=t[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1581:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var o=t(87462),a=(t(67294),t(3905));const r={id:"encode-and-decode-json-data",title:"Tutorial: How to Encode and Decode JSON Data?",sidebar_label:"Encoding and Decoding JSON Data"},i=void 0,s={unversionedId:"guides/tutorials/encode-and-decode-json-data",id:"guides/tutorials/encode-and-decode-json-data",title:"Tutorial: How to Encode and Decode JSON Data?",description:"Introduction",source:"@site/docs/guides/tutorials/encode-and-decode-json-data.md",sourceDirName:"guides/tutorials",slug:"/guides/tutorials/encode-and-decode-json-data",permalink:"/guides/tutorials/encode-and-decode-json-data",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/guides/tutorials/encode-and-decode-json-data.md",tags:[],version:"current",frontMatter:{id:"encode-and-decode-json-data",title:"Tutorial: How to Encode and Decode JSON Data?",sidebar_label:"Encoding and Decoding JSON Data"},sidebar:"guides-sidebar",previous:{title:"Making a ZIO application configurable",permalink:"/guides/tutorials/configurable-zio-application"},next:{title:"Enable Logging in a ZIO Application",permalink:"/guides/tutorials/enable-logging-in-a-zio-application"}},d={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Running Examples",id:"running-examples",level:2},{value:"What is ZIO JSON?",id:"what-is-zio-json",level:2},{value:"Adding Dependencies",id:"adding-dependencies",level:2},{value:"JsonEncoder and JsonDecoder",id:"jsonencoder-and-jsondecoder",level:2},{value:"Built-in Decoders and Encoders",id:"built-in-decoders-and-encoders",level:2},{value:"Simple Values",id:"simple-values",level:3},{value:"Higher-kinded Types",id:"higher-kinded-types",level:3},{value:"How to Define Custom Decoder/Encoder?",id:"how-to-define-custom-decoderencoder",level:2},{value:"Writing From Scratch",id:"writing-from-scratch",level:3},{value:"Automatic Derivation of Codecs (macros)",id:"automatic-derivation-of-codecs-macros",level:3},{value:"Mapping Existing Codecs to Complex Types",id:"mapping-existing-codecs-to-complex-types",level:3},{value:"Conclusion",id:"conclusion",level:2}],c={toc:l},p="wrapper";function u(e){let{components:n,...t}=e;return(0,a.kt)(p,(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"In this article, we will cover how to encode and decode JSON data."),(0,a.kt)("h2",{id:"running-examples"},"Running Examples"),(0,a.kt)("p",null,"To access the code examples, you can clone the ",(0,a.kt)("a",{parentName:"p",href:"http://github.com/zio/zio-quickstarts"},"ZIO Quickstarts")," project:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"$ git clone git@github.com:zio/zio-quickstarts.git \n$ cd zio-quickstarts/zio-quickstart-encode-decode-json-data\n")),(0,a.kt)("p",null,"To run all tests, execute the following command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"$ sbt Test/runMain dev.zio.quickstart.JsonSpec\n")),(0,a.kt)("h2",{id:"what-is-zio-json"},"What is ZIO JSON?"),(0,a.kt)("p",null,"ZIO JSON is a library that provides facilities for writing efficient JSON encoders and decoders. In this article, we will use this library to work with JSON data. To learn more about that, please refer to the ",(0,a.kt)("a",{parentName:"p",href:"https://zio.github.io/zio-json/"},"ZIO JSON")," documentation."),(0,a.kt)("h2",{id:"adding-dependencies"},"Adding Dependencies"),(0,a.kt)("p",null,"To use ZIO JSON, we need to add the following dependency to our ",(0,a.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio-json" % "0.3.0-RC10"\n')),(0,a.kt)("h2",{id:"jsonencoder-and-jsondecoder"},"JsonEncoder and JsonDecoder"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"JsonEncoder")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"JsonDecoder")," are the two main types in ZIO JSON. They are used to encode and decode JSON data. Let's see how they are defined (with simplified syntax):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"trait JsonDecoder[A] {\n  def decodeJson(str: CharSequence): Either[String, A]\n}\n\ntrait JsonEncoder[A] {\n  def encodeJson(a: A): CharSequence\n}\n")),(0,a.kt)("p",null,"We can say for a type ",(0,a.kt)("inlineCode",{parentName:"p"},"A"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A ",(0,a.kt)("strong",{parentName:"li"},"decoder")," is a function that takes a ",(0,a.kt)("inlineCode",{parentName:"li"},"CharSequence")," and returns a ",(0,a.kt)("inlineCode",{parentName:"li"},"Right")," with the decoded value or a ",(0,a.kt)("inlineCode",{parentName:"li"},"Left")," with an error message."),(0,a.kt)("li",{parentName:"ul"},"An ",(0,a.kt)("strong",{parentName:"li"},"encoder")," is a function that takes a value of type ",(0,a.kt)("inlineCode",{parentName:"li"},"A")," and returns a ",(0,a.kt)("inlineCode",{parentName:"li"},"CharSequence")," that represents the encoded value (JSON string).")),(0,a.kt)("p",null,"If we provide an instance of ",(0,a.kt)("inlineCode",{parentName:"p"},"JsonDecoder")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"JsonEncoder")," for a type ",(0,a.kt)("inlineCode",{parentName:"p"},"A"),", we can encode and decode JSON data of that type."),(0,a.kt)("h2",{id:"built-in-decoders-and-encoders"},"Built-in Decoders and Encoders"),(0,a.kt)("h3",{id:"simple-values"},"Simple Values"),(0,a.kt)("p",null,"The ZIO JSON library provides a default implementation for most of the primitive types like ",(0,a.kt)("inlineCode",{parentName:"p"},"Int"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"String"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Boolean"),", etc."),(0,a.kt)("p",null,"Let's start test some simple examples:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.json._\n\ntest("decode from string") {\n  val json    = "\\"John Doe\\""\n  val decoded = JsonDecoder[String].decodeJson(json)\n\n  assertTrue(decoded == Right("John Doe"))\n}\n\ntest("decode from int") {\n  val json    = "123"\n  val decoded = JsonDecoder[Int].decodeJson(json)\n\n  assertTrue(decoded == Right(123))\n}\n')),(0,a.kt)("h3",{id:"higher-kinded-types"},"Higher-kinded Types"),(0,a.kt)("p",null,"It also supports higher-kinded types like ",(0,a.kt)("inlineCode",{parentName:"p"},"List")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Option"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.json._\nimport zio.test._\nimport zio.test.Assertion._\n\ntest("decode from optional value") {\n  val json = "null"\n  val decoded = JsonDecoder[Option[Int]].decodeJson(json)\n  assertTrue(decoded == Right(None))\n} +\ntest("decode from array of ints") {\n  val json    = "[1, 2, 3]"\n  val decoded = json.fromJson[Array[Int]]\n\n  assert(decoded)(isRight(equalTo(Array(1, 2, 3))))\n}\n')),(0,a.kt)("h2",{id:"how-to-define-custom-decoderencoder"},"How to Define Custom Decoder/Encoder?"),(0,a.kt)("h3",{id:"writing-from-scratch"},"Writing From Scratch"),(0,a.kt)("p",null,"To have a new instance we implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"JsonEncoder")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"JsonDecoder")," interfaces for a type ",(0,a.kt)("inlineCode",{parentName:"p"},"A"),"."),(0,a.kt)("p",null,"For example, if we have a type ",(0,a.kt)("inlineCode",{parentName:"p"},"Person")," we can create instances of ",(0,a.kt)("inlineCode",{parentName:"p"},"JsonEncoder")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"JsonDecoder")," for this type as below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.json._\nimport zio.json.internal.{Write, RetractReader}\n\ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val encoder: JsonEncoder[Person] =\n    new JsonEncoder[Person] {\n      override def unsafeEncode(a: Person, indent: Option[Int], out: Write): Unit = ???\n    }\n  implicit val decoder: JsonDecoder[Person] =\n    new JsonDecoder[Person] {\n      override def unsafeDecode(trace: List[JsonError], in: RetractReader): Person = ???\n    }\n}\n")),(0,a.kt)("p",null,"Writing encoders and decoders from scratch is a complicated task and is not recommended for regular usage. So we don't deep into it furthermore."),(0,a.kt)("h3",{id:"automatic-derivation-of-codecs-macros"},"Automatic Derivation of Codecs (macros)"),(0,a.kt)("p",null,"By using macro utilities, we can derive the instances of ",(0,a.kt)("inlineCode",{parentName:"p"},"JsonEncoder")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"JsonDecoder")," for a case class using ",(0,a.kt)("inlineCode",{parentName:"p"},"DeriveJsonDecoder.gen[A]")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"DeriveJsonEncoder.gen[A]")," macros:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.json._\n\ntest("automatic derivation for case classes") {\n  case class Person(name: String, age: Int)\n  object Person {\n    implicit val decoder: JsonDecoder[Person] = DeriveJsonDecoder.gen[Person]\n    implicit val encoder: JsonEncoder[Person] = DeriveJsonEncoder.gen[Person]\n  }\n\n  assertTrue((Person("John", 42).toJson == "{\\"name\\":\\"John\\",\\"age\\":42}")\n    && ("{\\"name\\":\\"John\\",\\"age\\":42}".fromJson[Person] == Right(Person("John", 42)))\n  )\n}\n')),(0,a.kt)("p",null,"Let's try a more complex example. Assume we have a data type ",(0,a.kt)("inlineCode",{parentName:"p"},"Fruit")," that is written as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait Fruit extends Product with Serializable\ncase class Banana(curvature: Double) extends Fruit\ncase class Apple (poison: Boolean)   extends Fruit\n")),(0,a.kt)("p",null,"We can generate encoder and decoder for this ADT using the macros:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.json._\n\nobject Fruit {\n  implicit val decoder: JsonDecoder[Fruit] =\n    DeriveJsonDecoder.gen[Fruit]\n\n  implicit val encoder: JsonEncoder[Fruit] =\n    DeriveJsonEncoder.gen[Fruit]\n}\n")),(0,a.kt)("p",null,"So then we can have the following tests:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.json._\n\ntest("decode from custom adt") {\n  val json =\n    """\n      |[\n      |  {\n      |    "Apple": {\n      |      "poison": false\n      |    }\n      |  },\n      |  {\n      |    "Banana": {\n      |      "curvature": 0.5\n      |    }\n      |  }\n      |]\n      |""".stripMargin\n\n  val decoded = json.fromJson[List[Fruit]]\n  assertTrue(decoded == Right(List(Apple(false), Banana(0.5))))\n} +\ntest("roundtrip custom adt") {\n  val fruits = List(Apple(false), Banana(0.5))\n  val json = fruits.toJson\n  val roundTrip = json.fromJson[List[Fruit]]\n  assertTrue(roundTrip == Right(fruits))\n}\n')),(0,a.kt)("h3",{id:"mapping-existing-codecs-to-complex-types"},"Mapping Existing Codecs to Complex Types"),(0,a.kt)("p",null,"If we have ",(0,a.kt)("inlineCode",{parentName:"p"},"JsonDecoder[A]")," we can map its ",(0,a.kt)("strong",{parentName:"p"},"output")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"JsonDecoder[B]")," by providing a function ",(0,a.kt)("inlineCode",{parentName:"p"},"A => B")," as an argument to ",(0,a.kt)("inlineCode",{parentName:"p"},"map")," operation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"trait JsonDecoder[A] {\n  def map[B](f: A => B): JsonDecoder[B]\n} \n")),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.json._\n\ntest("mapping decoders") {\n  case class Person(name: String, age: Int)\n  object Person {\n    implicit val decoder = JsonDecoder[(String, Int)].map { case (name, age) => Person(name, age) }\n  }\n\n  val person = "[\\"John\\",42]".fromJson[Person]\n\n  assertTrue(person == Right(Person("John", 42)))\n}\n')),(0,a.kt)("p",null,"If we have ",(0,a.kt)("inlineCode",{parentName:"p"},"JsonEncoder[A]")," we can map its ",(0,a.kt)("strong",{parentName:"p"},"input")," by providing a function  of typ ",(0,a.kt)("inlineCode",{parentName:"p"},"B => A")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"contramap")," operator to create a new ",(0,a.kt)("inlineCode",{parentName:"p"},"JsonEncoder[B]"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"trait JsonEncoder[A] {\n  def contramap[B](f: B => A): JsonEncoder[B]\n}\n")),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.json._\n\ntest("mapping encoders (contramap)") {\n  case class Person(name: String, age: Int)\n  object Person {\n    implicit val encoder: JsonEncoder[Person] =\n      JsonEncoder[(String, Int)].contramap((p: Person) => (p.name, p.age))\n  }\n\n  val json = Person("John", 42).toJson\n\n  assertTrue(json == "[\\"John\\",42]")\n}\n')),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"In this section we have covered the basics of JSON encoding and decoding. We have also seen how to create custom codecs for complex types. "),(0,a.kt)("p",null,"All the source code associated with this article is available on the ",(0,a.kt)("a",{parentName:"p",href:"http://github.com/zio/zio-quickstarts"},"ZIO Quickstart")," on Github."))}u.isMDXComponent=!0}}]);