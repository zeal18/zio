"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[17621],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=p(n),m=o,h=u["".concat(s,".").concat(m)]||u[m]||d[m]||i;return n?a.createElement(h,l(l({ref:t},c),{},{components:n})):a.createElement(h,l({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,l=new Array(i);l[0]=m;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[u]="string"==typeof e?e:o,l[1]=r;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},79902:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var a=n(87462),o=(n(67294),n(3905));const i={id:"associative",title:"Associative"},l=void 0,r={unversionedId:"zio-prelude/functional-abstractions/concrete-types/associative",id:"zio-prelude/functional-abstractions/concrete-types/associative",title:"Associative",description:"Associative[A] describes a way of combining two values of type A that is associative.",source:"@site/docs/zio-prelude/functional-abstractions/concrete-types/associative.md",sourceDirName:"zio-prelude/functional-abstractions/concrete-types",slug:"/zio-prelude/functional-abstractions/concrete-types/associative",permalink:"/zio-prelude/functional-abstractions/concrete-types/associative",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/concrete-types/associative.md",tags:[],version:"current",frontMatter:{id:"associative",title:"Associative"},sidebar:"ecosystem-sidebar",previous:{title:"Introduction",permalink:"/zio-prelude/functional-abstractions/concrete-types/"},next:{title:"Commutative",permalink:"/zio-prelude/functional-abstractions/concrete-types/commutative"}},s={},p=[],c={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Associative[A]")," describes a way of combining two values of type ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," that is associative."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"trait Associative[A] {\n  def combine(left: => A, right: => A): A\n}\n")),(0,o.kt)("p",null,"If we import ",(0,o.kt)("inlineCode",{parentName:"p"},"zio.prelude._")," we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"<>")," operator to combine any two values of type ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," that have an ",(0,o.kt)("inlineCode",{parentName:"p"},"Associative")," instance defined for them."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"combine")," operator must be associative, meaning that if we combine ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"b")," and then combine the result with ",(0,o.kt)("inlineCode",{parentName:"p"},"c")," we must get the same value as if we combine ",(0,o.kt)("inlineCode",{parentName:"p"},"b")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"c")," and then combine ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," with the result."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"(a <> b) <> c === a <> (b <> c)\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Associative")," abstraction allows us to combine values of a data type to build a new value of that data type with richer structure."),(0,o.kt)("p",null,"A variety of data types can be combined in an associative way:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.{Chunk, NonEmptyChunk}\nimport zio.prelude._\n\nval string: String =\n  "Hello, " <> "world!"\n// string: String = "Hello, world!"\n\nval chunk: Chunk[Int] =\n  Chunk(1, 2, 3) <> Chunk(4, 5, 6)\n// chunk: Chunk[Int] = IndexedSeq(1, 2, 3, 4, 5, 6)\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Associative")," abstraction provides several advantages over using existing operators like the ",(0,o.kt)("inlineCode",{parentName:"p"},"++")," operator on ",(0,o.kt)("inlineCode",{parentName:"p"},"Chunk")," directly."),(0,o.kt)("p",null,"First, ",(0,o.kt)("inlineCode",{parentName:"p"},"Associative")," allows us to combine more complex data types as long as the data types they are composed of can be combined in an associative way."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Topic(value: String)\n\ncase class Votes(value: Int)\n\nobject Votes {\n  implicit val VotesAssociative: Associative[Votes] =\n    new Associative[Votes] {\n      def combine(left: => Votes, right: => Votes): Votes =\n        Votes(left.value + right.value)\n    }\n}\n\ncase class VoteMap(map: Map[Topic, Votes])\n\nobject VoteMap {\n  def combine(left: VoteMap, right: VoteMap): VoteMap =\n    VoteMap(left.map <> right.map)\n}\n")),(0,o.kt)("p",null,"If we didn't have ZIO Prelude we would have to implement the operator to combine two ",(0,o.kt)("inlineCode",{parentName:"p"},"VoteMap")," values ourselves. This would require some relatively low level logic that would look like this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def combine(left: VoteMap, right: VoteMap): VoteMap =\n  VoteMap(right.map.foldLeft(left.map) { case (map, (k, v)) =>\n    map + (k -> map.get(k).fold(v)(v1 => Votes(v.value + v1.value)))\n  })\n")),(0,o.kt)("p",null,"This code isn't the worst. It uses operators like ",(0,o.kt)("inlineCode",{parentName:"p"},"foldLeft")," to do this combining of the two maps in a relatively high level way."),(0,o.kt)("p",null,"But we're still having to implement our own collection operators, taking our attention away from implementing our business logic. And it would be hard to implement this without at least having to take a minute and to check our logic, especially if we are less familiar with immutable collection operators."),(0,o.kt)("p",null,"ZIO Prelude lets us avoid all of this because it knows how to combine two maps as long as there is a way to combine the map values. And it was quite simple to describe how we combine the map values, we just add them."),(0,o.kt)("p",null,"Second, the ",(0,o.kt)("inlineCode",{parentName:"p"},"Associative")," abstraction lets us generalize over different ways of combining values if we want to."),(0,o.kt)("p",null,"For example, we could define an operator for reducing any ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyChunk")," to a summary value like this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.NonEmptyChunk\n\ndef reduce[A: Associative](as: NonEmptyChunk[A]): A =\n  as.reduce(_ <> _)\n")),(0,o.kt)("p",null,"We can then reduce any ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyChunk")," to a summary value as long as there is a way of combining the elements of the ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyChunk"),", whether those elements are strings or vote maps."),(0,o.kt)("p",null,"So far we have not described some very basic ways of combining that are associative, such as integer addition."),(0,o.kt)("p",null,"The reason for this is that some data types support more than one way of combining them that is associative. For example, both integer addition and multiplication are associative."),(0,o.kt)("p",null,"This creates a potential issue when using the type class pattern because the Scala compiler looks up implicit values based on their type, so if there are two different implicit values of a given type the Scala compiler does not know which one to use."),(0,o.kt)("p",null,"For example, here is what happens if we try to define ",(0,o.kt)("inlineCode",{parentName:"p"},"Associative")," instances for ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," for both addition and multiplication."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"implicit val IntSumAssociative: Associative[Int] =\n  new Associative[Int] {\n    def combine(left: => Int, right: => Int): Int =\n      left + right\n  }\n\nimplicit val IntProdAssociative: Associative[Int] =\n  new Associative[Int] {\n    def combine(left: => Int, right: => Int): Int =\n      left * right\n  }\n\n2 <> 3\n// error: ambiguous implicit values:\n//  both value IntSumAssociative in object MdocApp of type zio.prelude.Associative[Int]\n//  and value IntProdAssociative in object MdocApp of type zio.prelude.Associative[Int]\n//  match expected type zio.prelude.Associative[Int]\n// 2 <> 3\n// ^^^^^^\n")),(0,o.kt)("p",null,"This makes sense because there are indeed two different instances of ",(0,o.kt)("inlineCode",{parentName:"p"},"Associative[Int]")," and there is no basis for choosing between them."),(0,o.kt)("p",null,'We could just define one of these instances as "primary" like some other functional programming libraries do and relegate the other to second class status but that would be arbitrary and reflect a lack of compositionality.'),(0,o.kt)("p",null,"Instead we solve the problem in a way that fits with Scala's implicit resolution mechanism. If the Scala compiler looks up implicit values based on their types, then if we want two values we need two types."),(0,o.kt)("p",null,"We can easily do this with ZIO Prelude's new type functionality."),(0,o.kt)("p",null,'New types allow us to define new types that "wrap" existing types in a way that has no overhead at runtime. We can also define these new types so that the Scala compiler actually knows that the new type is a subtype of the underlying type.'),(0,o.kt)("p",null,"Using this technique, we can define new types ",(0,o.kt)("inlineCode",{parentName:"p"},"Sum")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Prod")," that can be combined using addition and multiplication, respectively. ZIO Prelude provides these and similar new types such as ",(0,o.kt)("inlineCode",{parentName:"p"},"And")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Or")," for logical conjunction and disjunction in the ",(0,o.kt)("inlineCode",{parentName:"p"},"zio.prelude.newtypes")," package."),(0,o.kt)("p",null,"We can wrap any existing type in a new type using the ",(0,o.kt)("inlineCode",{parentName:"p"},"apply")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"wrap")," operators on the new type object."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.prelude._\nimport zio.prelude.newtypes._\n\nval sumInt: Sum[Int] =\n  Sum(1)\n// sumInt: Sum[Int] = 1\n\nval prodInt: Prod[Int] =\n  Prod.wrap(2)\n// prodInt: Prod[Int] = 2\n")),(0,o.kt)("p",null,"We can unwrap any new type to get back the original type using the ",(0,o.kt)("inlineCode",{parentName:"p"},"unwrap")," operator on the new type object."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val int: Int =\n  Sum.unwrap(sumInt)\n// int: Int = 1\n")),(0,o.kt)("p",null,"However, we will typically not need to do that for new types like ",(0,o.kt)("inlineCode",{parentName:"p"},"Sum")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Prod")," because they are subtypes of ",(0,o.kt)("inlineCode",{parentName:"p"},"Int"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val int: Int =\n  prodInt\n// int: Int = 2\n")),(0,o.kt)("p",null,"Let's use these types to solve our problem from above."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val sum: Int =\n  Sum(2) <> Sum(3)\n// sum: Int = 5\n\nval product: Int =\n  Prod(2) <> Prod(3)\n// product: Int = 6\n")),(0,o.kt)("p",null,"These variants don't just work for ",(0,o.kt)("inlineCode",{parentName:"p"},"Int"),", they work for any numeric data type in the Scala standard library."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val sum: Double =\n  Sum(2.0) <> Sum(3.0)\n// sum: Double = 5.0\n\nval product: Double =\n  Prod(2.0) <> Prod(3.0)\n// product: Double = 6.0\n")),(0,o.kt)("p",null,"Note that the associativity of addition and multiplication for ",(0,o.kt)("inlineCode",{parentName:"p"},"Double"),' values is subject to floating point rounding errors. ZIO Prelude assumes that if we are working with "lossy" data types like this we are aware of these issues and provides these instances for us, unlike some other functional programming libraries.'),(0,o.kt)("p",null,"ZIO Prelude provides several other new types that you can use to define how you want to combine various data types."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"And")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Or")," new types mentioned above let us define ",(0,o.kt)("inlineCode",{parentName:"p"},"Boolean")," values that can be combined using logical conjunction and disjunction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val and: Boolean =\n  And(true) <> And(false)\n// and: Boolean = false\n\nval or: Boolean =\n  Or(true) <> Or(false)\n// or: Boolean = true\n")),(0,o.kt)("p",null,"Another way of combining two values that is associative is taking the first or the last of two values."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'val first: String =\n  First("Hello") <> First("World")\n// first: String = "Hello"\n\nval last: String =\n  Last("Hello") <> Last("World")\n// last: String = "World"\n')),(0,o.kt)("p",null,"The minimum and maximum of two values for which an ordering is defined also constitutes an associative ",(0,o.kt)("inlineCode",{parentName:"p"},"combine")," operator."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val min: Int =\n  Min(1) <> Min(2)\n// min: Int = 1\n\nval max: Int =\n  Max(1) <> Max(2)\n// max: Int = 2\n")),(0,o.kt)("p",null,"These new types are particularly useful when dealing with more complex data types to specify how we want to combine part of them."),(0,o.kt)("p",null,"For example, let's go to our example with the ",(0,o.kt)("inlineCode",{parentName:"p"},"VoteMap")," but say that now we are not going to define the additional type for ",(0,o.kt)("inlineCode",{parentName:"p"},"Topic")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Votes"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class VoteMap(map: Map[String, Int])\n")),(0,o.kt)("p",null,"We need to tell ZIO Prelude how we want to combine ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," values. In this case we want to use the sum."),(0,o.kt)("p",null,"We do this by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"wrapAll")," operator. Just like ",(0,o.kt)("inlineCode",{parentName:"p"},"wrap")," wraps a single value in a new type, ",(0,o.kt)("inlineCode",{parentName:"p"},"wrapAll")," wraps a whole collection of values in a new type."),(0,o.kt)("p",null,"It does this without traversing the collection because ZIO Prelude knows internally that the new type and the underlying type are the same. This way we avoid any runtime overhead for using these abstractions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"object VoteMap {\n  implicit val VoteMapAssociative: Associative[VoteMap] =\n    new Associative[VoteMap] {\n      def combine(left: => VoteMap, right: => VoteMap): VoteMap =\n        VoteMap(Sum.wrapAll(left.map) <> Sum.wrapAll(right.map))\n    }\n}\n")),(0,o.kt)("p",null,"You can see the documentation on new types for additional information about new types in general. But the material here should give you what you need to combine values of even complex data types and define your own instances of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Associative")," abstraction for your own data types."),(0,o.kt)("p",null,"If you are interested in combining values of collections it is also worth checking out the ",(0,o.kt)("inlineCode",{parentName:"p"},"ForEach")," functional abstraction, which describes ways to iterate over collection types. The ",(0,o.kt)("inlineCode",{parentName:"p"},"ForEach")," abstraction comes with a variety of built in operators for combining collection types using an associative operator."),(0,o.kt)("p",null,"For example, using ",(0,o.kt)("inlineCode",{parentName:"p"},"ForEach"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Associative"),", and new types we could count the total number of words in a collection of lines like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.NonEmptyChunk\n\ndef wordCount(lines: NonEmptyChunk[String]): Int =\n  lines.reduceMap(line => Sum(line.split(" ").length))\n')),(0,o.kt)("p",null,"This maps each element in a collection to a new data type for which an ",(0,o.kt)("inlineCode",{parentName:"p"},"Associative")," instance is defined and then reduces all of those values to a single summary value with the ",(0,o.kt)("inlineCode",{parentName:"p"},"combine")," operator."),(0,o.kt)("p",null,"We could instead count the number of occurrences of each word like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'def wordCount(lines: NonEmptyChunk[String]): Map[String, Int] =\n  lines.reduceMap { line =>\n    Sum.wrapAll(line.split(" ").groupBy(identity).view.mapValues(_.length).toMap)\n  }\n')),(0,o.kt)("p",null,"This version is exactly the same except we mapped the elements to a different value. ZIO Prelude automatically applied the appropriate ",(0,o.kt)("inlineCode",{parentName:"p"},"combine")," operator."),(0,o.kt)("p",null,"This is a great example of how these abstractions can make it easy to combine values of different data types, cutting the boilerplate out of our code and reducing opportunities for bugs."))}d.isMDXComponent=!0}}]);