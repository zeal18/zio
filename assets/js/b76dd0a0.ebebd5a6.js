"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[4144],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>g});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(t),u=i,g=m["".concat(s,".").concat(u)]||m[u]||d[u]||o;return t?a.createElement(g,r(r({ref:n},c),{},{components:t})):a.createElement(g,r({ref:n},c))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[m]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},32824:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=t(87462),i=(t(67294),t(3905));const o={id:"community",title:"Community ZIO Libraries"},r=void 0,l={unversionedId:"resources/ecosystem/community",id:"version-1.0.18/resources/ecosystem/community",title:"Community ZIO Libraries",description:"In this section we are going to introduce some of the most important libraries that have first-class ZIO support from the community.",source:"@site/versioned_docs/version-1.0.18/resources/ecosystem/community.md",sourceDirName:"resources/ecosystem",slug:"/resources/ecosystem/community",permalink:"/1.0.18/resources/ecosystem/community",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/resources/ecosystem/community.md",tags:[],version:"1.0.18",frontMatter:{id:"community",title:"Community ZIO Libraries"}},s={},p=[{value:"Caliban",id:"caliban",level:2},{value:"Introduction",id:"introduction",level:3},{value:"Installation",id:"installation",level:3},{value:"Example",id:"example",level:3},{value:"ZIO gRPC",id:"zio-grpc",level:2},{value:"Introduction",id:"introduction-1",level:3},{value:"Installation",id:"installation-1",level:3},{value:"Example",id:"example-1",level:3},{value:"Distage",id:"distage",level:2},{value:"Introduction",id:"introduction-2",level:3},{value:"Installation",id:"installation-2",level:3},{value:"Example",id:"example-2",level:3},{value:"LogStage",id:"logstage",level:2},{value:"Introduction",id:"introduction-3",level:3},{value:"Installation",id:"installation-3",level:3},{value:"Example",id:"example-3",level:3},{value:"MUnit ZIO",id:"munit-zio",level:2},{value:"Introduction",id:"introduction-4",level:3},{value:"Installation",id:"installation-4",level:3},{value:"Example",id:"example-4",level:3},{value:"Rezilience",id:"rezilience",level:2},{value:"Introduction",id:"introduction-5",level:3},{value:"Installation",id:"installation-5",level:3},{value:"Example",id:"example-5",level:3},{value:"Tamer",id:"tamer",level:2},{value:"Introduction",id:"introduction-6",level:3},{value:"Installation",id:"installation-6",level:3},{value:"Example",id:"example-6",level:3},{value:"TranzactIO",id:"tranzactio",level:2},{value:"Introduction",id:"introduction-7",level:3},{value:"Installation",id:"installation-7",level:3},{value:"Example",id:"example-7",level:3},{value:"ZIO Arrow",id:"zio-arrow",level:2},{value:"Introduction",id:"introduction-8",level:3},{value:"Installation",id:"installation-8",level:3},{value:"Example",id:"example-8",level:3},{value:"ZIO AMQP",id:"zio-amqp",level:2},{value:"Introduction",id:"introduction-9",level:3},{value:"Installation",id:"installation-9",level:3},{value:"Example",id:"example-9",level:3},{value:"ZIO AWS",id:"zio-aws",level:2},{value:"Introduction",id:"introduction-10",level:3},{value:"Installation",id:"installation-10",level:3},{value:"Example",id:"example-10",level:3},{value:"ZIO AWS S3",id:"zio-aws-s3",level:2},{value:"Introduction",id:"introduction-11",level:3},{value:"Installation",id:"installation-11",level:3},{value:"Example",id:"example-11",level:3},{value:"ZIO HTTP",id:"zio-http",level:2},{value:"Introduction",id:"introduction-12",level:3},{value:"Installation",id:"installation-12",level:3},{value:"Example",id:"example-12",level:3},{value:"ZIO K8s",id:"zio-k8s",level:2},{value:"Introduction",id:"introduction-13",level:3},{value:"Installation",id:"installation-13",level:3},{value:"Example",id:"example-13",level:3},{value:"ZIO Kinesis",id:"zio-kinesis",level:2},{value:"Introduction",id:"introduction-14",level:3},{value:"Installation",id:"installation-14",level:3},{value:"Example",id:"example-14",level:3},{value:"ZIO Pulsar",id:"zio-pulsar",level:2},{value:"Introduction",id:"introduction-15",level:3},{value:"Installation",id:"installation-15",level:3},{value:"Example",id:"example-15",level:3},{value:"ZIO Saga",id:"zio-saga",level:2},{value:"Introduction",id:"introduction-16",level:3},{value:"Installation",id:"installation-16",level:3},{value:"Example",id:"example-16",level:3},{value:"ZIO Slick Interop",id:"zio-slick-interop",level:2},{value:"Installation",id:"installation-17",level:3},{value:"Example",id:"example-17",level:3},{value:"ZIO Test Akka HTTP",id:"zio-test-akka-http",level:2},{value:"Installation",id:"installation-18",level:3},{value:"Example",id:"example-18",level:3},{value:"ZparkIO",id:"zparkio",level:2},{value:"Introduction",id:"introduction-17",level:3},{value:"Installation",id:"installation-19",level:3},{value:"Example",id:"example-19",level:3},{value:"Quill",id:"quill",level:2},{value:"Introduction",id:"introduction-18",level:3},{value:"Installation",id:"installation-20",level:3},{value:"Example",id:"example-20",level:3}],c={toc:p},m="wrapper";function d(e){let{components:n,...t}=e;return(0,i.kt)(m,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In this section we are going to introduce some of the most important libraries that have first-class ZIO support from the community."),(0,i.kt)("p",null,"If you know a useful library that has first-class ZIO support, please consider ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zio/zio/pulls"},"submitting a pull request")," to add it to this list."),(0,i.kt)("h2",{id:"caliban"},"Caliban"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://ghostdogpr.github.io/caliban/"},"Caliban")," is a purely functional library for creating GraphQL servers and clients in Scala."),(0,i.kt)("h3",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Key features of Caliban"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Purely Functional")," \u2014 All interfaces are pure and types are referentially transparent."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Type Safety")," \u2014 Schemas are type safe and derived at compile time."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Minimal Boilerplate")," \u2014 No need to manually define a schema for every type in your API."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Excellent Interoperability")," \u2014 Out-of-the-box support for major HTTP server libraries, effect types, JSON libraries, and more.")),(0,i.kt)("h3",{id:"installation"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "com.github.ghostdogpr" %% "caliban" % "1.1.0"\n')),(0,i.kt)("p",null,"Caliban also have lots of optional modules to inter-operate with other various libraries:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "com.github.ghostdogpr" %% "caliban-http4s"     % "1.1.0" // routes for http4s\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-akka-http"  % "1.1.0" // routes for akka-http\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-play"       % "1.1.0" // routes for play\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-finch"      % "1.1.0" // routes for finch\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-zio-http"   % "1.1.0" // routes for zio-http\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-cats"       % "1.1.0" // interop with cats effect\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-monix"      % "1.1.0" // interop with monix\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-tapir"      % "1.1.0" // interop with tapir\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-federation" % "1.1.0" // interop with apollo federation\n')),(0,i.kt)("h3",{id:"example"},"Example"),(0,i.kt)("p",null,"First, to define Caliban API, we should define data models using case classes and ADTs. Then the Caliban can derive the whole GraphQL schema from these data models:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala",metastring:"modc:silent:nest","modc:silent:nest":!0},'import caliban.GraphQL.graphQL\nimport caliban.schema.Annotations.GQLDescription\nimport caliban.{RootResolver, ZHttpAdapter}\nimport zhttp.http._\nimport zhttp.service.Server\nimport zio.{ExitCode, ZEnv, ZIO}\n\nimport scala.language.postfixOps\n\nsealed trait Role\n\nobject Role {\n  case object SoftwareDeveloper       extends Role\n  case object SiteReliabilityEngineer extends Role\n  case object DevOps                  extends Role\n}\n\ncase class Employee(\n    name: String,\n    role: Role\n)\n\ncase class EmployeesArgs(role: Role)\ncase class EmployeeArgs(name: String)\n\ncase class Queries(\n    @GQLDescription("Return all employees with specific role")\n    employees: EmployeesArgs => List[Employee],\n    @GQLDescription("Find an employee by its name")\n    employee: EmployeeArgs => Option[Employee]\n)\nobject CalibanExample extends zio.App {\n\n  val employees = List(\n    Employee("Alex", Role.DevOps),\n    Employee("Maria", Role.SoftwareDeveloper),\n    Employee("James", Role.SiteReliabilityEngineer),\n    Employee("Peter", Role.SoftwareDeveloper),\n    Employee("Julia", Role.SiteReliabilityEngineer),\n    Employee("Roberta", Role.DevOps)\n  )\n\n  val myApp = for {\n    interpreter <- graphQL(\n      RootResolver(\n        Queries(\n          args => employees.filter(e => args.role == e.role),\n          args => employees.find(e => e.name == args.name)\n        )\n      )\n    ).interpreter\n    _ <- Server\n      .start(\n        port = 8088,\n        http = Http.route { case _ -> Root / "api" / "graphql" =>\n          ZHttpAdapter.makeHttpService(interpreter)\n        }\n      )\n      .forever\n  } yield ()\n\n  override def run(args: List[String]): ZIO[ZEnv, Nothing, ExitCode] =\n    myApp.exitCode\n\n}\n')),(0,i.kt)("p",null,"Now let's query all software developers using GraphQL query language:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},"query{\n  employees(role: SoftwareDeveloper){\n    name\n    role\n  }\n}\n")),(0,i.kt)("p",null,"Here is the ",(0,i.kt)("em",{parentName:"p"},"curl")," request of this query:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"curl 'http://localhost:8088/api/graphql' --data-binary '{\"query\":\"query{\\n employees(role: SoftwareDeveloper){\\n name\\n role\\n}\\n}\"}'\n")),(0,i.kt)("p",null,"And the response:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "data" : {\n    "employees" : [\n      {\n        "name" : "Maria",\n        "role" : "SoftwareDeveloper"\n      },\n      {\n        "name" : "Peter",\n        "role" : "SoftwareDeveloper"\n      }\n    ]\n  }\n}\n')),(0,i.kt)("h2",{id:"zio-grpc"},"ZIO gRPC"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://scalapb.github.io/zio-grpc/"},"ZIO-gRPC")," lets us write purely functional gRPC servers and clients."),(0,i.kt)("h3",{id:"introduction-1"},"Introduction"),(0,i.kt)("p",null,"Key features of ZIO gRPC:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Functional and Type-safe")," \u2014 Use the power of Functional Programming and the Scala compiler to build robust, correct and fully featured gRPC servers."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Support for Streaming")," \u2014 Use ZIO's feature-rich ",(0,i.kt)("inlineCode",{parentName:"li"},"ZStream"),"s to create server-streaming, client-streaming, and bi-directionally streaming RPC endpoints."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Highly Concurrent")," \u2014 Leverage the power of ZIO to build asynchronous clients and servers without deadlocks and race conditions."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Resource Safety")," \u2014 Safely cancel an RPC call by interrupting the effect. Resources on the server will never leak!"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Scala.js Support")," \u2014 ZIO gRPC comes with Scala.js support, so we can send RPCs to our service from the browser.")),(0,i.kt)("h3",{id:"installation-1"},"Installation"),(0,i.kt)("p",null,"First of all we need to add following lines to the ",(0,i.kt)("inlineCode",{parentName:"p"},"project/plugins.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'addSbtPlugin("com.thesamet" % "sbt-protoc" % "1.0.2")\n\nlibraryDependencies +=\n  "com.thesamet.scalapb.zio-grpc" %% "zio-grpc-codegen" % "0.5.0"\n')),(0,i.kt)("p",null,"Then in order to use this library, we need should add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'PB.targets in Compile := Seq(\n  scalapb.gen(grpc = true) -> (sourceManaged in Compile).value / "scalapb",\n  scalapb.zio_grpc.ZioCodeGenerator -> (sourceManaged in Compile).value / "scalapb"\n)\n\nlibraryDependencies ++= Seq(\n  "io.grpc" % "grpc-netty" % "1.39.0",\n  "com.thesamet.scalapb" %% "scalapb-runtime-grpc" % scalapb.compiler.Version.scalapbVersion\n)\n')),(0,i.kt)("h3",{id:"example-1"},"Example"),(0,i.kt)("p",null,"In this section, we are going to implement a simple server and client for the following gRPC ",(0,i.kt)("em",{parentName:"p"},"proto")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf"},'syntax = "proto3";\n\noption java_multiple_files = true;\noption java_package = "io.grpc.examples.helloworld";\noption java_outer_classname = "HelloWorldProto";\noption objc_class_prefix = "HLW";\n\npackage helloworld;\n\n// The greeting service definition.\nservice Greeter {\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n\n// The request message containing the user\'s name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n')),(0,i.kt)("p",null,"The hello world server would be like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import io.grpc.ServerBuilder\nimport io.grpc.examples.helloworld.helloworld.ZioHelloworld.ZGreeter\nimport io.grpc.examples.helloworld.helloworld.{HelloReply, HelloRequest}\nimport io.grpc.protobuf.services.ProtoReflectionService\nimport scalapb.zio_grpc.{ServerLayer, ServiceList}\nimport zio.console.putStrLn\nimport zio.{ExitCode, URIO, ZEnv, ZIO}\n\nobject HelloWorldServer extends zio.App {\n\n  val helloService: ZGreeter[ZEnv, Any] =\n    (request: HelloRequest) =>\n      putStrLn(s"Got request: $request") *>\n        ZIO.succeed(HelloReply(s"Hello, ${request.name}"))\n\n\n  val myApp = for {\n    _ <- putStrLn("Server is running. Press Ctrl-C to stop.")\n    _ <- ServerLayer\n      .fromServiceList(\n        ServerBuilder\n          .forPort(9000)\n          .addService(ProtoReflectionService.newInstance()),\n        ServiceList.add(helloService))\n      .build.useForever\n  } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n')),(0,i.kt)("p",null,"And this is an example of using its client:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import io.grpc.ManagedChannelBuilder\nimport io.grpc.examples.helloworld.helloworld.HelloRequest\nimport io.grpc.examples.helloworld.helloworld.ZioHelloworld.GreeterClient\nimport scalapb.zio_grpc.ZManagedChannel\nimport zio.console._\nimport zio.{ExitCode, URIO}\n\nobject HelloWorldClient extends zio.App {\n  def myApp =\n    for {\n      r <- GreeterClient.sayHello(HelloRequest("World"))\n      _ <- putStrLn(r.message)\n    } yield ()\n\n  val clientLayer =\n    GreeterClient.live(\n      ZManagedChannel(\n        ManagedChannelBuilder.forAddress("localhost", 9000).usePlaintext()\n      )\n    )\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.provideCustomLayer(clientLayer).exitCode\n}\n')),(0,i.kt)("h2",{id:"distage"},"Distage"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://izumi.7mind.io/distage/"},"Distage")," is a compile-time safe, transparent, and debuggable Dependency Injection framework for pure FP Scala."),(0,i.kt)("h3",{id:"introduction-2"},"Introduction"),(0,i.kt)("p",null,"By using ",(0,i.kt)("em",{parentName:"p"},"Distage")," we can auto-wire all components of our application."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We don't need to manually link components together"),(0,i.kt)("li",{parentName:"ul"},"We don't need to manually specify the order of allocation and allocation of dependencies. This will be derived automatically from the dependency order."),(0,i.kt)("li",{parentName:"ul"},"We can override any component within the dependency graph."),(0,i.kt)("li",{parentName:"ul"},"It helps us to create different configurations of our components for different use cases.")),(0,i.kt)("h3",{id:"installation-2"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "io.7mind.izumi" %% "distage-core" % "1.0.8"\n')),(0,i.kt)("h3",{id:"example-2"},"Example"),(0,i.kt)("p",null,"In this example we create a ",(0,i.kt)("inlineCode",{parentName:"p"},"RandomApp")," comprising two ",(0,i.kt)("inlineCode",{parentName:"p"},"Random")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Logger")," services. By using ",(0,i.kt)("inlineCode",{parentName:"p"},"ModuleDef")," we ",(0,i.kt)("em",{parentName:"p"},"bind")," services to their implementations:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import distage.{Activation, Injector, ModuleDef, Roots}\nimport izumi.distage.model.Locator\nimport izumi.distage.model.definition.Lifecycle\nimport zio.{ExitCode, Task, UIO, URIO, ZIO}\n\nimport java.time.LocalDateTime\n\ntrait Random {\n  def nextInteger: UIO[Int]\n}\n\nfinal class ScalaRandom extends Random {\n  override def nextInteger: UIO[Int] =\n    ZIO.effectTotal(scala.util.Random.nextInt())\n}\n\ntrait Logger {\n  def log(name: String): Task[Unit]\n}\n\nfinal class ConsoleLogger extends Logger {\n  override def log(line: String): Task[Unit] = {\n    val timeStamp = LocalDateTime.now()\n    ZIO.effect(println(s"$timeStamp: $line"))\n  }\n}\n\nfinal class RandomApp(random: Random, logger: Logger) {\n  def run: Task[Unit] = for {\n    random <- random.nextInteger\n    _ <- logger.log(s"random number generated: $random")\n  } yield ()\n}\n\nobject DistageExample extends zio.App {\n  def RandomAppModule: ModuleDef = new ModuleDef {\n    make[Random].from[ScalaRandom]\n    make[Logger].from[ConsoleLogger]\n    make[RandomApp] // `.from` is not required for concrete classes\n  }\n  \n  val resource: Lifecycle[Task, Locator] = Injector[Task]().produce(\n    plan = Injector[Task]().plan(\n      bindings = RandomAppModule,\n      activation = Activation.empty,\n      roots = Roots.target[RandomApp]\n    )\n  )\n\n  val myApp: Task[Unit] = resource.use(locator => locator.get[RandomApp].run)\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n')),(0,i.kt)("h2",{id:"logstage"},"LogStage"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://izumi.7mind.io/logstage/"},"LogStage")," is a zero-cost structural logging framework for Scala & Scala.js."),(0,i.kt)("h3",{id:"introduction-3"},"Introduction"),(0,i.kt)("p",null,"Some key features of ",(0,i.kt)("em",{parentName:"p"},"LogStage"),":"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"LogStage extracts structure from ordinary string interpolations in your log messages with zero changes to code."),(0,i.kt)("li",{parentName:"ol"},"LogStage uses macros to extract log structure, it is faster at runtime than a typical reflective structural logging frameworks"),(0,i.kt)("li",{parentName:"ol"},"Log contexts"),(0,i.kt)("li",{parentName:"ol"},"Console, File, and SLF4J sinks included, File sink supports log rotation,"),(0,i.kt)("li",{parentName:"ol"},"Human-readable output and JSON output included,"),(0,i.kt)("li",{parentName:"ol"},"Method-level logging granularity. Can configure methods com.example.Service.start and com.example.Service.doSomething independently,"),(0,i.kt)("li",{parentName:"ol"},"Slf4J adapters: route legacy Slf4J logs into LogStage router")),(0,i.kt)("h3",{id:"installation-3"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// LogStage core library\nlibraryDependencies += "io.7mind.izumi" %% "logstage-core" % "1.0.8"\n')),(0,i.kt)("p",null,"There are also some optional modules:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies ++= Seq(\n  // Json output\n  "io.7mind.izumi" %% "logstage-rendering-circe" % "1.0.8",\n  // Router from Slf4j to LogStage\n  "io.7mind.izumi" %% "logstage-adapter-slf4j" % "1.0.8",\n  // LogStage integration with DIStage\n  "io.7mind.izumi" %% "distage-extension-logstage" % "1.0.8",\n  // Router from LogStage to Slf4J\n  "io.7mind.izumi" %% "logstage-sink-slf4j " % "1.0.8",\n)\n')),(0,i.kt)("h3",{id:"example-3"},"Example"),(0,i.kt)("p",null,"Let's try a simple example of using ",(0,i.kt)("em",{parentName:"p"},"LogStage"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import izumi.fundamentals.platform.uuid.UUIDGen\nimport logstage.LogZIO.log\nimport logstage.{IzLogger, LogIO2, LogZIO}\nimport zio.{Has, URIO, _}\n\nobject LogStageExample extends zio.App {\n  val myApp = for {\n    _ <- log.info("I\'m logging with logstage!")\n    userId = UUIDGen.getTimeUUID()\n    _ <- log.info(s"Current $userId")\n    _ <- log.info("I\'m logging within the same fiber!")\n    f <- log.info("I\'m logging within a new fiber!").fork\n    _ <- f.join\n  } yield ()\n\n  val loggerLayer: ULayer[Has[LogIO2[IO]]] =\n    ZLayer.succeed(LogZIO.withFiberId(IzLogger()))\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.provideLayer(loggerLayer).exitCode\n}\n')),(0,i.kt)("p",null,"The output of this program would be something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"I 2021-07-26T21:27:35.164 (LogStageExample.scala:8)  \u2026mpty>.LogStageExample.myApp [14:zio-default-async-1] fiberId=Id(1627318654646,1) I'm logging with logstage!\nI 2021-07-26T21:27:35.252 (LogStageExample.scala:10)  <.LogStageExample.myApp.8 [14:zio-default-async-1] fiberId=Id(1627318654646,1) Current userId=93546810-ee32-11eb-a393-11bc5b145beb\nI 2021-07-26T21:27:35.266 (LogStageExample.scala:11)  <.L.myApp.8.10 [14:zio-default-async-1] fiberId=Id(1627318654646,1) I'm logging within the same fiber!\nI 2021-07-26T21:27:35.270 (LogStageExample.scala:12)  <.L.m.8.10.11 [16:zio-default-async-2] fiberId=Id(1627318655269,2) I'm logging within a new fiber!\n")),(0,i.kt)("h2",{id:"munit-zio"},"MUnit ZIO"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/poslegm/munit-zio"},"MUnit ZIO")," is an integration library between MUnit and ZIO."),(0,i.kt)("h3",{id:"introduction-4"},"Introduction"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://scalameta.org/munit/"},"MUnit")," is a Scala testing library that is implemented as a JUnit runner. It has ",(0,i.kt)("em",{parentName:"p"},"actionable errors"),", so the test reports are colorfully pretty-printed, stack traces are highlighted, error messages are pointed to the source code location where the failure happened."),(0,i.kt)("p",null,"The MUnit ZIO enables us to write tests that return ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," values without needing to call any unsafe methods (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"Runtime#unsafeRun"),")."),(0,i.kt)("h3",{id:"installation-4"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following lines in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "org.scalameta" %% "munit" % "0.7.27" % Test\nlibraryDependencies += "com.github.poslegm" %% "munit-zio" % "0.0.2" % Test\n')),(0,i.kt)("p",null,"If we are using a version of sbt lower than 1.5.0, we will also need to add:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'testFrameworks += new TestFramework("munit.Framework")\n')),(0,i.kt)("h3",{id:"example-4"},"Example"),(0,i.kt)("p",null,"Here is a simple MUnit spec that is integrated with the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," effect:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import munit._\nimport zio._\n\nclass SimpleZIOSpec extends ZSuite {\n  testZ("1 + 1 = 2") {\n    for {\n      a <- ZIO(1)\n      b <- ZIO(1)\n    }\n    yield assertEquals(a + b, 2)\n  }\n}\n')),(0,i.kt)("h2",{id:"rezilience"},"Rezilience"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/svroonland/rezilience"},"Rezilience")," is a ZIO-native library for making resilient distributed systems."),(0,i.kt)("h3",{id:"introduction-5"},"Introduction"),(0,i.kt)("p",null,"Rezilience is a ZIO-native fault tolerance library with a collection of policies for making asynchronous systems more resilient to failures inspired by Polly, Resilience4J, and Akka. It does not have external library dependencies other than ZIO."),(0,i.kt)("p",null,"It comprises these policies:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"CircuitBreaker")," \u2014 Temporarily prevent trying calls after too many failures"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"RateLimiter")," \u2014 Limit the rate of calls to a system"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Bulkhead")," \u2014 Limit the number of in-flight calls to a system"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Retry")," \u2014 Try again after transient failures"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Timeout")," \u2014 Interrupt execution if a call does not complete in time")),(0,i.kt)("h3",{id:"installation-5"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "nl.vroste" %% "rezilience" % "0.7.0"\n')),(0,i.kt)("h3",{id:"example-5"},"Example"),(0,i.kt)("p",null,"Let's try an example of writing ",(0,i.kt)("em",{parentName:"p"},"Circuit Breaker")," policy for calling an external API:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import nl.vroste.rezilience.CircuitBreaker.{CircuitBreakerCallError, State}\nimport nl.vroste.rezilience._\nimport zio._\nimport zio.clock.Clock\nimport zio.console.{Console, putStrLn}\nimport zio.duration._\n\nobject CircuitBreakerExample extends zio.App {\n\n  def callExternalSystem: ZIO[Console, String, Nothing] =\n    putStrLn("External service called, but failed!").orDie *>\n      ZIO.fail("External service failed!")\n\n  val myApp: ZIO[Console with Clock, Nothing, Unit] =\n    CircuitBreaker.withMaxFailures(\n      maxFailures = 10,\n      resetPolicy = Schedule.exponential(1.second),\n      onStateChange = (state: State) =>\n        ZIO(println(s"State changed to $state")).orDie\n    ).use { cb =>\n      for {\n        _ <- ZIO.foreach_(1 to 10)(_ => cb(callExternalSystem).either)\n        _ <- cb(callExternalSystem).catchAll(errorHandler)\n        _ <- ZIO.sleep(2.seconds)\n        _ <- cb(callExternalSystem).catchAll(errorHandler)\n      } yield ()\n    }\n\n  def errorHandler: CircuitBreakerCallError[String] => URIO[Console, Unit] = {\n    case CircuitBreaker.CircuitBreakerOpen =>\n      putStrLn("Circuit breaker blocked the call to our external system").orDie\n    case CircuitBreaker.WrappedError(error) =>\n      putStrLn(s"External system threw an exception: $error").orDie\n  }\n  \n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n')),(0,i.kt)("h2",{id:"tamer"},"Tamer"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/laserdisc-io/tamer"},"Tamer")," is a multi-functional Kafka connector for producing data based on ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zio/zio-kafka"},"ZIO Kafka"),"."),(0,i.kt)("h3",{id:"introduction-6"},"Introduction"),(0,i.kt)("p",null,"Tamer is a completely customizable source connector that produces to Kafka. It ships with preconfigured modules for SQL, cloud storage and REST API, but you can provide your own functions and Tamer will take care of the rest."),(0,i.kt)("h3",{id:"installation-6"},"Installation"),(0,i.kt)("p",null,"Depending on the source you have at hand you can add the correct dependency in your ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "io.laserdisc" %% "tamer-db"                % "0.16.1"\nlibraryDependencies += "io.laserdisc" %% "tamer-oci-objectstorage" % "0.16.1"\nlibraryDependencies += "io.laserdisc" %% "tamer-rest"              % "0.16.1"\nlibraryDependencies += "io.laserdisc" %% "tamer-s3"                % "0.16.1"\n')),(0,i.kt)("h3",{id:"example-6"},"Example"),(0,i.kt)("p",null,"Let's say you have a inventory DB that's compatible with ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tpolecat/doobie"},"Doobie"),", you can get all of your items with just a few lines of code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import tamer._\nimport tamer.db._\n\nimport doobie.implicits.legacy.instant._\nimport doobie.syntax.string._\nimport zio._\nimport zio.duration._\nimport zio.json._\n\nimport java.time.Instant\n\ncase class Row(id: String, name: String, description: Option[String], modifiedAt: Instant)\n    extends tamer.db.Timestamped(modifiedAt)\n\nobject Row {\n  implicit val rowJsonCodec = DeriveJsonCodec.gen[Row]\n}\n\nobject DatabaseSimple extends zio.App {\n  // Here we\'ll go with zio-json codec, you can use avro, circe and jsoniter\n  // out-of-the box or plug yours!\n  implicit val stateKeyJsonCodec = DeriveJsonCodec.gen[tamer.Tamer.StateKey]\n  implicit val windowJsonCodec = DeriveJsonCodec.gen[tamer.db.Window]\n\n  val program: RIO[ZEnv, Unit] = tamer.db.DbSetup\n    .tumbling(window =>\n      sql"""SELECT id, name, description, modified_at \n           |FROM users \n           |WHERE modified_at > ${window.from} AND modified_at <= ${window.to}""".stripMargin\n        .query[Row]\n    )(\n      recordKey = (_, v) => v.id,\n      from = Instant.parse("2020-01-01T00:00:00.00Z"),\n      tumblingStep = 5.days\n    )\n    .runWith(dbLayerFromEnvironment ++ tamer.kafkaConfigFromEnvironment)\n\n  override final def run(args: List[String]): URIO[ZEnv, ExitCode] =\n    program.exitCode\n\n  // If you have other codecs like circe in the classpath you have to disambiguate\n  implicit lazy val stateKeyCodec: Codec[Tamer.StateKey] = Codec.optionalZioJsonCodec\n  implicit lazy val windowCodec: Codec[tamer.db.Window] = Codec.optionalZioJsonCodec\n  implicit lazy val stringCodec: Codec[String] = Codec.optionalZioJsonCodec\n}\n')),(0,i.kt)("p",null,"See full example ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/laserdisc-io/tamer/blob/4e1a7646fb44041648d9aa3ba089decb81ebe487/example/src/main/scala/tamer/db/DatabaseSimple.scala"},"on the GitHub repo")),(0,i.kt)("h2",{id:"tranzactio"},"TranzactIO"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/gaelrenoux/tranzactio"},"TranzactIO")," is a ZIO wrapper for some Scala database access libraries, currently for ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tpolecat/doobie"},"Doobie")," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/playframework/anorm"},"Anorm"),"."),(0,i.kt)("h3",{id:"introduction-7"},"Introduction"),(0,i.kt)("p",null,"Using functional effect database access libraries like ",(0,i.kt)("em",{parentName:"p"},"Doobie")," enforces us to use their specialized monads like ",(0,i.kt)("inlineCode",{parentName:"p"},"ConnectionIO")," for ",(0,i.kt)("em",{parentName:"p"},"Doobie"),". The goal of ",(0,i.kt)("em",{parentName:"p"},"TranzactIO")," is to provide seamless integration with these libraries to help us to stay in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," world."),(0,i.kt)("h3",{id:"installation-7"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "io.github.gaelrenoux" %% "tranzactio" % "2.1.0"\n')),(0,i.kt)("p",null,"In addition, we need to declare the database access library we are using. For example, for the next example we need to add following dependencies for ",(0,i.kt)("em",{parentName:"p"},"Doobie")," integration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "org.tpolecat" %% "doobie-core" % "0.13.4"\nlibraryDependencies += "org.tpolecat" %% "doobie-h2"   % "0.13.4"\n')),(0,i.kt)("h3",{id:"example-7"},"Example"),(0,i.kt)("p",null,"Let's try an example of simple ",(0,i.kt)("em",{parentName:"p"},"Doobie")," program:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import doobie.implicits._\nimport io.github.gaelrenoux.tranzactio.doobie\nimport io.github.gaelrenoux.tranzactio.doobie.{Connection, Database, TranzactIO, tzio}\nimport org.h2.jdbcx.JdbcDataSource\nimport zio.blocking.Blocking\nimport zio.clock.Clock\nimport zio.console.{Console, putStrLn}\nimport zio.{ExitCode, Has, URIO, ZIO, ZLayer, blocking}\n\nimport javax.sql.DataSource\n\nobject TranzactIOExample extends zio.App {\n\n  val query: ZIO[Connection with Console, Throwable, Unit] = for {\n    _ <- PersonQuery.setup\n    _ <- PersonQuery.insert(Person("William", "Stewart"))\n    _ <- PersonQuery.insert(Person("Michelle", "Streeter"))\n    _ <- PersonQuery.insert(Person("Johnathon", "Martinez"))\n    users <- PersonQuery.list\n    _ <- putStrLn(users.toString)\n  } yield ()\n\n  val myApp: ZIO[zio.ZEnv, Throwable, Unit] =\n    Database.transactionOrWidenR(query).provideCustomLayer(services.database)\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n\ncase class Person(firstName: String, lastName: String)\n\nobject PersonQuery {\n  def list: TranzactIO[List[Person]] = tzio {\n    sql"""SELECT first_name, last_name FROM person""".query[Person].to[List]\n  }\n\n  def setup: TranzactIO[Unit] = tzio {\n    sql"""\n        CREATE TABLE person (\n          first_name VARCHAR NOT NULL,\n          last_name VARCHAR NOT NULL\n        )\n        """.update.run.map(_ => ())\n  }\n\n  def insert(p: Person): TranzactIO[Unit] = tzio {\n    sql"""INSERT INTO person (first_name, last_name) VALUES (${p.firstName}, ${p.lastName})""".update.run\n      .map(_ => ())\n  }\n}\n\nobject services {\n  val datasource: ZLayer[Blocking, Throwable, Has[DataSource]] =\n    ZLayer.fromEffect(\n      blocking.effectBlocking {\n        val ds = new JdbcDataSource\n        ds.setURL(s"jdbc:h2:mem:mydb;DB_CLOSE_DELAY=10")\n        ds.setUser("sa")\n        ds.setPassword("sa")\n        ds\n      }\n    )\n\n  val database: ZLayer[Any, Throwable, doobie.Database.Database] =\n    (Blocking.live >>> datasource ++ Blocking.live ++ Clock.live) >>> Database.fromDatasource\n}\n')),(0,i.kt)("h2",{id:"zio-arrow"},"ZIO Arrow"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/zio-mesh/zio-arrow/"},"ZIO Arrow")," provides the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZArrow")," effect, which is a high-performance composition effect for the ZIO ecosystem."),(0,i.kt)("h3",{id:"introduction-8"},"Introduction"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ZArrow[E, A, B]")," is an effect representing a computation parametrized over the input (",(0,i.kt)("inlineCode",{parentName:"p"},"A"),"), and the output (",(0,i.kt)("inlineCode",{parentName:"p"},"B"),") that may fail with an ",(0,i.kt)("inlineCode",{parentName:"p"},"E"),". Arrows focus on ",(0,i.kt)("strong",{parentName:"p"},"composition")," and ",(0,i.kt)("strong",{parentName:"p"},"high-performance computation"),". They are like simple functions, but they are lifted into the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZArrow")," context."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ZArrow")," delivers three main capabilities:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"}," High-Performance")," \u2014 ",(0,i.kt)("inlineCode",{parentName:"p"},"ZArrow")," exploits ",(0,i.kt)("inlineCode",{parentName:"p"},"JVM")," internals to dramatically decrease the number of allocations and dispatches, yielding an unprecedented runtime performance.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Abstract interface")," \u2014 ",(0,i.kt)("inlineCode",{parentName:"p"},"Arrow")," is a more abstract data type, than ZIO Monad. It's more abstract than ZIO Streams. In a nutshell, ",(0,i.kt)("inlineCode",{parentName:"p"},"ZArrow")," allows a function-like interface that can have both different inputs and different outputs.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Easy Integration")," \u2014 ",(0,i.kt)("inlineCode",{parentName:"p"},"ZArrow")," can both input and output ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO Monad")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO Stream"),", simplifying application development with different ZIO Effect types."))),(0,i.kt)("h3",{id:"installation-8"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "io.github.neurodyne" %% "zio-arrow" % "0.2.1"\n')),(0,i.kt)("h3",{id:"example-8"},"Example"),(0,i.kt)("p",null,"In this example we are going to write a repetitive task of reading a number from standard input and then power by 2 and then print the result:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.arrow.ZArrow\nimport zio.arrow.ZArrow._\nimport zio.console._\nimport zio.{ExitCode, URIO}\n\nimport java.io.IOException\n\nobject ArrowExample extends zio.App {\n\n  val isPositive : ZArrow[Nothing, Int, Boolean]     = ZArrow((_: Int) > 0)\n  val toStr      : ZArrow[Nothing, Any, String]      = ZArrow((i: Any) => i.toString)\n  val toInt      : ZArrow[Nothing, String, Int]      = ZArrow((i: String) => i.toInt)\n  val getLine    : ZArrow[IOException, Any, String]  = ZArrow.liftM((_: Any) => getStrLn.provideLayer(Console.live))\n  val printStr   : ZArrow[IOException, String, Unit] = ZArrow.liftM((line: String) => putStr(line).provideLayer(Console.live))\n  val printLine  : ZArrow[IOException, String, Unit] = ZArrow.liftM((line: String) => putStrLn(line).provideLayer(Console.live))\n  val power2     : ZArrow[Nothing, Int, Double]      = ZArrow((i: Int) => Math.pow(i, 2))\n  val enterNumber: ZArrow[Nothing, Unit, String]     = ZArrow((_: Unit) => "Enter positive number (-1 to exit): ")\n  val goodbye    : ZArrow[Nothing, Any, String]      = ZArrow((_: Any) => "Goodbye!")\n\n  val app: ZArrow[IOException, Unit, Boolean] =\n    enterNumber >>> printStr >>> getLine >>> toInt >>>\n      ifThenElse(isPositive)(\n        power2 >>> toStr >>> printLine >>> ZArrow((_: Any) => true)\n      )(\n        ZArrow((_: Any) => false)\n      )\n\n  val myApp = whileDo(app)(ZArrow(_ => ())) >>> goodbye >>> printLine\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.run(()).exitCode\n}\n')),(0,i.kt)("p",null,"Let's see an example of running this program:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Enter positive number (-1 to exit): 25\n625.0\nEnter positive number (-1 to exit): 8\n64.0\nEnter positive number (-1 to exit): -1\nGoodbye!\n")),(0,i.kt)("h2",{id:"zio-amqp"},"ZIO AMQP"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/svroonland/zio-amqp"},"ZIO AMQP")," is a ZIO-based AMQP client for Scala."),(0,i.kt)("h3",{id:"introduction-9"},"Introduction"),(0,i.kt)("p",null,"ZIO AMQP is a ZIO-based wrapper around the RabbitMQ client. It provides a streaming interface to AMQP queues and helps to prevent us from shooting ourselves in the foot with thread-safety issues."),(0,i.kt)("h3",{id:"installation-9"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "nl.vroste" %% "zio-amqp" % "0.2.0"\n')),(0,i.kt)("h3",{id:"example-9"},"Example"),(0,i.kt)("p",null,"First, let's create an instance of RabbitMQ:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"docker run -d --name some-rabbit -p 5672:5672 -p 5673:5673 -p 15672:15672 rabbitmq:3-management\n")),(0,i.kt)("p",null,"Then we need to create ",(0,i.kt)("inlineCode",{parentName:"p"},"my_exchange")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"my_queue")," and bind the queue to the exchange via the RabbitMQ management dashboard (",(0,i.kt)("inlineCode",{parentName:"p"},"localhost:15672"),")."),(0,i.kt)("p",null,"Now we can run the example below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import nl.vroste.zio.amqp._\nimport zio._\nimport zio.blocking._\nimport zio.clock.Clock\nimport zio.console._\nimport zio.duration.durationInt\nimport zio.random.Random\n\nimport java.net.URI\n\nobject ZIOAMQPExample extends zio.App {\n\n  val channelM: ZManaged[Blocking, Throwable, Channel] = for {\n    connection <- Amqp.connect(URI.create("amqp://localhost:5672"))\n    channel <- Amqp.createChannel(connection)\n  } yield channel\n\n  val myApp: ZIO[Blocking with Console with Clock with Random, Throwable, Unit] =\n    channelM.use { channel =>\n      val producer: ZIO[Blocking with Random with Clock, Throwable, Long] =\n        zio.random.nextUUID\n          .flatMap(uuid =>\n            channel.publish("my_exchange", uuid.toString.getBytes)\n              .map(_ => ())\n          ).schedule(Schedule.spaced(1.seconds))\n\n      val consumer: ZIO[Blocking with Console, Throwable, Unit] = channel\n        .consume(queue = "my_queue", consumerTag = "my_consumer")\n        .mapM { record =>\n          val deliveryTag = record.getEnvelope.getDeliveryTag\n          putStrLn(s"Received $deliveryTag: ${new String(record.getBody)}") *>\n            channel.ack(deliveryTag)\n        }\n        .runDrain\n\n      for {\n        p <- producer.fork\n        c <- consumer.fork\n        _ <- p.zip(c).join\n      } yield ()\n    }\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n')),(0,i.kt)("h2",{id:"zio-aws"},"ZIO AWS"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/vigoo/zio-aws"},"ZIO AWS")," is a low-level AWS wrapper for ZIO for all the AWS services using the AWS Java SDK v2."),(0,i.kt)("h3",{id:"introduction-10"},"Introduction"),(0,i.kt)("p",null,"The goal is to have access to all AWS functionality for cases when only simple, direct access is needed from a ZIO application, or to be used as a building block for higher-level wrappers around specific services."),(0,i.kt)("p",null,"Key features of ZIO AWS:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Common configuration layer"),(0,i.kt)("li",{parentName:"ul"},"ZIO module layer per AWS service"),(0,i.kt)("li",{parentName:"ul"},"Wrapper for all operations on all services"),(0,i.kt)("li",{parentName:"ul"},"HTTP service implementations for functional Scala HTTP libraries, injected through ZIO\u2019s module system"),(0,i.kt)("li",{parentName:"ul"},"ZStream wrapper around paginated operations"),(0,i.kt)("li",{parentName:"ul"},"Service-specific extra configuration"),(0,i.kt)("li",{parentName:"ul"},"More idiomatic Scala request and response types wrapping the Java classes")),(0,i.kt)("h3",{id:"installation-10"},"Installation"),(0,i.kt)("p",null,"There are tones of artifacts ",(0,i.kt)("a",{parentName:"p",href:"https://vigoo.github.io/zio-aws/docs/artifacts.html"},"published")," for each AWS service. We can pick whichever services we need."),(0,i.kt)("h3",{id:"example-10"},"Example"),(0,i.kt)("p",null,"The following example uses the ",(0,i.kt)("em",{parentName:"p"},"ElasticBeanstalk")," and ",(0,i.kt)("em",{parentName:"p"},"EC2")," APIs:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "io.github.vigoo" %% "zio-aws-core"             % "3.17.8.4",\nlibraryDependencies += "io.github.vigoo" %% "zio-aws-ec2"              % "3.17.8.4",\nlibraryDependencies += "io.github.vigoo" %% "zio-aws-elasticbeanstalk" % "3.17.8.4",\nlibraryDependencies += "io.github.vigoo" %% "zio-aws-netty"            % "3.17.8.4"\n')),(0,i.kt)("p",null,"And here is the example code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import io.github.vigoo.zioaws.core.AwsError\nimport io.github.vigoo.zioaws.ec2.Ec2\nimport io.github.vigoo.zioaws.ec2.model._\nimport io.github.vigoo.zioaws.elasticbeanstalk.ElasticBeanstalk\nimport io.github.vigoo.zioaws.elasticbeanstalk.model._\nimport io.github.vigoo.zioaws.{core, ec2, elasticbeanstalk, netty}\nimport zio.console._\nimport zio.stream._\nimport zio.{console, _}\n\nobject ZIOAWSExample extends zio.App {\n  val program: ZIO[Console with Ec2 with ElasticBeanstalk, AwsError, Unit] =\n    for {\n      appsResult <- elasticbeanstalk.describeApplications(\n        DescribeApplicationsRequest(applicationNames = Some(List("my-service")))\n      )\n      app <- appsResult.applications.map(_.headOption)\n      _ <- app match {\n        case Some(appDescription) =>\n          for {\n            applicationName <- appDescription.applicationName\n            _ <- console.putStrLn(\n              s"Got application description for $applicationName"\n            ).ignore\n\n            envStream = elasticbeanstalk.describeEnvironments(\n              DescribeEnvironmentsRequest(applicationName =\n                Some(applicationName)\n              )\n            )\n\n            _ <- envStream.run(Sink.foreach { env =>\n              env.environmentName.flatMap { environmentName =>\n                (for {\n                  environmentId <- env.environmentId\n                  _ <- console.putStrLn(\n                    s"Getting the EB resources of $environmentName"\n                  ).ignore\n\n                  resourcesResult <-\n                    elasticbeanstalk.describeEnvironmentResources(\n                      DescribeEnvironmentResourcesRequest(environmentId =\n                        Some(environmentId)\n                      )\n                    )\n                  resources <- resourcesResult.environmentResources\n                  _ <- console.putStrLn(\n                    s"Getting the EC2 instances in $environmentName"\n                  ).ignore\n                  instances <- resources.instances\n                  instanceIds <- ZIO.foreach(instances)(_.id)\n                  _ <- console.putStrLn(\n                    s"Instance IDs are ${instanceIds.mkString(", ")}"\n                  ).ignore\n\n                  reservationsStream = ec2.describeInstances(\n                    DescribeInstancesRequest(instanceIds = Some(instanceIds))\n                  )\n                  _ <- reservationsStream.run(Sink.foreach { reservation =>\n                    reservation.instances\n                      .flatMap { instances =>\n                        ZIO.foreach(instances) { instance =>\n                          for {\n                            id <- instance.instanceId\n                            typ <- instance.instanceType\n                            launchTime <- instance.launchTime\n                            _ <- console.putStrLn(s"  instance $id:").ignore\n                            _ <- console.putStrLn(s"    type: $typ").ignore\n                            _ <- console.putStrLn(\n                              s"    launched at: $launchTime"\n                            ).ignore\n                          } yield ()\n                        }\n                      }\n                  })\n                } yield ()).catchAll { error =>\n                  console.putStrLnErr(\n                    s"Failed to get info for $environmentName: $error"\n                  ).ignore\n                }\n              }\n            })\n          } yield ()\n        case None =>\n          ZIO.unit\n      }\n    } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] = { //\n    val httpClient = netty.default\n    val awsConfig  = httpClient >>> core.config.default\n    val aws        = awsConfig >>> (ec2.live ++ elasticbeanstalk.live)\n\n    program\n      .provideCustomLayer(aws)\n      .either\n      .flatMap {\n        case Left(error) =>\n          console.putStrErr(s"AWS error: $error").ignore.as(ExitCode.failure)\n        case Right(_) =>\n          ZIO.unit.as(ExitCode.success)\n      }\n  }\n}\n')),(0,i.kt)("h2",{id:"zio-aws-s3"},"ZIO AWS S3"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/zio-mesh/zio-aws-s3"},"ZIO AWS S3")," is a ZIO integration with AWS S3 SDK."),(0,i.kt)("h3",{id:"introduction-11"},"Introduction"),(0,i.kt)("p",null,"This project aims to ease ZIO integration with AWS S3, providing a clean, simple and efficient API."),(0,i.kt)("h3",{id:"installation-11"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "io.github.neurodyne" %% "zio-aws-s3" % "0.4.13"\n')),(0,i.kt)("h3",{id:"example-11"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import software.amazon.awssdk.regions.Region\nimport software.amazon.awssdk.services.s3.S3AsyncClient\nimport zio.{ExitCode, URIO, _}\nimport zio_aws_s3.AwsApp.AwsLink\nimport zio_aws_s3.{AwsAgent, AwsApp}\n\nimport scala.jdk.CollectionConverters._\n\nobject ZIOAWSS3Example extends zio.App {\n  val BUCKET = "<bucket name>"\n\n  val awsEnv: ZLayer[S3AsyncClient, Throwable, AwsLink] =\n    AwsApp.ExtDeps.live >>> AwsApp.AwsLink.live\n\n  val app: ZIO[Any, Throwable, Unit] = for {\n    s3 <- AwsAgent.createClient(Region.US_WEST_2, "<endpoint>")\n    response <- AwsApp.listBuckets().provideLayer(awsEnv).provide(s3)\n    buckets <- Task(response.buckets.asScala.toList.map(_.name))\n    _ = buckets.foreach(println)\n  } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    app.exitCode\n}\n')),(0,i.kt)("h2",{id:"zio-http"},"ZIO HTTP"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/dream11/zio-http"},"ZIO HTTP")," is a scala library to write HTTP applications."),(0,i.kt)("h3",{id:"introduction-12"},"Introduction"),(0,i.kt)("p",null,"ZIO HTTP is a Scala library for building HTTP applications. It is powered by ZIO and netty and aims at being the defacto solution for writing, highly scalable, and performant web applications using idiomatic scala."),(0,i.kt)("h3",{id:"installation-12"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following lines in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "io.d11" %% "zhttp"      % "1.0.0.0-RC13"\nlibraryDependencies += "io.d11" %% "zhttp-test" % "1.0.0.0-RC13" % Test\n')),(0,i.kt)("h3",{id:"example-12"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zhttp.http._\nimport zhttp.service.Server\nimport zio._\n\nobject ZIOHTTPExample extends zio.App {\n\n  // Create HTTP route\n  val app: HttpApp[Any, Nothing] = HttpApp.collect {\n    case Method.GET -> Root / "text" => Response.text("Hello World!")\n    case Method.GET -> Root / "json" => Response.jsonString("""{"greetings": "Hello World!"}""")\n  }\n\n  // Run it like any simple app\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    Server.start(8090, app.silent).exitCode\n}\n')),(0,i.kt)("h2",{id:"zio-k8s"},"ZIO K8s"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/coralogix/zio-k8s"},"ZIO K8S")," is an idiomatic ZIO client for the Kubernetes API."),(0,i.kt)("h3",{id:"introduction-13"},"Introduction"),(0,i.kt)("p",null,"This library provides a client for the full Kubernetes API as well as providing code generator support for custom resources and higher-level concepts such as operators, taking full advantage of the ZIO library."),(0,i.kt)("p",null,"Using ZIO K8S we can talk to the Kubernetes API that helps us to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Write an operator for our custom resource types"),(0,i.kt)("li",{parentName:"ul"},"Schedule some jobs in our cluster"),(0,i.kt)("li",{parentName:"ul"},"Query the cluster for monitoring purposes"),(0,i.kt)("li",{parentName:"ul"},"Write some cluster management tools")),(0,i.kt)("h3",{id:"installation-13"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "com.coralogix" %% "zio-k8s-client" % "1.3.3"\n')),(0,i.kt)("p",null,"And then we need to choose the proper sttp backend:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'"com.softwaremill.sttp.client3" %% "httpclient-backend-zio" % "3.1.1",\n"com.softwaremill.sttp.client3" %% "slf4j-backend"          % "3.1.1"\n')),(0,i.kt)("p",null,"Or the asynchronous version:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'"com.softwaremill.sttp.client3" %% "async-http-client-backend-zio" % "3.1.1"\n"com.softwaremill.sttp.client3" %% "slf4j-backend"                 % "3.1.1"\n')),(0,i.kt)("h3",{id:"example-13"},"Example"),(0,i.kt)("p",null,"This is an example of printing the tail logs of a container:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import com.coralogix.zio.k8s.client.K8sFailure\nimport com.coralogix.zio.k8s.client.config.httpclient._\nimport com.coralogix.zio.k8s.client.model.K8sNamespace\nimport com.coralogix.zio.k8s.client.v1.pods\nimport com.coralogix.zio.k8s.client.v1.pods.Pods\nimport zio._\nimport zio.console.Console\n\nimport scala.languageFeature.implicitConversions\n\nobject ZIOK8sLogsExample extends zio.App {\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] = (args match {\n    case List(podName) => tailLogs(podName, None)\n    case List(podName, containerName) => tailLogs(podName, Some(containerName))\n    case _ => console.putStrLnErr("Usage: <podname> [containername]")\n  })\n    .provideCustomLayer(k8sDefault >>> Pods.live)\n    .exitCode\n\n  def tailLogs(podName: String,\n               containerName: Option[String]\n              ): ZIO[Pods with Console, K8sFailure, Unit] =\n    pods\n      .getLog(\n        name = podName,\n        namespace = K8sNamespace.default,\n        container = containerName,\n        follow = Some(true)\n      )\n      .tap { line: String =>\n        console.putStrLn(line).ignore\n      }\n      .runDrain\n}\n')),(0,i.kt)("h2",{id:"zio-kinesis"},"ZIO Kinesis"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/svroonland/zio-kinesis"},"ZIO Kinesis")," is a ZIO-based AWS Kinesis client for Scala."),(0,i.kt)("h3",{id:"introduction-14"},"Introduction"),(0,i.kt)("p",null,"ZIO Kinesis is an interface to Amazon Kinesis Data Streams for consuming and producing data. This library is built on top of ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/vigoo/zio-aws"},"ZIO AWS"),", a library of automatically generated ZIO wrappers around AWS SDK methods."),(0,i.kt)("h3",{id:"installation-14"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "nl.vroste" %% "zio-kinesis" % "0.20.0"\n')),(0,i.kt)("h3",{id:"example-14"},"Example"),(0,i.kt)("p",null,"This is an example of consuming a stream from Amazon Kinesis:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc:silent:reset","mdoc:silent:reset":!0},'import nl.vroste.zio.kinesis.client.serde.Serde\nimport nl.vroste.zio.kinesis.client.zionative.Consumer\nimport zio.clock.Clock\nimport zio.console.{Console, putStrLn}\nimport zio.duration._\nimport zio.logging.Logging\nimport zio.{ExitCode, URIO, _}\n\nobject ZIOKinesisConsumerExample extends zio.App {\n  val loggingLayer: ZLayer[Any, Nothing, Logging] =\n    (Console.live ++ Clock.live) >>>\n      Logging.console() >>>\n      Logging.withRootLoggerName(getClass.getName)\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    Consumer\n      .consumeWith(\n        streamName = "my-stream",\n        applicationName = "my-application",\n        deserializer = Serde.asciiString,\n        workerIdentifier = "worker1",\n        checkpointBatchSize = 1000L,\n        checkpointDuration = 5.minutes\n      )(record => putStrLn(s"Processing record $record"))\n      .provideCustomLayer(Consumer.defaultEnvironment ++ loggingLayer)\n      .exitCode\n}\n')),(0,i.kt)("h2",{id:"zio-pulsar"},"ZIO Pulsar"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/apache/pulsar"},"ZIO Pulsar")," is the ",(0,i.kt)("em",{parentName:"p"},"Apache Pulsar")," client for Scala with ZIO and ZIO Streams integration."),(0,i.kt)("h3",{id:"introduction-15"},"Introduction"),(0,i.kt)("p",null,"ZIO Pulsar is a purely functional Scala wrapper over the official Pulsar client. Some key features of this library:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Type-safe")," \u2014 Utilizes Scala type system to reduce runtime exceptions present in the official Java client."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Streaming-enabled")," \u2014 Naturally integrates with ZIO Streams."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ZIO integrated")," \u2014 Uses common ZIO primitives like ZIO effect and ",(0,i.kt)("inlineCode",{parentName:"li"},"ZManaged")," to reduce the boilerplate and increase expressiveness.")),(0,i.kt)("h3",{id:"installation-15"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file for ",(0,i.kt)("em",{parentName:"p"},"Scala 3"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "com.github.jczuchnowski" %% "zio-pulsar" % "0.1"\n')),(0,i.kt)("h3",{id:"example-15"},"Example"),(0,i.kt)("p",null,"First of all we need to create an instance of ",(0,i.kt)("em",{parentName:"p"},"Apache Pulsar")," and run that:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"docker run -it \\\n  -p 6650:6650 \\\n  -p 8080:8080 \\\n  --mount source=pulsardata,target=/pulsar/data \\\n  --mount source=pulsarconf,target=/pulsar/conf \\\n  --network pulsar \\\n  apachepulsar/pulsar:2.7.0 \\\n  bin/pulsar standalone\n")),(0,i.kt)("p",null,"Now we can run the following example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import org.apache.pulsar.client.api.{PulsarClientException, Schema}\nimport zio._\nimport zio.blocking._\nimport zio.clock._\nimport zio.console._\nimport zio.pulsar._\nimport zio.stream._\n\nimport java.nio.charset.StandardCharsets\n\nobject StreamingExample extends zio.App {\n  val topic = "my-topic"\n\n  val producer: ZManaged[Has[PulsarClient], PulsarClientException, Unit] =\n    for {\n      sink <- Producer.make(topic, Schema.STRING).map(_.asSink)\n      _ <- Stream.fromIterable(0 to 100).map(i => s"Message $i").run(sink).toManaged_\n    } yield ()\n\n  val consumer: ZManaged[Has[PulsarClient] with Blocking with Console, PulsarClientException, Unit] =\n    for {\n      builder <- ConsumerBuilder.make(Schema.STRING).toManaged_\n      consumer <- builder\n        .subscription(Subscription("my-subscription", SubscriptionType.Exclusive))\n        .topic(topic)\n        .build\n      _ <- consumer.receiveStream.take(10).foreach { e =>\n        consumer.acknowledge(e.getMessageId) *>\n          putStrLn(new String(e.getData, StandardCharsets.UTF_8)).orDie\n      }.toManaged_\n    } yield ()\n\n  val myApp =\n    for {\n      f <- consumer.fork\n      _ <- producer\n      _ <- f.join.toManaged_\n    } yield ()\n\n  def run(args: List[String]): URIO[ZEnv, ExitCode] =\n    myApp\n      .provideCustomLayer(\n        (Console.live ++ Clock.live) >+>\n          PulsarClient.live("localhost", 6650)\n      ).useNow.exitCode\n}\n')),(0,i.kt)("h2",{id:"zio-saga"},"ZIO Saga"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/VladKopanev/zio-saga"},"ZIO Saga")," is a distributed transaction manager using Saga Pattern."),(0,i.kt)("h3",{id:"introduction-16"},"Introduction"),(0,i.kt)("p",null,"Sometimes when we are architecting the business logic using microservice architecture we need distributed transactions that are across services. "),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"Saga Pattern")," lets us manage distributed transactions by sequencing local transactions with their corresponding compensating actions. A ",(0,i.kt)("em",{parentName:"p"},"Saga Pattern")," runs all operations. In the case of failure, it guarantees us to undo all previous works by running the compensating actions."),(0,i.kt)("p",null,"ZIO Saga allows us to compose our requests and compensating actions from the Saga pattern in one transaction with no boilerplate."),(0,i.kt)("p",null,"ZIO Saga adds a simple abstraction called ",(0,i.kt)("inlineCode",{parentName:"p"},"Saga")," that takes the responsibility of proper composition of effects and associated compensating actions."),(0,i.kt)("h3",{id:"installation-16"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "com.vladkopanev" %% "zio-saga-core" % "0.4.0"\n')),(0,i.kt)("h3",{id:"example-16"},"Example"),(0,i.kt)("p",null,"In the following example, all API requests have a compensating action. We compose all them together and then run the whole as one transaction:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import com.vladkopanev.zio.saga.Saga\nimport zio.{IO, UIO, URIO, ZIO}\n\nimport com.vladkopanev.zio.saga.Saga._\n\nval transaction: Saga[Any, String, Unit] =\n  for {\n    _ <- bookHotel compensate cancelHotel\n    _ <- bookTaxi compensate cancelTaxi\n    _ <- bookFlight compensate cancelFlight\n  } yield ()\n\nval myApp: ZIO[Any, String, Unit] = transaction.transact\n")),(0,i.kt)("h2",{id:"zio-slick-interop"},"ZIO Slick Interop"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ScalaConsultants/zio-slick-interop"},"ZIO Slick Interop")," is a small library, that provides interop between Slick and ZIO."),(0,i.kt)("h3",{id:"installation-17"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "io.scalac" %% "zio-slick-interop" % "0.4.0"\n')),(0,i.kt)("h3",{id:"example-17"},"Example"),(0,i.kt)("p",null,"To run this example we should also add the ",(0,i.kt)("em",{parentName:"p"},"HikariCP integration for Slick")," in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "com.typesafe.slick" %% "slick-hikaricp" % "3.3.3"\n')),(0,i.kt)("p",null,"Here is a full working example of creating database-agnostic Slick repository:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import com.typesafe.config.ConfigFactory\nimport slick.interop.zio.DatabaseProvider\nimport slick.interop.zio.syntax._\nimport slick.jdbc.H2Profile.api._\nimport slick.jdbc.JdbcProfile\nimport zio.console.Console\nimport zio.interop.console.cats.putStrLn\nimport zio.{ExitCode, Has, IO, URIO, ZIO, ZLayer}\n\nimport scala.jdk.CollectionConverters._\n\ncase class Item(id: Long, name: String)\n\ntrait ItemRepository {\n  def add(name: String): IO[Throwable, Long]\n\n  def getById(id: Long): IO[Throwable, Option[Item]]\n\n  def upsert(name: String): IO[Throwable, Long]\n}\n\nobject ItemsTable {\n  class Items(tag: Tag) extends Table[Item](\n    _tableTag = tag,\n    _tableName = "ITEMS"\n  ) {\n    def id = column[Long]("ID", O.PrimaryKey, O.AutoInc)\n\n    def name = column[String]("NAME")\n\n    def * = (id, name) <> ((Item.apply _).tupled, Item.unapply _)\n  }\n\n  val table = TableQuery[ItemsTable.Items]\n}\n\nobject SlickItemRepository {\n  val live: ZLayer[Has[DatabaseProvider], Throwable, Has[ItemRepository]] =\n    ZLayer.fromServiceM { db =>\n      db.profile.flatMap { profile =>\n        import profile.api._\n\n        val initialize = ZIO.fromDBIO(ItemsTable.table.schema.createIfNotExists)\n\n        val repository = new ItemRepository {\n          private val items = ItemsTable.table\n\n          def add(name: String): IO[Throwable, Long] =\n            ZIO\n              .fromDBIO((items returning items.map(_.id)) += Item(0L, name))\n              .provide(Has(db))\n\n          def getById(id: Long): IO[Throwable, Option[Item]] = {\n            val query = items.filter(_.id === id).result\n\n            ZIO.fromDBIO(query).map(_.headOption).provide(Has(db))\n          }\n\n          def upsert(name: String): IO[Throwable, Long] =\n            ZIO\n              .fromDBIO { implicit ec =>\n                (for {\n                  itemOpt <- items.filter(_.name === name).result.headOption\n                  id <- itemOpt.fold[DBIOAction[Long, NoStream, Effect.Write]](\n                    (items returning items.map(_.id)) += Item(0L, name)\n                  )(item => (items.map(_.name) update name).map(_ => item.id))\n                } yield id).transactionally\n              }\n              .provide(Has(db))\n        }\n\n        initialize.as(repository).provide(Has(db))\n      }\n    }\n}\n\n\nobject Main extends zio.App {\n\n  private val config = ConfigFactory.parseMap(\n    Map(\n      "url" -> "jdbc:h2:mem:test1;DB_CLOSE_DELAY=-1",\n      "driver" -> "org.h2.Driver",\n      "connectionPool" -> "disabled"\n    ).asJava\n  )\n\n  private val env: ZLayer[Any, Throwable, Has[ItemRepository]] =\n    (ZLayer.succeed(config) ++ ZLayer.succeed[JdbcProfile](\n      slick.jdbc.H2Profile\n    )) >>> DatabaseProvider.live >>> SlickItemRepository.live\n\n  val myApp: ZIO[Console with Has[ItemRepository], Throwable, Unit] =\n    for {\n      repo <- ZIO.service[ItemRepository]\n      aId1 <- repo.add("A")\n      _ <- repo.add("B")\n      a <- repo.getById(1L)\n      b <- repo.getById(2L)\n      aId2 <- repo.upsert("A")\n      _ <- putStrLn(s"$aId1 == $aId2")\n      _ <- putStrLn(s"A item: $a")\n      _ <- putStrLn(s"B item: $b")\n    } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.provideCustomLayer(env).exitCode\n}\n')),(0,i.kt)("h2",{id:"zio-test-akka-http"},"ZIO Test Akka HTTP"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/senia-psm/zio-test-akka-http"},"ZIO Test Akka HTTP")," is an Akka-HTTP Route TestKit for zio-test."),(0,i.kt)("h3",{id:"installation-18"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "info.senia" %% "zio-test-akka-http" % "1.0.2"\n')),(0,i.kt)("h3",{id:"example-18"},"Example"),(0,i.kt)("p",null,"An example of writing Akka HTTP Route test spec:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import akka.http.scaladsl.model.HttpResponse\nimport akka.http.scaladsl.server.Directives.complete\nimport zio.test.Assertion._\nimport zio.test._\nimport zio.test.akkahttp.DefaultAkkaRunnableSpec\n\nobject MySpec extends DefaultAkkaRunnableSpec {\n  def spec =\n    suite("MySpec")(\n      testM("my test") {\n        assertM(Get() ~> complete(HttpResponse()))(\n          handled(\n            response(equalTo(HttpResponse()))\n          )\n        )\n      }\n    )\n}\n')),(0,i.kt)("h2",{id:"zparkio"},"ZparkIO"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/leobenkel/ZparkIO"},"ZParkIO")," is a boilerplate framework to use ",(0,i.kt)("em",{parentName:"p"},"Spark")," and ",(0,i.kt)("em",{parentName:"p"},"ZIO")," together."),(0,i.kt)("h3",{id:"introduction-17"},"Introduction"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"ZparkIO")," enables us to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Wrap asynchronous and synchronous operations smoothly. So everything is wrapped in ZIO."),(0,i.kt)("li",{parentName:"ul"},"Have ZIO features in our spark jobs, like forking and joining fibers, parallelizing tasks, retrying, and timing-out."),(0,i.kt)("li",{parentName:"ul"},"Make our spark job much easier to debug")),(0,i.kt)("h3",{id:"installation-19"},"Installation"),(0,i.kt)("p",null,"In order to use this library, we need to add the following line in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "com.leobenkel" %% "zparkio" % "[SPARK_VERSION]_[VERSION]"\n')),(0,i.kt)("h3",{id:"example-19"},"Example"),(0,i.kt)("p",null,"Using ",(0,i.kt)("em",{parentName:"p"},"ZparkIO")," we can write jobs like the following example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import com.leobenkel.zparkio.Services.SparkModule\nimport com.leobenkel.zparkio.Services.SparkModule.SparkModule\nimport com.leobenkel.zparkio.ZparkioApplicationTimeoutException\nimport org.apache.spark.sql.DataFrame\nimport zio.clock.Clock\nimport zio.duration.durationInt\nimport zio.{Schedule, Task, ZIO}\n\ndef readParquetFile[A](parquetPath: String): ZIO[Clock with SparkModule, Throwable, DataFrame] =\n  for {\n    spark <- SparkModule()\n    dataset <- Task(spark.read.parquet(parquetPath))\n      .retry(\n        Schedule.recurs(3) && Schedule.exponential(2.seconds)\n      )\n      .timeoutFail(ZparkioApplicationTimeoutException())(5.minutes)\n  } yield dataset\n")),(0,i.kt)("h2",{id:"quill"},"Quill"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/getquill/quill"},"Quil")," is a Compile-time Language Integrated Queries for Scala."),(0,i.kt)("h3",{id:"introduction-18"},"Introduction"),(0,i.kt)("p",null,"Quill allows us to create SQL out of a Scala code during the ",(0,i.kt)("strong",{parentName:"p"},"compile-time"),". It provides the ",(0,i.kt)("em",{parentName:"p"},"Quoted Domain Specific Language (QDSL)")," to express queries in Scala and execute them in a target language."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Boilerplate-free mapping")," \u2014 The database schema is mapped using simple case classes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Quoted DSL")," \u2014 Queries are defined inside a quote block. Quill parses each quoted block of code (quotation) at compile-time and translates them to an internal Abstract Syntax Tree (AST)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Compile-time query generation")," \u2014 The ",(0,i.kt)("inlineCode",{parentName:"li"},"ctx.run")," call reads the quotation\u2019s AST and translates it to the target language at compile-time, emitting the query string as a compilation message. As the query string is known at compile-time, the runtime overhead is very low and similar to using the database driver directly."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Compile-time query validation")," \u2014 If configured, the query is verified against the database at compile-time and the compilation fails if it is not valid. The query validation does not alter the database state.")),(0,i.kt)("h3",{id:"installation-20"},"Installation"),(0,i.kt)("p",null,"In order to use this library with ZIO, we need to add the following lines in our ",(0,i.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// Provides Quill contexts for ZIO.\nlibraryDependencies += "io.getquill" %% "quill-zio" % "3.9.0"\n\n// Provides Quill context that execute MySQL, PostgreSQL, SQLite, H2, SQL Server and Oracle queries inside of ZIO.\nlibraryDependencies += "io.getquill" %% "quill-jdbc-zio" % "3.9.0" \n\n// Provides Quill context that executes Cassandra queries inside of ZIO.\nlibraryDependencies += "io.getquill" %% "quill-cassandra-zio" % "3.9.0"\n')),(0,i.kt)("h3",{id:"example-20"},"Example"),(0,i.kt)("p",null,"First, to run this example, we should create the ",(0,i.kt)("inlineCode",{parentName:"p"},"Person")," table at the database initialization. Let's put the following lines into the ",(0,i.kt)("inlineCode",{parentName:"p"},"h2-schema.sql")," file at the",(0,i.kt)("inlineCode",{parentName:"p"},"src/main/resources")," path:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE IF NOT EXISTS Person(\n    name VARCHAR(255),\n    age int\n);\n")),(0,i.kt)("p",null,"In this example, we use in-memory database as our data source. So we just put these lines into the ",(0,i.kt)("inlineCode",{parentName:"p"},"application.conf")," at the ",(0,i.kt)("inlineCode",{parentName:"p"},"src/main/resources")," path:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-hocon"},"myH2DB {\n  dataSourceClassName = org.h2.jdbcx.JdbcDataSource\n  dataSource {\n    url = \"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;INIT=RUNSCRIPT FROM 'classpath:h2-schema.sql'\"\n    user = sa\n  }\n}\n")),(0,i.kt)("p",null,"Now we are ready to run the example below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import io.getquill._\nimport io.getquill.context.ZioJdbc._\nimport zio.console.{Console, putStrLn}\nimport zio.{ExitCode, Has, URIO, ZIO}\n\nimport java.io.Closeable\nimport javax.sql\n\nobject QuillZIOExample extends zio.App {\n  val ctx = new H2ZioJdbcContext(Literal)\n\n  import ctx._\n\n  case class Person(name: String, age: Int)\n\n  val myApp: ZIO[Console with Has[sql.DataSource with Closeable], Exception, Unit] =\n    for {\n      _ <- ctx.run(\n        quote {\n          liftQuery(List(Person("Alex", 25), Person("Sarah", 23)))\n            .foreach(r =>\n              query[Person].insert(r)\n            )\n        }\n      ).onDS\n      result <- ctx.run(\n        quote(query[Person].filter(p => p.name == "Sarah"))\n      ).onDS\n      _ <- putStrLn(result.toString)\n    } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp\n      .provideCustomLayer(DataSourceLayer.fromPrefix("myH2DB"))\n      .exitCode\n}\n')))}d.isMDXComponent=!0}}]);