"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[71959],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),d=s(n),c=o,h=d["".concat(p,".").concat(c)]||d[c]||u[c]||i;return n?a.createElement(h,l(l({ref:t},m),{},{components:n})):a.createElement(h,l({ref:t},m))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,l=new Array(i);l[0]=c;var r={};for(var p in t)hasOwnProperty.call(t,p)&&(r[p]=t[p]);r.originalType=e,r[d]="string"==typeof e?e:o,l[1]=r;for(var s=2;s<i;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},71275:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>s});var a=n(87462),o=(n(67294),n(3905));const i={id:"nonemptylist",title:"NonEmptyList"},l=void 0,r={unversionedId:"zio-prelude/functional-data-types/nonemptylist",id:"zio-prelude/functional-data-types/nonemptylist",title:"NonEmptyList",description:"NonEmptyList represents a List that is guaranteed not to be empty.",source:"@site/docs/zio-prelude/functional-data-types/nonemptylist.md",sourceDirName:"zio-prelude/functional-data-types",slug:"/zio-prelude/functional-data-types/nonemptylist",permalink:"/zio-prelude/functional-data-types/nonemptylist",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-data-types/nonemptylist.md",tags:[],version:"current",frontMatter:{id:"nonemptylist",title:"NonEmptyList"},sidebar:"ecosystem-sidebar",previous:{title:"Equivalence",permalink:"/zio-prelude/functional-data-types/equivalence"},next:{title:"These",permalink:"/zio-prelude/functional-data-types/these"}},p={},s=[{value:"Constructing NonEmptyList Values",id:"constructing-nonemptylist-values",level:2},{value:"Working With NonEmptyList Values",id:"working-with-nonemptylist-values",level:2},{value:"Interoperability With Scala Collections",id:"interoperability-with-scala-collections",level:2}],m={toc:s},d="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," represents a ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," that is guaranteed not to be empty."),(0,o.kt)("p",null,"This is useful to allow more accurate domain modeling in situations where we know a collection is not empty."),(0,o.kt)("p",null,"For example, we might be handling a collection of errors. If an error has occurred at all then we know the collection is not empty."),(0,o.kt)("p",null,"However, if we are working with a collection type from the Scala standard library such as ",(0,o.kt)("inlineCode",{parentName:"p"},"List"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Vector"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"Iterable")," then the Scala compiler does not know that. It will force us to handle the case where the collection is empty even though we know that cannot occur."),(0,o.kt)("p",null,"Or perhaps we are implementing a batched API and need to handle a collection of requests. We know the collection is not empty, or we would not have been called at all, but now we have to handle the case of an empty collection."),(0,o.kt)("p",null,"Sometimes there are sensible defaults in these cases, but other times we are forced to resort to potentially unsafe operators like ",(0,o.kt)("inlineCode",{parentName:"p"},"head")," or to throw exceptions in branches of logic we know should never occur. This wastes developer time, makes code harder to understand, and encourages bad coding practices."),(0,o.kt)("p",null,"To avoid these problems we want a data type that is specific enough to describe at the type level what we know to be true, in this case that a collection is not empty."),(0,o.kt)("p",null,"We can try to represent this using the ",(0,o.kt)("inlineCode",{parentName:"p"},"::")," case of ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," from the Scala standard library but unfortunately ",(0,o.kt)("inlineCode",{parentName:"p"},"::")," itself has extremely poor ergonomics. It is hard to construct ",(0,o.kt)("inlineCode",{parentName:"p"},"::")," values, and it is easy for operators to forget the more specific type. This is where ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," comes in."),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait NonEmptyList[+A]\n\nobject NonEmptyList {\n  case class Single[A](head: A)                      extends NonEmptyList[A]\n  case class Cons[A](head: A, tail: NonEmptyList[A]) extends NonEmptyList[A]\n}\n")),(0,o.kt)("p",null,"We can see that ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," looks very similar to ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," except that there is no ",(0,o.kt)("inlineCode",{parentName:"p"},"Nil")," case. A ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," is either a ",(0,o.kt)("inlineCode",{parentName:"p"},"Single")," with a single value of type ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," or a ",(0,o.kt)("inlineCode",{parentName:"p"},"Cons")," with a value of type ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," and a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," of further values of type ",(0,o.kt)("inlineCode",{parentName:"p"},"A"),"."),(0,o.kt)("p",null,"Generally you should just be able to use higher level operators on ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," but if you ever want to implement your own operators on ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," you can do so by pattern matching on a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," just like you would on a ",(0,o.kt)("inlineCode",{parentName:"p"},"List"),"."),(0,o.kt)("h2",{id:"constructing-nonemptylist-values"},"Constructing NonEmptyList Values"),(0,o.kt)("p",null,"The easiest way to construct a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," is with the ",(0,o.kt)("inlineCode",{parentName:"p"},"apply")," operator."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"trait NonEmptyList[+A]\n\nobject NonEmptyList {\n  def apply[A](a: A, as: A*): NonEmptyList[A] =\n    ???\n}\n")),(0,o.kt)("p",null,"If we already have another collection type we can convert it into a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," using the ",(0,o.kt)("inlineCode",{parentName:"p"},"fromIterableOption")," operator."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"object NonEmptyList {\n  def fromIterableOption[A](as: Iterable[A]): Option[NonEmptyList[A]] =\n    ???\n}\n")),(0,o.kt)("p",null,"Notice that ",(0,o.kt)("inlineCode",{parentName:"p"},"fromIterableOption")," returns an ",(0,o.kt)("inlineCode",{parentName:"p"},"Option[NonEmptyList[A]]")," because the original collection might be empty, and so we might not be able to construct a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," from it."),(0,o.kt)("p",null,"If we know the collection is not empty we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"fromIterable")," operator and provide the first element of the collection to establish that it is not empty."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"object NonEmptyList {\n  def fromIterable[A](a: A, as: Iterable[A]): NonEmptyList[A] =\n    ???\n}\n")),(0,o.kt)("p",null,"We can also construct a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," from the ",(0,o.kt)("inlineCode",{parentName:"p"},"::")," case of a ",(0,o.kt)("inlineCode",{parentName:"p"},"List"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"object NonEmptyList {\n  def fromCons[A](as: ::[A]): NonEmptyList[A] =\n    ???\n}\n")),(0,o.kt)("p",null,"This is useful if we already have a ",(0,o.kt)("inlineCode",{parentName:"p"},"::")," value, for example from a ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO")," operator like ",(0,o.kt)("inlineCode",{parentName:"p"},"ZIO.validate")," that returns ",(0,o.kt)("inlineCode",{parentName:"p"},"::[E]")," if it fails."),(0,o.kt)("p",null,"In addition to these operators for constructing ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," values from other values there are a couple of operators that are useful for building up ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," values."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"single")," operator lets us construct a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," from a single value. The ",(0,o.kt)("inlineCode",{parentName:"p"},"cons")," operator lets us construct a new ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," from an existing ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," and a new head value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"object NonEmptyList {\n  def cons[A](a: A, as: NonEmptyList[A]): NonEmptyList[A] =\n    ???\n  def single[A](a: A): NonEmptyList[A] =\n    ???\n}\n")),(0,o.kt)("p",null,"These operators let us build larger ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," values from smaller ones in recursive algorithms much like the ",(0,o.kt)("inlineCode",{parentName:"p"},"::")," operator and ",(0,o.kt)("inlineCode",{parentName:"p"},"Nil")," allow us to do for ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," values."),(0,o.kt)("h2",{id:"working-with-nonemptylist-values"},"Working With NonEmptyList Values"),(0,o.kt)("p",null,"The operators on ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," values are essentially the same as those on ",(0,o.kt)("inlineCode",{parentName:"p"},"List"),". So if you know how to work with a ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," you know how to work with a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList"),"."),(0,o.kt)("p",null,"The main difference between a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," and a ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," is that many operators are safe on ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," that are not safe on ",(0,o.kt)("inlineCode",{parentName:"p"},"List"),"."),(0,o.kt)("p",null,"For example, we would generally not consider it a good practice to call ",(0,o.kt)("inlineCode",{parentName:"p"},"head")," on a ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," because that could throw an exception. However, it is fine to call ",(0,o.kt)("inlineCode",{parentName:"p"},"head")," on a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," because it is always guaranteed to contain at most one value."),(0,o.kt)("p",null,"Similarly, we can use ",(0,o.kt)("inlineCode",{parentName:"p"},"reduceLeft")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"reduceRight")," to reduce the elements of a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," to a summary value even though this would not be safe to do on a ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," because we know there is always at least one element."),(0,o.kt)("p",null,"The other difference between a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," and a ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," is that operators on ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," will try to preserve the knowledge that the list is not empty whenever possible."),(0,o.kt)("p",null,"For example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," operator on ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"trait NonEmptyList[+A] {\n  def map[B](f: A => B): NonEmptyList[B]\n}\n")),(0,o.kt)("p",null,"The return type is also a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," because ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," transforms each element with a function but does not change the number of elements, so if the original list was not empty then we know that the resulting list is not empty."),(0,o.kt)("p",null,"However, sometimes it is not possible to preserve this information because of the nature of the operator."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"trait NonEmptyList[+A] {\n  def dropWhile(f: A => Boolean): List[A]\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"dropWhile")," operator returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"List[A]")," instead of a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList[A]")," because it could drop all of the elements of the list, resulting in a list that is empty. So we can no longer return a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList"),"."),(0,o.kt)("p",null,"The final difference between ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," is some additional operators are provided that take advantage of the fact that we know the list is not empty."),(0,o.kt)("p",null,"The most notable of these are ",(0,o.kt)("inlineCode",{parentName:"p"},"reduceMapLeft")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"reduceMapRight"),", which take the place of ",(0,o.kt)("inlineCode",{parentName:"p"},"foldLeft")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"foldRight"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"trait NonEmptyList[+A] {\n  def reduceMapLeft[B](map: A => B)(reduce: (B, A) => B): B\n  def reduceMapRight[B](map: A => B)(reduce: (A, B) => B): B\n}\n")),(0,o.kt)("p",null,"On standard collections ",(0,o.kt)("inlineCode",{parentName:"p"},"foldLeft")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"foldRight"),' are fundamental collection operators that allow us to "tear down" a collection to a summary value by providing an initial value to use if the collection is empty and a way to update that initial value for every element in the collection.'),(0,o.kt)("p",null,"Since we know that a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," contains at least one value, we don't need to provide an initial value for when the list is empty and can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"reduceLeft")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"reduceRight")," operators. However, these operators don't provide us quite the power we need in a lot of situations because they don't allow the type of the summary value to differ from the type of the elements in the collection."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"reduceMapLeft")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"reduceMapRight")," operators allow us to transform the first value in the ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," to the summary value and then combine each other value with that summary value. This is useful because it allows us to preserve the information that the collection is not empty."),(0,o.kt)("p",null,"For example, here is how we could use ",(0,o.kt)("inlineCode",{parentName:"p"},"reduceMapLeft")," to convert a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," to a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyChunk"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.NonEmptyChunk\nimport zio.prelude.NonEmptyList\n\ndef toNonEmptyChunk[A](as: NonEmptyList[A]): NonEmptyChunk[A] =\n  as.reduceMapLeft(a => NonEmptyChunk(a))(_ appended _)\n")),(0,o.kt)("p",null,"This would have been difficult to express with ",(0,o.kt)("inlineCode",{parentName:"p"},"foldLeft")," because we would have had to start with an initial value that was an empty chunk and thus would have gotten back a ",(0,o.kt)("inlineCode",{parentName:"p"},"Chunk")," instead of a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyChunk"),"."),(0,o.kt)("p",null,"Of course, we could have just used the ",(0,o.kt)("inlineCode",{parentName:"p"},"toNonEmptyChunk")," operator on ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def toNonEmptyChunk[A](as: NonEmptyList[A]): NonEmptyChunk[A] =\n  as.toNonEmptyChunk\n")),(0,o.kt)("h2",{id:"interoperability-with-scala-collections"},"Interoperability With Scala Collections"),(0,o.kt)("p",null,"One of the great features of the ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," data type is its excellent integration with the Scala standard library collections framework."),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," is implicitly convertible into the ",(0,o.kt)("inlineCode",{parentName:"p"},"::")," case of a ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," so anywhere you need a ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," and provide a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," it will just work."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.prelude.NonEmptyList\n\ndef myExistingAPI(as: List[Int]): String =\n  "Some fancy stuff"\n\nval nonEmptyList: NonEmptyList[Int] =\n  NonEmptyList(1, 2, 3)\n// nonEmptyList: NonEmptyList[Int] = Cons(\n//   head = 1,\n//   tail = Cons(head = 2, tail = Single(head = 3))\n// )\n\nmyExistingAPI(nonEmptyList)\n// res2: String = "Some fancy stuff"\n')),(0,o.kt)("p",null,"This is also extremely convenient because it means all operators available on ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," are available on ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList"),"."),(0,o.kt)("p",null,"For example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"filter")," operator is not implemented directly on ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList"),". But you can still filter a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," because we can always view a ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," as a ",(0,o.kt)("inlineCode",{parentName:"p"},"List"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"val filtered: List[Int] =\n  nonEmptyList.filter(_ % 2 == 0)\n// filtered: List[Int] = List(2)\n")),(0,o.kt)("p",null,"The return type of ",(0,o.kt)("inlineCode",{parentName:"p"},"List[Int]")," is as specific as possible because the ",(0,o.kt)("inlineCode",{parentName:"p"},"filter")," operator could filter out all the elements of the list and return a list that is empty."),(0,o.kt)("p",null,"Thus, ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," lets us work in a way that is as close as possible to being as if ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," was a subtype of ",(0,o.kt)("inlineCode",{parentName:"p"},"List"),", which conceptually it is."))}u.isMDXComponent=!0}}]);