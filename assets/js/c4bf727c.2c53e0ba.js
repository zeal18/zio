"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[34874],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>g});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=l(n),d=a,g=u["".concat(p,".").concat(d)]||u[d]||m[d]||i;return n?r.createElement(g,o(o({ref:t},c),{},{components:n})):r.createElement(g,o({ref:t},c))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[u]="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},15799:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=n(87462),a=(n(67294),n(3905));const i={id:"opencensus",title:"OpenCensus"},o=void 0,s={unversionedId:"zio-telemetry/opencensus",id:"zio-telemetry/opencensus",title:"OpenCensus",description:"OpenCensus is a stats collection and distributed tracing framework. Well known implementations are Jaeger",source:"@site/docs/zio-telemetry/opencensus.md",sourceDirName:"zio-telemetry",slug:"/zio-telemetry/opencensus",permalink:"/zio-telemetry/opencensus",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-telemetry/opencensus.md",tags:[],version:"current",frontMatter:{id:"opencensus",title:"OpenCensus"},sidebar:"ecosystem-sidebar",previous:{title:"OpenTracing Example",permalink:"/zio-telemetry/opentracing-example"},next:{title:"OpenTelemetry",permalink:"/zio-telemetry/opentelemetry"}},p={},l=[{value:"Installation",id:"installation",level:2},{value:"Usage",id:"usage",level:2}],c={toc:l},u="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"OpenCensus is a stats collection and distributed tracing framework. Well known implementations are ",(0,a.kt)("a",{parentName:"p",href:"https://www.jaegertracing.io"},"Jaeger"),"\nand ",(0,a.kt)("a",{parentName:"p",href:"https://www.zipkin.io"},"Zipkin"),"."),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("p",null,"First, add the following dependency to your build.sbt:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'"dev.zio" %% "zio-opencensus" % "<version>"\n')),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("p",null,"To use ZIO Telemetry, you will need a ",(0,a.kt)("inlineCode",{parentName:"p"},"Tracing")," service in your environment. You also need to provide a ",(0,a.kt)("inlineCode",{parentName:"p"},"tracer")," implementation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import zio.telemetry.opencensus.Tracing\nimport zio.telemetry.opencensus.implicits._\nimport zio._\nimport io.opencensus.trace.Status\n\nval tracerLayer = ZLayer.succeed(io.opencensus.trace.Tracing.getTracer)\n\nval errorMapper = ErrorMapper[Throwable] { case _ => Status.UNKNOWN }\n\nval app =\n  ZIO.serviceWithZIO[Tracing] { tracing =>\n    import tracing.aspects._\n\n    (for {\n      _       <- tracing.putAttributes(Map("foo" -> "bar"))\n      message <- Console.readline\n    } yield message) @@ root("/app")\n  }.provide(Tracing.live, tracerLayer)\n')),(0,a.kt)("p",null,"After importing ",(0,a.kt)("inlineCode",{parentName:"p"},"import tracing.aspects._"),", additional ",(0,a.kt)("inlineCode",{parentName:"p"},"ZIOAspect")," combinators\non ",(0,a.kt)("inlineCode",{parentName:"p"},"ZIO"),"s are available to support starting child spans and adding attributes."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.serviceWithZIO[Tracing] { tracing =>\n  import tracing.aspects._\n  \n  // start a new root span and set some attributes\n  val zio1 = ZIO.unit @@ root("root span", attributes = ("foo", "bar))\n  // start a child of the current span\n  val zio2 = ZIO.unit @@ span("child span", attributes = Map.empty)\n}\n')),(0,a.kt)("p",null,"To propagate contexts across process boundaries, extraction and injection can be\nused. The current span context is injected into a carrier, which is passed\nthrough some side channel to the next process. There it is injected back and a\nchild span of it is started."),(0,a.kt)("p",null,"Due to the use of the (mutable) OpenCensus carrier APIs, injection and extraction\nare not referentially transparent."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'ZIO.serviceWithZIO[Tracing] { tracing =>\n  import tracing.aspects._\n  \n  val textFormat                           = Tracing.getPropagationComponent().getB3Format()\n  val carrier: mutable.Map[String, String] = mutable.Map().empty\n\n  val getter: TextFormat.Getter[mutable.Map[String, String]] = new TextFormat.Getter[mutable.Map[String, String]] {\n    override def keys(carrier: mutable.Map[String, String]): lang.Iterable[String] =\n      carrier.keys.asJava\n\n    override def get(carrier: mutable.Map[String, String], key: String): String =\n      carrier.get(key).orNull\n  }\n\n  val setter: TextFormat.Setter[mutable.Map[String, String]] = new TextFormat.Setter[mutable.Map[String, String]] {\n    override def put(carrier: mutable.Map[String, String], key: String, value: String): Unit =\n      carrier.update(key, value)\n  }\n  \n  val zio1 = tracing.inject(textFormat, carrier, setter) @@ \n    root("root span", attributes = Map.empty)\n  \n  val zio2 = ZIO.unit @@ \n    span("child span", attributes = Map(("foo", "bar"))) @@ \n    fromRootSpan(textFormat, carrier, getter, "foo", attributes = Map.empty)\n}\n')))}m.isMDXComponent=!0}}]);