"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[4690],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>f});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(t),u=r,f=d["".concat(l,".").concat(u)]||d[u]||m[u]||o;return t?a.createElement(f,i(i({ref:n},c),{},{components:t})):a.createElement(f,i({ref:n},c))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},18296:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=t(87462),r=(t(67294),t(3905));const o={id:"manual-instances",title:"Manual Instances"},i=void 0,s={unversionedId:"zio-json/manual-instances",id:"zio-json/manual-instances",title:"Manual Instances",description:"Sometimes it is easier to reuse an existing JsonDecoder rather than generate a new one. This can be accomplished using convenience methods on the JsonDecoder typeclass to derive new decoders:",source:"@site/docs/zio-json/manual-instances.md",sourceDirName:"zio-json",slug:"/zio-json/manual-instances",permalink:"/zio-json/manual-instances",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-json/manual-instances.md",tags:[],version:"current",frontMatter:{id:"manual-instances",title:"Manual Instances"},sidebar:"ecosystem-sidebar",previous:{title:"Configuration",permalink:"/zio-json/configuration"},next:{title:"Performance",permalink:"/zio-json/performance"}},l={},p=[{value:"<code>.map</code>",id:"map",level:3},{value:"<code>.mapOrFail</code>",id:"maporfail",level:3}],c={toc:p},d="wrapper";function m(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Sometimes it is easier to reuse an existing ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonDecoder")," rather than generate a new one. This can be accomplished using convenience methods on the ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonDecoder")," typeclass to ",(0,r.kt)("em",{parentName:"p"},"derive")," new decoders:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait JsonDecoder[A] {\n  def map[B](f: A => B): JsonDecoder[B]\n  def mapOrFail[B](f: A => Either[String, B]): JsonDecoder[B]\n  ...\n}\n")),(0,r.kt)("p",null,"Similarly, we can reuse an existing ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonEncoder")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"trait JsonEncoder[A] {\n  def contramap[B](f: B => A): JsonEncoder[B]\n  ...\n}\n")),(0,r.kt)("h3",{id:"map"},(0,r.kt)("inlineCode",{parentName:"h3"},".map")),(0,r.kt)("p",null,"We can ",(0,r.kt)("inlineCode",{parentName:"p"},".map")," from another ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonDecoder")," in cases where the conversion will always succeed. This is very useful if we have a ",(0,r.kt)("inlineCode",{parentName:"p"},"case class")," that simply wraps another thing and shares the same expected JSON."),(0,r.kt)("p",null,"For example, say we want to model the count of fruit with a ",(0,r.kt)("inlineCode",{parentName:"p"},"case class")," to provide us with additional type safety in our business logic (this pattern is known as a ",(0,r.kt)("em",{parentName:"p"},"newtype"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class FruitCount(value: Int)\n")),(0,r.kt)("p",null,"but this would cause us to expect JSON of the form"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"value":1}\n')),(0,r.kt)("p",null,"wheres we really expect the raw number. We can derive a decoder from ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonDecoder[Int]")," and ",(0,r.kt)("inlineCode",{parentName:"p"},".map")," the result into a ",(0,r.kt)("inlineCode",{parentName:"p"},"FruitCount")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"object FruitCount {\n  implicit val decoder: JsonDecoder[FruitCount] = JsonDecoder[Int].map(FruitCount(_))\n}\n")),(0,r.kt)("p",null,"and now the ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonDecoder")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"FruitCount")," just expects a raw ",(0,r.kt)("inlineCode",{parentName:"p"},"Int"),"."),(0,r.kt)("p",null,"Every time we use a ",(0,r.kt)("inlineCode",{parentName:"p"},".map")," to create a ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonDecoder")," we can usually create a ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonEncoder")," with ",(0,r.kt)("inlineCode",{parentName:"p"},".contramap")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"object FruitCount {\n  ...\n  implicit val encoder: JsonEncoder[FruitCount] = JsonEncoder[Int].contramap(_.value)\n}\n")),(0,r.kt)("p",null,"Another use case is if we want to encode a ",(0,r.kt)("inlineCode",{parentName:"p"},"case class")," as an array of values, rather than an object with named fields. Such an encoding is very efficient because the messages are smaller and require less processing, but are very strict schemas that cannot be upgraded."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Things(s: String, i: Int, b: Boolean)\nobject Things {\n  implicit val decoder: JsonDecoder[Things] =\n    JsonDecoder[(String, Int, Boolean)].map { case (p1, p2, p3) => Things(p1, p2, p3) }\n}\n")),(0,r.kt)("p",null,"which parses the following JSON"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'["hello",1,true]\n')),(0,r.kt)("h3",{id:"maporfail"},(0,r.kt)("inlineCode",{parentName:"h3"},".mapOrFail")),(0,r.kt)("p",null,"We can use ",(0,r.kt)("inlineCode",{parentName:"p"},".mapOrFail")," to take the result of another ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonDecoder")," and try to convert it into our custom data type, failing with a message if there is an error."),(0,r.kt)("p",null,"Say we are using the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/fthomas/refined"},(0,r.kt)("inlineCode",{parentName:"a"},"refined"))," library to ensure that a ",(0,r.kt)("inlineCode",{parentName:"p"},"Person")," data type only holds a non-empty string in its ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," field"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.json._\nimport zio.json.interop.refined._\n\nimport eu.timepit.refined.api.Refined\nimport eu.timepit.refined.collection.NonEmpty\n\ncase class Person(name: String Refined NonEmpty)\n\nobject Person {\n  implicit val decoder: JsonDecoder[Person] = DeriveJsonDecoder.gen\n}\n")),(0,r.kt)("p",null,"we will get a compiletime error because there is no ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonDecoder[String Refined NonEmpty]"),"."),(0,r.kt)("p",null,"However, we can derive one by requesting the ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonDecoder[String]")," and calling ",(0,r.kt)("inlineCode",{parentName:"p"},".mapOrFail"),", supplying the constructor for our special ",(0,r.kt)("inlineCode",{parentName:"p"},"String Refined NonEmpty")," type"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"implicit val decodeName: JsonDecoder[String Refined NonEmpty] =\n  JsonDecoder[String].mapOrFail(refined.refineV[NonEmpty](_))\n")),(0,r.kt)("p",null,"Now the code compiles."),(0,r.kt)("p",null,"In fact, we do not need to provide ",(0,r.kt)("inlineCode",{parentName:"p"},"decodeName")," for each ",(0,r.kt)("inlineCode",{parentName:"p"},"Refined")," data type; ",(0,r.kt)("inlineCode",{parentName:"p"},"zio-json")," comes with support out of the box, see the Integrations section below."))}m.isMDXComponent=!0}}]);