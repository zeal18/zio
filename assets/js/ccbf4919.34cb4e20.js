"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[64929],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>f});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(r),h=a,f=d["".concat(s,".").concat(h)]||d[h]||u[h]||o;return r?n.createElement(f,l(l({ref:t},p),{},{components:r})):n.createElement(f,l({ref:t},p))}));function f(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,l=new Array(o);l[0]=h;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[d]="string"==typeof e?e:a,l[1]=i;for(var c=2;c<o;c++)l[c]=r[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},32381:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var n=r(87462),a=(r(67294),r(3905));const o={id:"handling-errors",title:"Handling Errors"},l=void 0,i={unversionedId:"overview/handling-errors",id:"overview/handling-errors",title:"Handling Errors",description:"ZIO effects may fail due to foreseen or unforeseen problems. In order to help you build robust applications, ZIO tracks foreseen errors at compile-time, letting you know which effects can fail, and how they can fail. For non-recoverable problems, ZIO gives you full insight into the cause of failures (even if unexpected or catastrophic), preserving all information and automatically logging unhandled errors.",source:"@site/docs/overview/handling-errors.md",sourceDirName:"overview",slug:"/overview/handling-errors",permalink:"/overview/handling-errors",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/overview/handling-errors.md",tags:[],version:"current",frontMatter:{id:"handling-errors",title:"Handling Errors"},sidebar:"overview_sidebar",previous:{title:"Basic Operations",permalink:"/overview/basic-operations"},next:{title:"Handling Resources",permalink:"/overview/handling-resources"}},s={},c=[{value:"Either",id:"either",level:2},{value:"Catching All Errors",id:"catching-all-errors",level:2},{value:"Catching Some Errors",id:"catching-some-errors",level:2},{value:"Fallback",id:"fallback",level:2},{value:"Folding",id:"folding",level:2},{value:"Retrying",id:"retrying",level:2},{value:"Next Steps",id:"next-steps",level:2}],p={toc:c},d="wrapper";function u(e){let{components:t,...r}=e;return(0,a.kt)(d,(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"ZIO effects may fail due to foreseen or unforeseen problems. In order to help you build robust applications, ZIO tracks foreseen errors at compile-time, letting you know which effects can fail, and how they can fail. For non-recoverable problems, ZIO gives you full insight into the cause of failures (even if unexpected or catastrophic), preserving all information and automatically logging unhandled errors."),(0,a.kt)("p",null,"In this section, you will learn about some of the tools ZIO gives you to build applications with robust error management."),(0,a.kt)("h2",{id:"either"},"Either"),(0,a.kt)("p",null,"With the ",(0,a.kt)("inlineCode",{parentName:"p"},"ZIO#either")," method, you can transform an effect that fails into an infallible effect that places both failure and success into Scala's ",(0,a.kt)("inlineCode",{parentName:"p"},"Either")," type. This brings the error from the error channel to the success channel, which is useful because many ZIO operators work on the success channel, not the error channel."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'val zeither: ZIO[Any, Nothing, Either[String, Nothing]] = \n  ZIO.fail("Uh oh!").either\n')),(0,a.kt)("h2",{id:"catching-all-errors"},"Catching All Errors"),(0,a.kt)("p",null,"If you want to catch and recover from all types of recoverable errors and effectfully attempt recovery, then you can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"catchAll")," method, which lets you specify an error handler that returns the effect to execute in the event of an error:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'val z: ZIO[Any, IOException, Array[Byte]] = \n  openFile("primary.json").catchAll { error => \n    for {\n      _    <- ZIO.logErrorCause("Could not open primary file", Cause.fail(error))\n      file <- openFile("backup.json")\n    } yield file \n  }\n')),(0,a.kt)("p",null,"In the error handler passed to ",(0,a.kt)("inlineCode",{parentName:"p"},"catchAll"),", you may return an effect with a ",(0,a.kt)("em",{parentName:"p"},"different")," error type (perhaps ",(0,a.kt)("inlineCode",{parentName:"p"},"Nothing"),", if the error handler cannot fail), which is then reflected in the type of effect returned by ",(0,a.kt)("inlineCode",{parentName:"p"},"catchAll"),"."),(0,a.kt)("h2",{id:"catching-some-errors"},"Catching Some Errors"),(0,a.kt)("p",null,"If you want to catch and recover from only some types of recoverable errors and effectfully attempt recovery, then you can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"catchSome")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'val data: ZIO[Any, IOException, Array[Byte]] = \n  openFile("primary.data").catchSome {\n    case _ : FileNotFoundException => \n      openFile("backup.data")\n  }\n')),(0,a.kt)("p",null,"Unlike ",(0,a.kt)("inlineCode",{parentName:"p"},"catchAll"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"catchSome")," cannot reduce or eliminate the error type, although it can widen the error type to a broader class of errors."),(0,a.kt)("h2",{id:"fallback"},"Fallback"),(0,a.kt)("p",null,"You can try one effect or if it fails, try another effect with the ",(0,a.kt)("inlineCode",{parentName:"p"},"orElse")," combinator:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'val primaryOrBackupData: ZIO[Any, IOException, Array[Byte]] = \n  openFile("primary.data").orElse(openFile("backup.data"))\n')),(0,a.kt)("h2",{id:"folding"},"Folding"),(0,a.kt)("p",null,"In the Scala standard library, the data types ",(0,a.kt)("inlineCode",{parentName:"p"},"Option")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Either")," have a ",(0,a.kt)("inlineCode",{parentName:"p"},"fold")," method, which lets you handle both failure and success cases at the same time."),(0,a.kt)("p",null,"In a similar fashion, ",(0,a.kt)("inlineCode",{parentName:"p"},"ZIO")," effects also have several methods that allow you to handle both failure and success at the same time."),(0,a.kt)("p",null,"The first fold method, ",(0,a.kt)("inlineCode",{parentName:"p"},"fold"),", lets you separately convert both failure and success into some common type:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val DefaultData: Array[Byte] = Array(0, 0)\n\nval primaryOrDefaultData: ZIO[Any, Nothing, Array[Byte]] = \n  openFile("primary.data").fold(\n    _    => DefaultData, // Failure case\n    data => data)        // Success case\n')),(0,a.kt)("p",null,"The second fold method, ",(0,a.kt)("inlineCode",{parentName:"p"},"foldZIO"),", lets you separately handle both failure and success by specifying effects that will be executed in each respective case:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'val primaryOrSecondaryData: ZIO[Any, IOException, Array[Byte]] = \n  openFile("primary.data").foldZIO(\n    _    => openFile("secondary.data"), // Error handler\n    data => ZIO.succeed(data))          // Success handler\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"foldZIO")," method is almost the most powerful error recovery method in ZIO, with only ",(0,a.kt)("inlineCode",{parentName:"p"},"foldCauseZIO")," being more powerful. Most other operators, such as ",(0,a.kt)("inlineCode",{parentName:"p"},"either")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"orElse"),", are implemented in terms of these powerful methods."),(0,a.kt)("p",null,"In the following additional example, ",(0,a.kt)("inlineCode",{parentName:"p"},"foldZIO")," is used to handle both the failure and the success of the ",(0,a.kt)("inlineCode",{parentName:"p"},"readUrls")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'val urls: ZIO[Any, Nothing, Content] =\n  readUrls("urls.json").foldZIO(\n    error   => ZIO.succeed(Content.NoContent(error)), \n    success => fetchContent(success)\n  )\n')),(0,a.kt)("h2",{id:"retrying"},"Retrying"),(0,a.kt)("p",null,"In order to deal with transient errors, which are the norm when interacting with external cloud systems, ZIO provides very powerful retry mechanisms."),(0,a.kt)("p",null,"One of these mechanisms is the ",(0,a.kt)("inlineCode",{parentName:"p"},"ZIO#retry")," method, which takes a ",(0,a.kt)("inlineCode",{parentName:"p"},"Schedule"),", and returns a new effect that will retry the original effect if it fails, according to the specified schedule:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'val retriedOpenFile: ZIO[Any, IOException, Array[Byte]] = \n  openFile("primary.data")\n      .retry(Schedule.recurs(5))\n')),(0,a.kt)("p",null,"The next most powerful function is ",(0,a.kt)("inlineCode",{parentName:"p"},"ZIO#retryOrElse"),", which allows specification of a fallback to use if the effect does not succeed with the specified policy:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'val retryOpenFile: ZIO[Any, IOException, DefaultData) = \n  openFile("primary.data")\n      .retryOrElse(Schedule.recurs(5), (_, _) => ZIO.succeed(DefaultData))\n')),(0,a.kt)("p",null,"For more information on how to build schedules, see the documentation on ",(0,a.kt)("a",{parentName:"p",href:"/reference/schedule/"},"Schedule"),"."),(0,a.kt)("h2",{id:"next-steps"},"Next Steps"),(0,a.kt)("p",null,"If you are comfortable with basic error handling, including applying simple retry logic to effects, the next step is to learn about safe ",(0,a.kt)("a",{parentName:"p",href:"/overview/handling-resources"},"resource handling"),"."))}u.isMDXComponent=!0}}]);