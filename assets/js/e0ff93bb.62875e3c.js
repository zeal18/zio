"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[64260],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,k=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(k,l(l({ref:t},p),{},{components:n})):a.createElement(k,l({ref:t},p))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=m;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[d]="string"==typeof e?e:i,l[1]=r;for(var c=2;c<o;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},14335:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var a=n(87462),i=(n(67294),n(3905));const o={id:"contexts",title:"Contexts"},l=void 0,r={unversionedId:"zio-quill/contexts",id:"zio-quill/contexts",title:"Contexts",description:"Contexts represent the database and provide an execution interface for queries.",source:"@site/docs/zio-quill/contexts.md",sourceDirName:"zio-quill",slug:"/zio-quill/contexts",permalink:"/zio-quill/contexts",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-quill/contexts.md",tags:[],version:"current",frontMatter:{id:"contexts",title:"Contexts"},sidebar:"ecosystem-sidebar",previous:{title:"Extending Quill",permalink:"/zio-quill/extending-quill"},next:{title:"Code Generation",permalink:"/zio-quill/code-generation"}},s={},c=[{value:"Mirror context",id:"mirror-context",level:2},{value:"Dependent contexts",id:"dependent-contexts",level:2},{value:"Context Traits",id:"context-traits",level:3},{value:"Modular Contexts",id:"modular-contexts",level:3},{value:"Use <code>ModularContext</code> in a mirror context:",id:"use-modularcontext-in-a-mirror-context",level:4},{value:"Use <code>ModularContext</code> to query a Postgres Database",id:"use-modularcontext-to-query-a-postgres-database",level:4},{value:"Use <code>ModularContext</code> to query a Spark Dataset",id:"use-modularcontext-to-query-a-spark-dataset",level:4},{value:"Spark Integration",id:"spark-integration",level:2},{value:"Importing Quill Spark",id:"importing-quill-spark",level:3},{value:"Usage",id:"usage",level:3},{value:"Using Quill-Spark",id:"using-quill-spark",level:3},{value:"Simplify it",id:"simplify-it",level:4},{value:"Workflow",id:"workflow",level:4},{value:"Custom Functions",id:"custom-functions",level:3},{value:"Restrictions",id:"restrictions",level:3},{value:"Top Level Classes",id:"top-level-classes",level:4},{value:"Lifted Variable Interpolation",id:"lifted-variable-interpolation",level:4},{value:"SQL Contexts",id:"sql-contexts",level:2},{value:"Dialect",id:"dialect",level:3},{value:"Naming strategy",id:"naming-strategy",level:3},{value:"Configuration",id:"configuration",level:3},{value:"quill-jdbc",id:"quill-jdbc",level:2},{value:"transactions",id:"transactions",level:4},{value:"MySQL (quill-jdbc)",id:"mysql-quill-jdbc",level:3},{value:"sbt dependencies",id:"sbt-dependencies",level:4},{value:"context definition",id:"context-definition",level:4},{value:"application.properties",id:"applicationproperties",level:4},{value:"Postgres (quill-jdbc)",id:"postgres-quill-jdbc",level:3},{value:"sbt dependencies",id:"sbt-dependencies-1",level:4},{value:"context definition",id:"context-definition-1",level:4},{value:"application.properties",id:"applicationproperties-1",level:4},{value:"Sqlite (quill-jdbc)",id:"sqlite-quill-jdbc",level:3},{value:"sbt dependencies",id:"sbt-dependencies-2",level:4},{value:"context definition",id:"context-definition-2",level:4},{value:"application.properties",id:"applicationproperties-2",level:4},{value:"H2 (quill-jdbc)",id:"h2-quill-jdbc",level:3},{value:"sbt dependencies",id:"sbt-dependencies-3",level:4},{value:"context definition",id:"context-definition-3",level:4},{value:"application.properties",id:"applicationproperties-3",level:4},{value:"SQL Server (quill-jdbc)",id:"sql-server-quill-jdbc",level:3},{value:"sbt dependencies",id:"sbt-dependencies-4",level:4},{value:"context definition",id:"context-definition-4",level:4},{value:"Oracle (quill-jdbc)",id:"oracle-quill-jdbc",level:3},{value:"sbt dependencies",id:"sbt-dependencies-5",level:4},{value:"context definition",id:"context-definition-5",level:4},{value:"application.properties",id:"applicationproperties-4",level:4},{value:"ZIO (quill-jdbc-zio)",id:"zio-quill-jdbc-zio",level:2},{value:"DAO helper",id:"dao-helper",level:4},{value:"streaming",id:"streaming",level:4},{value:"transactions",id:"transactions-1",level:4},{value:"json",id:"json",level:4},{value:"MySQL (quill-jdbc-zio)",id:"mysql-quill-jdbc-zio",level:3},{value:"sbt dependencies",id:"sbt-dependencies-6",level:4},{value:"context definition",id:"context-definition-6",level:4},{value:"application.properties",id:"applicationproperties-5",level:4},{value:"Postgres (quill-jdbc-zio)",id:"postgres-quill-jdbc-zio",level:3},{value:"sbt dependencies",id:"sbt-dependencies-7",level:4},{value:"context definition",id:"context-definition-7",level:4},{value:"application.properties",id:"applicationproperties-6",level:4},{value:"Sqlite (quill-jdbc-zio)",id:"sqlite-quill-jdbc-zio",level:3},{value:"sbt dependencies",id:"sbt-dependencies-8",level:4},{value:"context definition",id:"context-definition-8",level:4},{value:"application.properties",id:"applicationproperties-7",level:4},{value:"H2 (quill-jdbc-zio)",id:"h2-quill-jdbc-zio",level:3},{value:"sbt dependencies",id:"sbt-dependencies-9",level:4},{value:"context definition",id:"context-definition-9",level:4},{value:"application.properties",id:"applicationproperties-8",level:4},{value:"SQL Server (quill-jdbc-zio)",id:"sql-server-quill-jdbc-zio",level:3},{value:"sbt dependencies",id:"sbt-dependencies-10",level:4},{value:"context definition",id:"context-definition-10",level:4},{value:"application.properties",id:"applicationproperties-9",level:4},{value:"Oracle (quill-jdbc-zio)",id:"oracle-quill-jdbc-zio",level:3},{value:"sbt dependencies",id:"sbt-dependencies-11",level:4},{value:"context definition",id:"context-definition-11",level:4},{value:"application.properties",id:"applicationproperties-10",level:4},{value:"quill-jdbc-monix",id:"quill-jdbc-monix",level:2},{value:"streaming",id:"streaming-1",level:4},{value:"transactions",id:"transactions-2",level:4},{value:"runners",id:"runners",level:4},{value:"MySQL (quill-jdbc-monix)",id:"mysql-quill-jdbc-monix",level:3},{value:"sbt dependencies",id:"sbt-dependencies-12",level:4},{value:"context definition",id:"context-definition-12",level:4},{value:"application.properties",id:"applicationproperties-11",level:4},{value:"Postgres (quill-jdbc-monix)",id:"postgres-quill-jdbc-monix",level:3},{value:"sbt dependencies",id:"sbt-dependencies-13",level:4},{value:"context definition",id:"context-definition-13",level:4},{value:"application.properties",id:"applicationproperties-12",level:4},{value:"Sqlite (quill-jdbc-monix)",id:"sqlite-quill-jdbc-monix",level:3},{value:"sbt dependencies",id:"sbt-dependencies-14",level:4},{value:"context definition",id:"context-definition-14",level:4},{value:"application.properties",id:"applicationproperties-13",level:4},{value:"H2 (quill-jdbc-monix)",id:"h2-quill-jdbc-monix",level:3},{value:"sbt dependencies",id:"sbt-dependencies-15",level:4},{value:"context definition",id:"context-definition-15",level:4},{value:"application.properties",id:"applicationproperties-14",level:4},{value:"SQL Server (quill-jdbc-monix)",id:"sql-server-quill-jdbc-monix",level:3},{value:"sbt dependencies",id:"sbt-dependencies-16",level:4},{value:"context definition",id:"context-definition-16",level:4},{value:"application.properties",id:"applicationproperties-15",level:4},{value:"Oracle (quill-jdbc-monix)",id:"oracle-quill-jdbc-monix",level:3},{value:"sbt dependencies",id:"sbt-dependencies-17",level:4},{value:"context definition",id:"context-definition-17",level:4},{value:"application.properties",id:"applicationproperties-16",level:4},{value:"NDBC Context",id:"ndbc-context",level:2},{value:"quill-ndbc-postgres",id:"quill-ndbc-postgres",level:3},{value:"transactions",id:"transactions-3",level:4},{value:"sbt dependencies",id:"sbt-dependencies-18",level:4},{value:"context definition",id:"context-definition-18",level:4},{value:"application.properties",id:"applicationproperties-17",level:4},{value:"quill-async",id:"quill-async",level:2},{value:"transactions",id:"transactions-4",level:4},{value:"application.properties",id:"applicationproperties-18",level:4},{value:"connection configuration",id:"connection-configuration",level:5},{value:"connection pool configuration",id:"connection-pool-configuration",level:5},{value:"SSL configuration",id:"ssl-configuration",level:5},{value:"other",id:"other",level:5},{value:"quill-async-mysql",id:"quill-async-mysql",level:3},{value:"sbt dependencies",id:"sbt-dependencies-19",level:4},{value:"context definition",id:"context-definition-19",level:4},{value:"application.properties",id:"applicationproperties-19",level:4},{value:"quill-async-postgres",id:"quill-async-postgres",level:3},{value:"sbt dependencies",id:"sbt-dependencies-20",level:4},{value:"context definition",id:"context-definition-20",level:4},{value:"application.properties",id:"applicationproperties-20",level:4},{value:"quill-jasync",id:"quill-jasync",level:2},{value:"transactions",id:"transactions-5",level:4},{value:"application.properties",id:"applicationproperties-21",level:4},{value:"connection configuration",id:"connection-configuration-1",level:5},{value:"SSL configuration",id:"ssl-configuration-1",level:5},{value:"quill-jasync-mysql",id:"quill-jasync-mysql",level:3},{value:"sbt dependencies",id:"sbt-dependencies-21",level:4},{value:"context definition",id:"context-definition-21",level:4},{value:"application.properties",id:"applicationproperties-22",level:4},{value:"quill-jasync-postgres",id:"quill-jasync-postgres",level:3},{value:"sbt dependencies",id:"sbt-dependencies-22",level:4},{value:"context definition",id:"context-definition-22",level:4},{value:"application.properties",id:"applicationproperties-23",level:4},{value:"quill-jasync-zio",id:"quill-jasync-zio",level:2},{value:"connection configuration",id:"connection-configuration-2",level:5},{value:"SSL configuration",id:"ssl-configuration-2",level:5},{value:"quill-jasync-zio-postgres",id:"quill-jasync-zio-postgres",level:3},{value:"sbt dependencies",id:"sbt-dependencies-23",level:4},{value:"context definition",id:"context-definition-23",level:4},{value:"application.properties",id:"applicationproperties-24",level:4},{value:"quill-doobie",id:"quill-doobie",level:2},{value:"running and streaming",id:"running-and-streaming",level:4},{value:"actions",id:"actions",level:4},{value:"Finagle Contexts",id:"finagle-contexts",level:2},{value:"quill-finagle-mysql",id:"quill-finagle-mysql",level:3},{value:"transactions",id:"transactions-6",level:4},{value:"streaming",id:"streaming-2",level:4},{value:"sbt dependencies",id:"sbt-dependencies-24",level:4},{value:"context definition",id:"context-definition-24",level:4},{value:"application.properties",id:"applicationproperties-25",level:4},{value:"quill-finagle-postgres",id:"quill-finagle-postgres",level:3},{value:"transactions",id:"transactions-7",level:4},{value:"sbt dependencies",id:"sbt-dependencies-25",level:4},{value:"context definition",id:"context-definition-25",level:4},{value:"application.properties",id:"applicationproperties-26",level:4},{value:"quill-cassandra",id:"quill-cassandra",level:2},{value:"sbt dependencies",id:"sbt-dependencies-26",level:4},{value:"synchronous context",id:"synchronous-context",level:4},{value:"asynchronous context",id:"asynchronous-context",level:4},{value:"application.properties",id:"applicationproperties-27",level:4},{value:"quill-cassandra-zio",id:"quill-cassandra-zio",level:2},{value:"DAO helper",id:"dao-helper-1",level:4},{value:"sbt dependencies",id:"sbt-dependencies-27",level:4},{value:"quill-cassandra-monix",id:"quill-cassandra-monix",level:2},{value:"sbt dependencies",id:"sbt-dependencies-28",level:4},{value:"monix context",id:"monix-context",level:4},{value:"stream context",id:"stream-context",level:4},{value:"quill-cassandra-alpakka",id:"quill-cassandra-alpakka",level:2},{value:"sbt dependencies",id:"sbt-dependencies-29",level:4},{value:"context",id:"context",level:4},{value:"application.properties",id:"applicationproperties-28",level:4},{value:"OrientDB Contexts",id:"orientdb-contexts",level:2},{value:"sbt dependencies",id:"sbt-dependencies-30",level:4},{value:"synchronous context",id:"synchronous-context-1",level:4},{value:"application.properties",id:"applicationproperties-29",level:4}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Contexts represent the database and provide an execution interface for queries."),(0,i.kt)("h2",{id:"mirror-context"},"Mirror context"),(0,i.kt)("p",null,"Quill provides a mirror context for testing purposes. Instead of running the query, the mirror context returns a structure with the information that would be used to run the query. There are three mirror context instances:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"io.getquill.MirrorContext"),": Mirrors the quotation AST"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"io.getquill.SqlMirrorContext"),": Mirrors the SQL query"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"io.getquill.CassandraMirrorContext"),": Mirrors the CQL query")),(0,i.kt)("h2",{id:"dependent-contexts"},"Dependent contexts"),(0,i.kt)("p",null,"The context instance provides all methods and types to interact with quotations and the database.\nContexts can be imported and passed around normally in constructors and function arguments."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'class MyContext extends SqlMirrorContext(MirrorSqlDialect, Literal)\ncase class MySchema(c: MyContext) {\n  import c._\n  val people = quote {\n    querySchema[Person]("people")\n  }\n}\ncase class MyDao(c: MyContext, schema: MySchema) {\n  def allPeople = c.run(schema.people)\n}\n')),(0,i.kt)("h3",{id:"context-traits"},"Context Traits"),(0,i.kt)("p",null,"One way to compose applications with this kind of context is to use traits with an abstract context variable:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'class MyContext extends SqlMirrorContext(MirrorSqlDialect, Literal)\n\ntrait MySchema {\n\n  val c: MyContext\n  import c._\n\n  val people = quote {\n    querySchema[Person]("people")\n  }\n}\n\ncase class MyDao(c: MyContext) extends MySchema {\n  import c._\n\n  def allPeople =\n    c.run(people)\n}\n')),(0,i.kt)("h3",{id:"modular-contexts"},"Modular Contexts"),(0,i.kt)("p",null,"Another simple way to modularize Quill code is by extending ",(0,i.kt)("inlineCode",{parentName:"p"},"Context")," as a self-type and applying mixins. Using this strategy,\nit is possible to create functionality that is fully portable across databases and even different types of databases\n(e.g. creating common queries for both Postgres and Spark)."),(0,i.kt)("p",null,"For example, create the following abstract context:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait ModularContext[I <: Idiom, N <: NamingStrategy] { this: Context[I, N] =>\n  def peopleOlderThan = quote {\n    (age:Int, q:Query[Person]) => q.filter(p => p.age > age)\n  }\n}\n")),(0,i.kt)("p",null,"Let's see how this can be used across different kinds of databases and Quill contexts."),(0,i.kt)("h4",{id:"use-modularcontext-in-a-mirror-context"},"Use ",(0,i.kt)("inlineCode",{parentName:"h4"},"ModularContext")," in a mirror context:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// Note: In some cases need to explicitly specify [MirrorSqlDialect, Literal].\nval ctx =\n  new SqlMirrorContext[MirrorSqlDialect, Literal](MirrorSqlDialect, Literal)\n    with ModularContext[MirrorSqlDialect, Literal]\n\nimport ctx._\nprintln( run(peopleOlderThan(22, query[Person])).string )\n")),(0,i.kt)("h4",{id:"use-modularcontext-to-query-a-postgres-database"},"Use ",(0,i.kt)("inlineCode",{parentName:"h4"},"ModularContext")," to query a Postgres Database"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val ctx =\n  new PostgresJdbcContext[Literal](Literal, ds)\n    with ModularContext[PostgresDialect, Literal]\n\nimport ctx._\nval results = run(peopleOlderThan(22, query[Person]))\n")),(0,i.kt)("h4",{id:"use-modularcontext-to-query-a-spark-dataset"},"Use ",(0,i.kt)("inlineCode",{parentName:"h4"},"ModularContext")," to query a Spark Dataset"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object CustomQuillSparkContext extends QuillSparkContext\n  with ModularContext[SparkDialect, Literal]\n\nval results = run(peopleOlderThan(22, liftQuery(dataset)))\n")),(0,i.kt)("h2",{id:"spark-integration"},"Spark Integration"),(0,i.kt)("p",null,"Quill provides a fully type-safe way to use Spark's highly-optimized SQL engine. It's an alternative to ",(0,i.kt)("inlineCode",{parentName:"p"},"Dataset"),"'s weakly-typed API."),(0,i.kt)("h3",{id:"importing-quill-spark"},"Importing Quill Spark"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "io.getquill" %% "quill-spark" % "4.6.1"\n)\n')),(0,i.kt)("h3",{id:"usage"},"Usage"),(0,i.kt)("p",null,"Unlike the other modules, the Spark context is a companion object. Also, it does not depend on a spark session. To use it, add the following import:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import org.apache.spark.sql.SparkSession\n\n// Create your Spark Context\nval session =\n  SparkSession.builder()\n    .master("local")\n    .appName("spark test")\n    .getOrCreate()\n\n// The Spark SQL Context must be provided by the user through an implicit value:\nimplicit val sqlContext = session.sqlContext\nimport sqlContext.implicits._      // Also needed...\n\n// Import the Quill Spark Context\nimport io.getquill.QuillSparkContext._\n')),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note Unlike the other modules, the Spark context is a companion object. Also, it does not depend on a spark session.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Also Note: Quill decoders and meta instances are not used by the quill-spark module, Spark's ",(0,i.kt)("inlineCode",{parentName:"p"},"Encoder"),"s are used instead.")),(0,i.kt)("h3",{id:"using-quill-spark"},"Using Quill-Spark"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," method returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"Dataset")," transformed by the Quill query using the SQL engine."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// Typically you start with some type dataset.\nval peopleDS: Dataset[Person] = spark.read.parquet("path/to/people").as[Person]\nval addressesDS: Dataset[Address] = spark.read.parquet("path/to/addresses").as[Address]\n\n// The liftQuery method converts Datasets to Quill queries:\nval people = quote { liftQuery(peopleDS) }\nval addresses = quote { liftQuery(addressesDS) }\n\nval peopleAndAddresses = quote {\n  (people join addresses).on((p, a) => p.id == a.ownerFk)\n}\n\nval peopleAndAddressesDS: Dataset[(Person, Address)] = run(peopleAndAddresses)\n')),(0,i.kt)("h4",{id:"simplify-it"},"Simplify it"),(0,i.kt)("p",null,"Since the ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," method allows for Quill queries to be specified directly, and ",(0,i.kt)("inlineCode",{parentName:"p"},"liftQuery")," can be used inside\nof any Quoted block, you can shorten various steps of the above workflow:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val peopleDS: Dataset[Person] = spark.read.parquet("path/to/people")\nval addressesDS: Dataset[Address] = spark.read.parquet("path/to/addresses")\n\nval peopleAndAddressesDS: Dataset[(Person, Address)] = run {\n  liftQuery(peopleDS)\n    .join(liftQuery(addressesDS))\n    .on((p, a) => p.id == a.ownerFk)\n}\n')),(0,i.kt)("p",null,"Here is an example of a Dataset being converted into Quill, filtered, and then written back out."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import org.apache.spark.sql.Dataset\n\ndef filter(myDataset: Dataset[Person], name: String): Dataset[Int] =\n  run {\n    liftQuery(myDataset).filter(_.name == lift(name)).map(_.age)\n  }\n// SELECT x1.age _1 FROM (?) x1 WHERE x1.name = ?\n")),(0,i.kt)("h4",{id:"workflow"},"Workflow"),(0,i.kt)("p",null,"Due to the design of Quill-Spark, it can be used interchangeably throughout your Spark workflow:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Lift a Dataset to Query to do some filtering and sub-selecting\n(with ",(0,i.kt)("a",{parentName:"li",href:"https://jaceklaskowski.gitbooks.io/mastering-spark-sql/spark-sql-Optimizer-PushDownPredicate.html"},"Predicate and Filter Pushdown!"),")."),(0,i.kt)("li",{parentName:"ul"},"Then covert it back to a Dataset to do Spark-Specific operations."),(0,i.kt)("li",{parentName:"ul"},"Then convert it back to a Query to use Quills great Join DSL..."),(0,i.kt)("li",{parentName:"ul"},"Then convert it back to a Dataset to write it to a file or do something else with it...")),(0,i.kt)("h3",{id:"custom-functions"},"Custom Functions"),(0,i.kt)("p",null,"TODO UDFs and UDAFs"),(0,i.kt)("h3",{id:"restrictions"},"Restrictions"),(0,i.kt)("h4",{id:"top-level-classes"},"Top Level Classes"),(0,i.kt)("p",null,"Spark only supports using top-level classes as record types. That means that\nwhen using ",(0,i.kt)("inlineCode",{parentName:"p"},"quill-spark")," you can only use a top-level case class for ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"Query[T]"),"."),(0,i.kt)("p",null,"TODO Get the specific error"),(0,i.kt)("h4",{id:"lifted-variable-interpolation"},"Lifted Variable Interpolation"),(0,i.kt)("p",null,"The queries printed from ",(0,i.kt)("inlineCode",{parentName:"p"},"run(myQuery)")," during compile time escape question marks via a backslash them in order to\nbe able to substitute liftings properly. They are then returned back to their original form before running."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import org.apache.spark.sql.Dataset\n\ndef filter(myDataset: Dataset[Person]): Dataset[Int] =\n  run {\n    liftQuery(myDataset).filter(_.name == \"?\").map(_.age)\n  }\n// This is generated during compile time:\n// SELECT x1.age _1 FROM (?) x1 WHERE x1.name = '\\?'\n// It is reverted upon run-time:\n// SELECT x1.age _1 FROM (ds1) x1 WHERE x1.name = '?'\n")),(0,i.kt)("h2",{id:"sql-contexts"},"SQL Contexts"),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new MysqlJdbcContext(SnakeCase, "ctx")\n')),(0,i.kt)("h3",{id:"dialect"},"Dialect"),(0,i.kt)("p",null,"The SQL dialect parameter defines the specific database dialect to be used. Some context types are specific to a database and thus not require it."),(0,i.kt)("p",null,"Quill has five built-in dialects:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"io.getquill.H2Dialect")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"io.getquill.MySQLDialect")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"io.getquill.PostgresDialect")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"io.getquill.SqliteDialect")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"io.getquill.SQLServerDialect")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"io.getquill.OracleDialect"))),(0,i.kt)("h3",{id:"naming-strategy"},"Naming strategy"),(0,i.kt)("p",null,"The naming strategy parameter defines the behavior when translating identifiers (table and column names) to SQL."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"strategy"),(0,i.kt)("th",{parentName:"tr",align:null},"example"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"io.getquill.naming.Literal")),(0,i.kt)("td",{parentName:"tr",align:null},"some_ident  -> some_ident")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"io.getquill.naming.Escape")),(0,i.kt)("td",{parentName:"tr",align:null},'some_ident  -> "some_ident"')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"io.getquill.naming.UpperCase")),(0,i.kt)("td",{parentName:"tr",align:null},"some_ident  -> SOME_IDENT")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"io.getquill.naming.LowerCase")),(0,i.kt)("td",{parentName:"tr",align:null},"SOME_IDENT  -> some_ident")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"io.getquill.naming.SnakeCase")),(0,i.kt)("td",{parentName:"tr",align:null},"someIdent   -> some_ident")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"io.getquill.naming.CamelCase")),(0,i.kt)("td",{parentName:"tr",align:null},"some_ident  -> someIdent")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"io.getquill.naming.MysqlEscape")),(0,i.kt)("td",{parentName:"tr",align:null},"some_ident  -> ","`","some_ident","`")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"io.getquill.naming.PostgresEscape")),(0,i.kt)("td",{parentName:"tr",align:null},"$some_ident -> $some_ident")))),(0,i.kt)("p",null,"Multiple transformations can be defined using ",(0,i.kt)("inlineCode",{parentName:"p"},"NamingStrategy()"),". For instance, the naming strategy"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"NamingStrategy(SnakeCase, UpperCase)")),(0,i.kt)("p",null,"produces the following transformation:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"someIdent -> SOME_IDENT")),(0,i.kt)("p",null,"The transformations are applied from left to right."),(0,i.kt)("h3",{id:"configuration"},"Configuration"),(0,i.kt)("p",null,"The string passed to the context is used as the key in order to obtain configurations using the ",(0,i.kt)("a",{parentName:"p",href:"http://github.com/typesafehub/config"},"typesafe config")," library."),(0,i.kt)("p",null,"Additionally, the contexts provide multiple constructors. For instance, with ",(0,i.kt)("inlineCode",{parentName:"p"},"JdbcContext")," it's possible to specify a ",(0,i.kt)("inlineCode",{parentName:"p"},"DataSource")," directly, without using the configuration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def createDataSource: javax.sql.DataSource with java.io.Closeable = ???\n\nlazy val ctx = new MysqlJdbcContext(SnakeCase, createDataSource)\n")),(0,i.kt)("h2",{id:"quill-jdbc"},"quill-jdbc"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"quill-jdbc")," module provides a simple blocking JDBC context for standard use-cases. For transactions, the JDBC connection is kept in a thread-local variable."),(0,i.kt)("p",null,"Quill uses ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/brettwooldridge/HikariCP"},"HikariCP")," for connection pooling. Please refer to HikariCP's ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/brettwooldridge/HikariCP#configuration-knobs-baby"},"documentation")," for a detailed explanation of the available configurations."),(0,i.kt)("p",null,"Note that there are ",(0,i.kt)("inlineCode",{parentName:"p"},"dataSource")," configurations, that go under ",(0,i.kt)("inlineCode",{parentName:"p"},"dataSource"),", like ",(0,i.kt)("inlineCode",{parentName:"p"},"user")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"password"),", but some pool settings may go under the root config, like ",(0,i.kt)("inlineCode",{parentName:"p"},"connectionTimeout"),"."),(0,i.kt)("h4",{id:"transactions"},"transactions"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"JdbcContext")," provides thread-local transaction support:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.transaction {\n  ctx.run(query[Person].delete)\n  // other transactional code\n}\n")),(0,i.kt)("p",null,"The body of ",(0,i.kt)("inlineCode",{parentName:"p"},"transaction")," can contain calls to other methods and multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," calls since the transaction is propagated through a thread-local."),(0,i.kt)("h3",{id:"mysql-quill-jdbc"},"MySQL (quill-jdbc)"),(0,i.kt)("h4",{id:"sbt-dependencies"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "mysql" % "mysql-connector-java" % "8.0.17",\n  "io.getquill" %% "quill-jdbc" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new MysqlJdbcContext(SnakeCase, "ctx")\n')),(0,i.kt)("h4",{id:"applicationproperties"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dataSourceClassName=com.mysql.cj.jdbc.MysqlDataSource\nctx.dataSource.url=jdbc:mysql://host/database\nctx.dataSource.user=root\nctx.dataSource.password=root\nctx.dataSource.cachePrepStmts=true\nctx.dataSource.prepStmtCacheSize=250\nctx.dataSource.prepStmtCacheSqlLimit=2048\nctx.connectionTimeout=30000\n")),(0,i.kt)("h3",{id:"postgres-quill-jdbc"},"Postgres (quill-jdbc)"),(0,i.kt)("h4",{id:"sbt-dependencies-1"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "org.postgresql" % "postgresql" % "42.2.8",\n  "io.getquill" %% "quill-jdbc" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-1"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new PostgresJdbcContext(SnakeCase, "ctx")\n')),(0,i.kt)("h4",{id:"applicationproperties-1"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dataSourceClassName=org.postgresql.ds.PGSimpleDataSource\nctx.dataSource.user=root\nctx.dataSource.password=root\nctx.dataSource.databaseName=database\nctx.dataSource.portNumber=5432\nctx.dataSource.serverName=host\nctx.connectionTimeout=30000\n")),(0,i.kt)("h3",{id:"sqlite-quill-jdbc"},"Sqlite (quill-jdbc)"),(0,i.kt)("h4",{id:"sbt-dependencies-2"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "org.xerial" % "sqlite-jdbc" % "3.28.0",\n  "io.getquill" %% "quill-jdbc" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-2"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new SqliteJdbcContext(SnakeCase, "ctx")\n')),(0,i.kt)("h4",{id:"applicationproperties-2"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.driverClassName=org.sqlite.JDBC\nctx.jdbcUrl=jdbc:sqlite:/path/to/db/file.db\n")),(0,i.kt)("h3",{id:"h2-quill-jdbc"},"H2 (quill-jdbc)"),(0,i.kt)("h4",{id:"sbt-dependencies-3"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "com.h2database" % "h2" % "1.4.199",\n  "io.getquill" %% "quill-jdbc" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-3"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new H2JdbcContext(SnakeCase, "ctx")\n')),(0,i.kt)("h4",{id:"applicationproperties-3"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dataSourceClassName=org.h2.jdbcx.JdbcDataSource\nctx.dataSource.url=jdbc:h2:mem:yourdbname\nctx.dataSource.user=sa\n")),(0,i.kt)("h3",{id:"sql-server-quill-jdbc"},"SQL Server (quill-jdbc)"),(0,i.kt)("h4",{id:"sbt-dependencies-4"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "com.microsoft.sqlserver" % "mssql-jdbc" % "7.4.1.jre8",\n  "io.getquill" %% "quill-jdbc" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-4"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new SqlServerJdbcContext(SnakeCase, "ctx")\n')),(0,i.kt)("h3",{id:"oracle-quill-jdbc"},"Oracle (quill-jdbc)"),(0,i.kt)("p",null,"Quill supports Oracle version 12c and up although due to licensing restrictions, version 18c XE is used for testing."),(0,i.kt)("p",null,"Note that the latest Oracle JDBC drivers are not publicly available. In order to get them,\nyou will need to connect to Oracle's private maven repository as instructed ",(0,i.kt)("a",{parentName:"p",href:"https://docs.oracle.com/middleware/1213/core/MAVEN/config_maven_repo.htm#MAVEN9012"},"here"),".\nUnfortunately, this procedure currently does not work for SBT. There are various workarounds\navailable for this situation ",(0,i.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/1074869/find-oracle-jdbc-driver-in-maven-repository?rq=1"},"here"),"."),(0,i.kt)("h4",{id:"sbt-dependencies-5"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "com.oracle.jdbc" % "ojdbc8" % "18.3.0.0.0",\n  "io.getquill" %% "quill-jdbc" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-5"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new OracleJdbcContext(SnakeCase, "ctx")\n')),(0,i.kt)("h4",{id:"applicationproperties-4"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dataSourceClassName=com.microsoft.sqlserver.jdbc.SQLServerDataSource\nctx.dataSource.user=user\nctx.dataSource.password=YourStrongPassword\nctx.dataSource.databaseName=database\nctx.dataSource.portNumber=1433\nctx.dataSource.serverName=host\n")),(0,i.kt)("h2",{id:"zio-quill-jdbc-zio"},"ZIO (quill-jdbc-zio)"),(0,i.kt)("p",null,"Quill context that executes JDBC queries inside of ZIO. Unlike most other contexts\nthat require passing in a ",(0,i.kt)("inlineCode",{parentName:"p"},"java.sql.DataSource")," when the context is created, this context's\nrun methods return a ZIO that has a DataSource resource dependency.\nNaturally, this should be provided later on in your application\n(see ",(0,i.kt)("inlineCode",{parentName:"p"},"ZioJdbc")," for helper methods that assist in doing this)."),(0,i.kt)("p",null,"Since resource dependency is ",(0,i.kt)("inlineCode",{parentName:"p"},"Has[DataSource]")," the result of a ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," call is ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO[Has[DataSource], SQLException, T]"),".\nThis means that if you have a ",(0,i.kt)("inlineCode",{parentName:"p"},"DataSource")," object, you can just provide it!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def ds: DataSource = _\nrun(people).provide(Has(ds))\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Since most quill-zio methods return ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO[Has[DataSource], SQLException, T]"),"\nthe type ",(0,i.kt)("inlineCode",{parentName:"p"},"QIO[T]")," i.e. Quill-IO has been defined as an alias."),(0,i.kt)("p",{parentName:"blockquote"},"For underlying-contexts (see below) that depend on ",(0,i.kt)("inlineCode",{parentName:"p"},"Has[Connection]"),",\nthe alias ",(0,i.kt)("inlineCode",{parentName:"p"},"QCIO[T]")," (i.e. Quill-Connection-IO) has been defined\nfor ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO[Has[Connection], SQLException, T]"),".")),(0,i.kt)("p",null,"Since in most JDBC use-cases, a connection-pool datasource (e.g. Hikari) is used,\nconstructor-methods ",(0,i.kt)("inlineCode",{parentName:"p"},"fromPrefix"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"fromConfig"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"fromJdbcConfig")," are available on\n",(0,i.kt)("inlineCode",{parentName:"p"},"DataSourceLayer")," to construct instances of a ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLayer[Any, SQLException, Has[DataSource]]"),"\nwhich can be easily used to provide a DataSource dependency.\nYou can use them like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import ZioJdbc._\nval zioDs = DataSourceLayer.fromPrefix("testPostgresDB")\nMyZioContext.run(query[Person]).provideCustomLayer(zioDS)\n')),(0,i.kt)("p",null,"If in some rare cases, you wish to provide a ",(0,i.kt)("inlineCode",{parentName:"p"},"java.sql.Connection")," to a ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," method directly, you can delegate\nto the underlying-context. This is a more low-level context whose ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," methods have a ",(0,i.kt)("inlineCode",{parentName:"p"},"Has[Connection]")," resource.\nHere is an example of how this can be done."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def conn: Connection = _ // If you are starting with a connection object\n\nimport io.getquill.context.ZioJdbc._\n// Import encoders/decoders of the underlying context. Do not import quote/run/prepare methods to avoid conflicts.\nimport MyZioContext.underlying.{ quote => _, run => _, prepare => _,  _ }\n\nMyZioContext.underlying.run(people).provide(Has(conn))\n")),(0,i.kt)("p",null,"If you are working with an underlying-context and want to provide a DataSource instead of a connection,\nyou can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"onDataSource")," method. Note however that this is ",(0,i.kt)("em",{parentName:"p"},"only")," needed when working with an underlying-context.\nWhen working with a normal context, ",(0,i.kt)("inlineCode",{parentName:"p"},"onDataSource")," is not available or necessary\n(since for a  normal contexts ",(0,i.kt)("inlineCode",{parentName:"p"},"R")," will be ",(0,i.kt)("inlineCode",{parentName:"p"},"Has[DataSource]"),")."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val ds: DataSource = _\n\nimport io.getquill.context.ZioJdbc._\n// Import encoders/decoders of the underlying context. Do not import quote/run/prepare methods to avoid conflicts.\nimport MyZioContext.underlying.{ quote => _, run => _, prepare => _,  _ }\n\nMyZioContext.underlying.run(people).onDataSource.provide(Has(ds))\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Also note that if you are using a Plain Scala app however, you will need to manually run it i.e. using zio.Runtime"),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"Runtime.default.unsafeRun(MyZioContext.run(query[Person]).provideLayer(zioDS))\n"))),(0,i.kt)("h4",{id:"dao-helper"},"DAO helper"),(0,i.kt)("p",null,"One additional useful pattern is to use ",(0,i.kt)("inlineCode",{parentName:"p"},"import io.getquill.context.qzio.ImplicitSyntax.Implicit")," to provide\nan implicit DataSource to one or multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"run(qry)")," calls in a context. This is very useful when creating\nDAO patterns that will reuse a DataSource many times:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class MyQueryService(ds: DataSource with Closeable) { // I.e. our DAO\n import Ctx._\n implicit val env = Implicit(Has(ds)) // This will be looked up in each `.implicitDS` call\n\n val joes = Ctx.run(query[Person].filter(p => p.name == "Joe")).implicitDS\n val jills = Ctx.run(query[Person].filter(p => p.name == "Jill")).implicitDS\n val alexes = Ctx.run(query[Person].filter(p => p.name == "Alex")).implicitDS\n}\n')),(0,i.kt)("p",null,"More examples of a Quill-JDBC-ZIO app ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/getquill/quill/tree/master/quill-jdbc-zio/src/test/scala/io/getquill/examples"},"quill-jdbc-zio/src/test/scala/io/getquill/examples"),"."),(0,i.kt)("h4",{id:"streaming"},"streaming"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ZioJdbcContext")," can stream using zio.ZStream:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.stream(query[Person])             // returns: ZStream[Has[Connection], Throwable, Person]\n  .run(Sink.collectAll).map(_.toList) // returns: ZIO[Has[Connection], Throwable, List[T]]\n")),(0,i.kt)("h4",{id:"transactions-1"},"transactions"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ZioJdbcContext"),"s provide support for transactions without needing thread-local storage or similar\nbecause they propagate the resource dependency in the ZIO effect itself (i.e. the ",(0,i.kt)("inlineCode",{parentName:"p"},"Has[Connection]")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"Zio[Has[Connection], _, _]"),").\nAs with the other contexts, if an exception is thrown anywhere inside a task or sub-task within a ",(0,i.kt)("inlineCode",{parentName:"p"},"transaction")," block, the entire block\nwill be rolled back by the database."),(0,i.kt)("p",null,"Basic syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'val trans =\n  ctx.transaction {\n    for {\n      _ <- ctx.run(query[Person].delete)\n      _ <- ctx.run(query[Person].insertValue(Person("Joe", 123)))\n      p <- ctx.run(query[Person])\n    } yield p\n  } //returns: ZIO[Has[Connection], Throwable, List[Person]]\n\nval result = Runtime.default.unsafeRun(trans.onDataSource.provide(ds)) //returns: List[Person]\n')),(0,i.kt)("h4",{id:"json"},"json"),(0,i.kt)("p",null,"The Zio Quill Postgres supports JSON encoding/decoding via the zio-json library. Just wrap your object in a ",(0,i.kt)("inlineCode",{parentName:"p"},"JsonValue")," instance\nand then define encoders/decoders via zio-json's ",(0,i.kt)("inlineCode",{parentName:"p"},"JsonEncoder"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"JsonDecoder")," modules."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import context._\ncase class Person(name: String, age: Int)\ncase class MyTable(name: String, value: JsonValue[Person])\n\nval joe = Person("Joe", 123)\nval joeRow = MyTable("SomeJoe", JsonValue(joe))\n\n// Declare an encoder/decoder for `Person` via zio-json\nimplicit val personEncoder: JsonEncoder[Person] = DeriveJsonEncoder.gen[Person]\nimplicit val personDecoder: JsonDecoder[Person] = DeriveJsonDecoder.gen[Person]\n\nval myApp: ZIO[Any, SQLException, List[MyTable]] =\n  for {\n    // You can then insert the value:\n    _ <- context.run(query[MyTable].insertValue(lift(joeRow)))\n    // As well read it:\n    value <- context.run(query[MyTable])\n  } yield (value)\n')),(0,i.kt)("p",null,"You can also encode/decode objects that have the type ",(0,i.kt)("inlineCode",{parentName:"p"},"zio.json.ast.Json")," directly."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import context._\ncase class MyTable(name: String, value: JsonValue[Json])\n\n// i.e. {name:"Joe", age:123}\nval jsonJoe = Json.Obj(Chunk("name" -> Json.Str("Joe"), "age" -> Json.Num(123)))\nval joeRow = MyTable("SomeJoe", JsonValue(jsonJoe))\n\ntestContext.run(jsonAstQuery.insertValue(lift(joeRow)))\n')),(0,i.kt)("h3",{id:"mysql-quill-jdbc-zio"},"MySQL (quill-jdbc-zio)"),(0,i.kt)("h4",{id:"sbt-dependencies-6"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "mysql" % "mysql-connector-java" % "8.0.17",\n  "io.getquill" %% "quill-jdbc-zio" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-6"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val ctx = new MysqlZioJdbcContext(SnakeCase)\n// Also can be static:\nobject MyContext extends MysqlZioJdbcContext(SnakeCase)\n")),(0,i.kt)("h4",{id:"applicationproperties-5"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dataSourceClassName=com.mysql.cj.jdbc.MysqlDataSource\nctx.dataSource.url=jdbc:mysql://host/database\nctx.dataSource.user=root\nctx.dataSource.password=root\nctx.dataSource.cachePrepStmts=true\nctx.dataSource.prepStmtCacheSize=250\nctx.dataSource.prepStmtCacheSqlLimit=2048\nctx.connectionTimeout=30000\n")),(0,i.kt)("h3",{id:"postgres-quill-jdbc-zio"},"Postgres (quill-jdbc-zio)"),(0,i.kt)("h4",{id:"sbt-dependencies-7"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "org.postgresql" % "postgresql" % "42.2.8",\n  "io.getquill" %% "quill-jdbc-zio" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-7"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val ctx = new PostgresZioJdbcContext(SnakeCase)\n// Also can be static:\nobject MyContext extends PostgresZioJdbcContext(SnakeCase)\n")),(0,i.kt)("h4",{id:"applicationproperties-6"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dataSourceClassName=org.postgresql.ds.PGSimpleDataSource\nctx.dataSource.user=root\nctx.dataSource.password=root\nctx.dataSource.databaseName=database\nctx.dataSource.portNumber=5432\nctx.dataSource.serverName=host\nctx.connectionTimeout=30000\n")),(0,i.kt)("h3",{id:"sqlite-quill-jdbc-zio"},"Sqlite (quill-jdbc-zio)"),(0,i.kt)("h4",{id:"sbt-dependencies-8"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "org.xerial" % "sqlite-jdbc" % "3.28.0",\n  "io.getquill" %% "quill-jdbc-zio" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-8"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val ctx = new SqlitezioJdbcContext(SnakeCase)\n// Also can be static:\nobject MyContext extends SqlitezioJdbcContext(SnakeCase)\n")),(0,i.kt)("h4",{id:"applicationproperties-7"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.driverClassName=org.sqlite.JDBC\nctx.jdbcUrl=jdbc:sqlite:/path/to/db/file.db\n")),(0,i.kt)("h3",{id:"h2-quill-jdbc-zio"},"H2 (quill-jdbc-zio)"),(0,i.kt)("h4",{id:"sbt-dependencies-9"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "com.h2database" % "h2" % "1.4.199",\n  "io.getquill" %% "quill-jdbc-zio" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-9"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val ctx = new H2ZioJdbcContext(SnakeCase)\n// Also can be static:\nobject MyContext extends H2ZioJdbcContext(SnakeCase)\n")),(0,i.kt)("h4",{id:"applicationproperties-8"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dataSourceClassName=org.h2.jdbcx.JdbcDataSource\nctx.dataSource.url=jdbc:h2:mem:yourdbname\nctx.dataSource.user=sa\n")),(0,i.kt)("h3",{id:"sql-server-quill-jdbc-zio"},"SQL Server (quill-jdbc-zio)"),(0,i.kt)("h4",{id:"sbt-dependencies-10"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "com.microsoft.sqlserver" % "mssql-jdbc" % "7.4.1.jre8",\n  "io.getquill" %% "quill-jdbc-zio" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-10"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val ctx = new SqlServerZioJdbcContext(SnakeCase)\n// Also can be static:\nobject MyContext extends SqlServerZioJdbcContext(SnakeCase)\n")),(0,i.kt)("h4",{id:"applicationproperties-9"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dataSourceClassName=com.microsoft.sqlserver.jdbc.SQLServerDataSource\nctx.dataSource.user=user\nctx.dataSource.password=YourStrongPassword\nctx.dataSource.databaseName=database\nctx.dataSource.portNumber=1433\nctx.dataSource.serverName=host\n")),(0,i.kt)("h3",{id:"oracle-quill-jdbc-zio"},"Oracle (quill-jdbc-zio)"),(0,i.kt)("p",null,"Quill supports Oracle version 12c and up although due to licensing restrictions, version 18c XE is used for testing."),(0,i.kt)("h4",{id:"sbt-dependencies-11"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "com.oracle.jdbc" % "ojdbc8" % "18.3.0.0.0",\n  "io.getquill" %% "quill-jdbc-zio" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-11"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val ctx = new OracleZioJdbcContext(SnakeCase)\n// Also can be static:\nobject MyContext extends OracleZioJdbcContext(SnakeCase)\n")),(0,i.kt)("h4",{id:"applicationproperties-10"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dataSourceClassName=oracle.jdbc.xa.client.OracleXADataSource\nctx.dataSource.databaseName=xe\nctx.dataSource.user=database\nctx.dataSource.password=YourStrongPassword\nctx.dataSource.driverType=thin\nctx.dataSource.portNumber=1521\nctx.dataSource.serverName=host\n")),(0,i.kt)("h2",{id:"quill-jdbc-monix"},"quill-jdbc-monix"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"quill-jdbc-monix")," module integrates the Monix asynchronous programming framework with Quill,\nsupporting all of the database vendors of the ",(0,i.kt)("inlineCode",{parentName:"p"},"quill-jdbc")," module.\nThe Quill Monix contexts encapsulate JDBC Queries and Actions into Monix ",(0,i.kt)("inlineCode",{parentName:"p"},"Task"),"s\nand also include support for streaming queries via ",(0,i.kt)("inlineCode",{parentName:"p"},"Observable"),"."),(0,i.kt)("h4",{id:"streaming-1"},"streaming"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"MonixJdbcContext")," can stream using Monix Observables:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.stream(query[Person]) // returns: Observable[Person]\n  .foreachL(println(_))\n  .runSyncUnsafe()\n")),(0,i.kt)("h4",{id:"transactions-2"},"transactions"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"MonixJdbcContext")," provides support for transactions by storing the connection into a Monix ",(0,i.kt)("inlineCode",{parentName:"p"},"Local"),".\nThis process is designed to be completely transparent to the user. As with the other contexts,\nif an exception is thrown anywhere inside a task or sub-task within a ",(0,i.kt)("inlineCode",{parentName:"p"},"transaction")," block, the entire block\nwill be rolled back by the database."),(0,i.kt)("p",null,"Basic syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'val trans =\n  ctx.transaction {\n    for {\n      _ <- ctx.run(query[Person].delete)\n      _ <- ctx.run(query[Person].insertValue(Person("Joe", 123)))\n      p <- ctx.run(query[Person])\n    } yield p\n  } //returns: Task[List[Person]]\n\nval result = trans.runSyncUnsafe() //returns: List[Person]\n')),(0,i.kt)("p",null,"Streaming can also be done inside of ",(0,i.kt)("inlineCode",{parentName:"p"},"transaction")," block so long as the result is converted to a task beforehand."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'val trans =\n  ctx.transaction {\n    for {\n      _   <- ctx.run(query[Person].insertValue(Person("Joe", 123)))\n      ppl <- ctx\n              .stream(query[Person])                               // Observable[Person]\n              .foldLeftL(List[Person]())({case (l, p) => p +: l})  // ... becomes Task[List[Person]]\n    } yield ppl\n  } //returns: Task[List[Person]]\n\nval result = trans.runSyncUnsafe() //returns: List[Person]\n')),(0,i.kt)("h4",{id:"runners"},"runners"),(0,i.kt)("p",null,"Use a ",(0,i.kt)("inlineCode",{parentName:"p"},"Runner")," object to create the different ",(0,i.kt)("inlineCode",{parentName:"p"},"MonixJdbcContext"),"s.\nThe Runner does the actual wrapping of JDBC calls into Monix Tasks."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'\nimport monix.execution.Scheduler\nimport io.getquill.context.monix.Runner\n\n// You can use the default Runner when constructing a Monix jdbc contexts.\n// The resulting tasks will be wrapped with whatever Scheduler is\n// defined when you do task.syncRunUnsafe(), typically a global implicit.\nlazy val ctx = new MysqlMonixJdbcContext(SnakeCase, "ctx", EffectWrapper.default)\n\n// However...\n// Monix strongly suggests that you use a separate thread pool for database IO\n// operations. `Runner` provides a convenience method in order to do this.\nlazy val ctx = new MysqlMonixJdbcContext(SnakeCase, "ctx", Runner.using(Scheduler.io()))\n')),(0,i.kt)("h3",{id:"mysql-quill-jdbc-monix"},"MySQL (quill-jdbc-monix)"),(0,i.kt)("h4",{id:"sbt-dependencies-12"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "mysql" % "mysql-connector-java" % "8.0.17",\n  "io.getquill" %% "quill-jdbc-monix" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-12"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new MysqlMonixJdbcContext(SnakeCase, "ctx", EffectWrapper.default)\n')),(0,i.kt)("h4",{id:"applicationproperties-11"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dataSourceClassName=com.mysql.cj.jdbc.MysqlDataSource\nctx.dataSource.url=jdbc:mysql://host/database\nctx.dataSource.user=root\nctx.dataSource.password=root\nctx.dataSource.cachePrepStmts=true\nctx.dataSource.prepStmtCacheSize=250\nctx.dataSource.prepStmtCacheSqlLimit=2048\nctx.connectionTimeout=30000\n")),(0,i.kt)("h3",{id:"postgres-quill-jdbc-monix"},"Postgres (quill-jdbc-monix)"),(0,i.kt)("h4",{id:"sbt-dependencies-13"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "org.postgresql" % "postgresql" % "42.2.8",\n  "io.getquill" %% "quill-jdbc-monix" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-13"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new PostgresMonixJdbcContext(SnakeCase, "ctx", EffectWrapper.default)\n')),(0,i.kt)("h4",{id:"applicationproperties-12"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dataSourceClassName=org.postgresql.ds.PGSimpleDataSource\nctx.dataSource.user=root\nctx.dataSource.password=root\nctx.dataSource.databaseName=database\nctx.dataSource.portNumber=5432\nctx.dataSource.serverName=host\nctx.connectionTimeout=30000\n")),(0,i.kt)("h3",{id:"sqlite-quill-jdbc-monix"},"Sqlite (quill-jdbc-monix)"),(0,i.kt)("h4",{id:"sbt-dependencies-14"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "org.xerial" % "sqlite-jdbc" % "3.28.0",\n  "io.getquill" %% "quill-jdbc-monix" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-14"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new SqliteMonixJdbcContext(SnakeCase, "ctx", EffectWrapper.default)\n')),(0,i.kt)("h4",{id:"applicationproperties-13"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.driverClassName=org.sqlite.JDBC\nctx.jdbcUrl=jdbc:sqlite:/path/to/db/file.db\n")),(0,i.kt)("h3",{id:"h2-quill-jdbc-monix"},"H2 (quill-jdbc-monix)"),(0,i.kt)("h4",{id:"sbt-dependencies-15"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "com.h2database" % "h2" % "1.4.199",\n  "io.getquill" %% "quill-jdbc-monix" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-15"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new H2MonixJdbcContext(SnakeCase, "ctx", EffectWrapper.default)\n')),(0,i.kt)("h4",{id:"applicationproperties-14"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dataSourceClassName=org.h2.jdbcx.JdbcDataSource\nctx.dataSource.url=jdbc:h2:mem:yourdbname\nctx.dataSource.user=sa\n")),(0,i.kt)("h3",{id:"sql-server-quill-jdbc-monix"},"SQL Server (quill-jdbc-monix)"),(0,i.kt)("h4",{id:"sbt-dependencies-16"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "com.microsoft.sqlserver" % "mssql-jdbc" % "7.4.1.jre8",\n  "io.getquill" %% "quill-jdbc-monix" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-16"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new SqlServerMonixJdbcContext(SnakeCase, "ctx", EffectWrapper.default)\n')),(0,i.kt)("h4",{id:"applicationproperties-15"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dataSourceClassName=com.microsoft.sqlserver.jdbc.SQLServerDataSource\nctx.dataSource.user=user\nctx.dataSource.password=YourStrongPassword\nctx.dataSource.databaseName=database\nctx.dataSource.portNumber=1433\nctx.dataSource.serverName=host\n")),(0,i.kt)("h3",{id:"oracle-quill-jdbc-monix"},"Oracle (quill-jdbc-monix)"),(0,i.kt)("p",null,"Quill supports Oracle version 12c and up although due to licensing restrictions, version 18c XE is used for testing."),(0,i.kt)("p",null,"Note that the latest Oracle JDBC drivers are not publicly available. In order to get them,\nyou will need to connect to Oracle's private maven repository as instructed ",(0,i.kt)("a",{parentName:"p",href:"https://docs.oracle.com/middleware/1213/core/MAVEN/config_maven_repo.htm#MAVEN9012"},"here"),".\nUnfortunately, this procedure currently does not work for SBT. There are various workarounds\navailable for this situation ",(0,i.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/1074869/find-oracle-jdbc-driver-in-maven-repository?rq=1"},"here"),"."),(0,i.kt)("h4",{id:"sbt-dependencies-17"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "com.oracle.jdbc" % "ojdbc8" % "18.3.0.0.0",\n  "io.getquill" %% "quill-jdbc-monix" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-17"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new OracleJdbcContext(SnakeCase, "ctx")\n')),(0,i.kt)("h4",{id:"applicationproperties-16"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dataSourceClassName=oracle.jdbc.xa.client.OracleXADataSource\nctx.dataSource.databaseName=xe\nctx.dataSource.user=database\nctx.dataSource.password=YourStrongPassword\nctx.dataSource.driverType=thin\nctx.dataSource.portNumber=1521\nctx.dataSource.serverName=host\n")),(0,i.kt)("h2",{id:"ndbc-context"},"NDBC Context"),(0,i.kt)("p",null,"Async support via ",(0,i.kt)("a",{parentName:"p",href:"https://ndbc.io/"},"NDBC driver")," is available with Postgres database."),(0,i.kt)("h3",{id:"quill-ndbc-postgres"},"quill-ndbc-postgres"),(0,i.kt)("h4",{id:"transactions-3"},"transactions"),(0,i.kt)("p",null,"Transaction support is provided out of the box by NDBC:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"ctx.transaction {\n  ctx.run(query[Person].delete)\n  // other transactional code\n}\n")),(0,i.kt)("p",null,"The body of transaction can contain calls to other methods and multiple run calls since the transaction is automatically handled."),(0,i.kt)("h4",{id:"sbt-dependencies-18"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "io.getquill" %% "quill-ndbc-postgres" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-18"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new NdbcPostgresContext(Literal, "ctx")\n')),(0,i.kt)("h4",{id:"applicationproperties-17"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.ndbc.dataSourceSupplierClass=io.trane.ndbc.postgres.netty4.DataSourceSupplier\nctx.ndbc.host=host\nctx.ndbc.port=1234\nctx.ndbc.user=root\nctx.ndbc.password=root\nctx.ndbc.database=database\n")),(0,i.kt)("h2",{id:"quill-async"},"quill-async"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"quill-async")," module provides simple async support for MySQL and Postgres databases."),(0,i.kt)("h4",{id:"transactions-4"},"transactions"),(0,i.kt)("p",null,"The async module provides transaction support based on a custom implicit execution context:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.transaction { implicit ec =>\n  ctx.run(query[Person].delete)\n  // other transactional code\n}\n")),(0,i.kt)("p",null,"The body of ",(0,i.kt)("inlineCode",{parentName:"p"},"transaction")," can contain calls to other methods and multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," calls, but the transactional code must be done using the provided implicit execution context. For instance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'def deletePerson(name: String)(implicit ec: ExecutionContext) =\n  ctx.run(query[Person].filter(_.name == lift(name)).delete)\n\nctx.transaction { implicit ec =>\n  deletePerson("John")\n}\n')),(0,i.kt)("p",null,"Depending on how the main execution context is imported, it is possible to produce an ambiguous implicit resolution. A way to solve this problem is shadowing the multiple implicits by using the same name:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'import scala.concurrent.ExecutionContext.Implicits.{ global => ec }\n\ndef deletePerson(name: String)(implicit ec: ExecutionContext) =\n  ctx.run(query[Person].filter(_.name == lift(name)).delete)\n\nctx.transaction { implicit ec =>\n  deletePerson("John")\n}\n')),(0,i.kt)("p",null,"Note that the global execution context is renamed to ec."),(0,i.kt)("h4",{id:"applicationproperties-18"},"application.properties"),(0,i.kt)("h5",{id:"connection-configuration"},"connection configuration"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.host=host\nctx.port=1234\nctx.user=root\nctx.password=root\nctx.database=database\n")),(0,i.kt)("p",null,"or use connection URL with database-specific scheme (see below):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.url=scheme://host:5432/database?user=root&password=root\n")),(0,i.kt)("h5",{id:"connection-pool-configuration"},"connection pool configuration"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.poolMaxQueueSize=4\nctx.poolMaxObjects=4\nctx.poolMaxIdle=999999999\nctx.poolValidationInterval=10000\n")),(0,i.kt)("p",null,"Also see ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/mauricio/postgresql-async/blob/master/db-async-common/src/main/scala/com/github/mauricio/async/db/pool/PoolConfiguration.scala"},(0,i.kt)("inlineCode",{parentName:"a"},"PoolConfiguration")," documentation"),"."),(0,i.kt)("h5",{id:"ssl-configuration"},"SSL configuration"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.sslmode=disable # optional, one of [disable|prefer|require|verify-ca|verify-full]\nctx.sslrootcert=./path/to/cert/file # optional, required for sslmode=verify-ca or verify-full\n")),(0,i.kt)("h5",{id:"other"},"other"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.charset=UTF-8\nctx.maximumMessageSize=16777216\nctx.connectTimeout=5s\nctx.testTimeout=5s\nctx.queryTimeout=10m\n")),(0,i.kt)("h3",{id:"quill-async-mysql"},"quill-async-mysql"),(0,i.kt)("h4",{id:"sbt-dependencies-19"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "io.getquill" %% "quill-async-mysql" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-19"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new MysqlAsyncContext(SnakeCase, "ctx")\n')),(0,i.kt)("h4",{id:"applicationproperties-19"},"application.properties"),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"#applicationproperties-5"},"above")),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"url")," property use ",(0,i.kt)("inlineCode",{parentName:"p"},"mysql")," scheme:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.url=mysql://host:3306/database?user=root&password=root\n")),(0,i.kt)("h3",{id:"quill-async-postgres"},"quill-async-postgres"),(0,i.kt)("h4",{id:"sbt-dependencies-20"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "io.getquill" %% "quill-async-postgres" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-20"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new PostgresAsyncContext(SnakeCase, "ctx")\n')),(0,i.kt)("h4",{id:"applicationproperties-20"},"application.properties"),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"#applicationproperties-5"},"common properties")),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"url")," property use ",(0,i.kt)("inlineCode",{parentName:"p"},"postgresql")," scheme:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.url=postgresql://host:5432/database?user=root&password=root\n")),(0,i.kt)("h2",{id:"quill-jasync"},"quill-jasync"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"quill-jasync")," module provides simple async support for Postgres databases."),(0,i.kt)("h4",{id:"transactions-5"},"transactions"),(0,i.kt)("p",null,"The async module provides transaction support based on a custom implicit execution context:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.transaction { implicit ec =>\n  ctx.run(query[Person].delete)\n  // other transactional code\n}\n")),(0,i.kt)("p",null,"The body of ",(0,i.kt)("inlineCode",{parentName:"p"},"transaction")," can contain calls to other methods and multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," calls, but the transactional code must be done using the provided implicit execution context. For instance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'def deletePerson(name: String)(implicit ec: ExecutionContext) =\n  ctx.run(query[Person].filter(_.name == lift(name)).delete)\n\nctx.transaction { implicit ec =>\n  deletePerson("John")\n}\n')),(0,i.kt)("p",null,"Depending on how the main execution context is imported, it is possible to produce an ambiguous implicit resolution. A way to solve this problem is shadowing the multiple implicits by using the same name:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'import scala.concurrent.ExecutionContext.Implicits.{ global => ec }\n\ndef deletePerson(name: String)(implicit ec: ExecutionContext) =\n  ctx.run(query[Person].filter(_.name == lift(name)).delete)\n\nctx.transaction { implicit ec =>\n  deletePerson("John")\n}\n')),(0,i.kt)("p",null,"Note that the global execution context is renamed to ec."),(0,i.kt)("h4",{id:"applicationproperties-21"},"application.properties"),(0,i.kt)("h5",{id:"connection-configuration-1"},"connection configuration"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.host=host\nctx.port=1234\nctx.username=root\nctx.password=root\nctx.database=database\n")),(0,i.kt)("p",null,"or use connection URL with database-specific scheme (see below):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.url=scheme://host:5432/database?user=root&password=root\n")),(0,i.kt)("p",null,"Also see full settings ",(0,i.kt)("inlineCode",{parentName:"p"},"ConnectionPoolConfiguration")," ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jasync-sql/jasync-sql/blob/master/db-async-common/src/main/java/com/github/jasync/sql/db/ConnectionPoolConfiguration.kt"},"documentation"),"."),(0,i.kt)("h5",{id:"ssl-configuration-1"},"SSL configuration"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.sslmode=disable # optional, one of [disable|prefer|require|verify-ca|verify-full]\nctx.sslrootcert=./path/to/cert/file # optional, required for sslmode=verify-ca or verify-full\n")),(0,i.kt)("h3",{id:"quill-jasync-mysql"},"quill-jasync-mysql"),(0,i.kt)("h4",{id:"sbt-dependencies-21"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "io.getquill" %% "quill-jasync-mysql" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-21"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new MysqlJAsyncContext(SnakeCase, "ctx")\n')),(0,i.kt)("h4",{id:"applicationproperties-22"},"application.properties"),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"#applicationproperties-5"},"above")),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"url")," property use ",(0,i.kt)("inlineCode",{parentName:"p"},"mysql")," scheme:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.url=mysql://host:3306/database?user=root&password=root\n")),(0,i.kt)("h3",{id:"quill-jasync-postgres"},"quill-jasync-postgres"),(0,i.kt)("h4",{id:"sbt-dependencies-22"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "io.getquill" %% "quill-jasync-postgres" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-22"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new PostgresJAsyncContext(SnakeCase, "ctx")\n')),(0,i.kt)("h4",{id:"applicationproperties-23"},"application.properties"),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"#applicationproperties-5"},"common properties")),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"url")," property use ",(0,i.kt)("inlineCode",{parentName:"p"},"postgresql")," scheme:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.url=postgresql://host:5432/database?user=root&password=root\n")),(0,i.kt)("h2",{id:"quill-jasync-zio"},"quill-jasync-zio"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"quill-jasync-zio")," module provides ZIO async support for Postgres databases."),(0,i.kt)("h5",{id:"connection-configuration-2"},"connection configuration"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.host=host\nctx.port=1234\nctx.username=root\nctx.password=root\nctx.database=database\n")),(0,i.kt)("p",null,"or use connection URL with database-specific scheme (see below):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.url=scheme://host:5432/database?user=root&password=root\n")),(0,i.kt)("p",null,"Also see full settings ",(0,i.kt)("inlineCode",{parentName:"p"},"ConnectionPoolConfiguration")," ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jasync-sql/jasync-sql/blob/master/db-async-common/src/main/java/com/github/jasync/sql/db/ConnectionPoolConfiguration.kt"},"documentation"),"."),(0,i.kt)("h5",{id:"ssl-configuration-2"},"SSL configuration"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.sslmode=disable # optional, one of [disable|prefer|require|verify-ca|verify-full]\nctx.sslrootcert=./path/to/cert/file # optional, required for sslmode=verify-ca or verify-full\nctx.sslcert=./path/to/cert/file # optional, required to only allow connections from trusted clients\nctx.sslkey=./path/to/key/file # optional, required to only allow connections from trusted clients\n")),(0,i.kt)("h3",{id:"quill-jasync-zio-postgres"},"quill-jasync-zio-postgres"),(0,i.kt)("h4",{id:"sbt-dependencies-23"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "io.getquill" %% "quill-jasync-zio-postgres" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-23"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"lazy val ctx = new PostgresZioJAsyncContext(SnakeCase)\n// Also can be static:\nobject MyContext extends PostgresZioJAsyncContext(Literal)\n")),(0,i.kt)("p",null,"In order to run operation in this context we need to provide ",(0,i.kt)("inlineCode",{parentName:"p"},"ZioJAsyncConnection")," instance."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'object MyApp extends zio.App {\n  object DBContext extends PostgresZioJAsyncContext(Literal)\n  import DBContext._\n\n  val dependencies =\n    PostgresJAsyncContextConfig.loadConfig("testPostgresDB") >>>\n    ZioJAsyncConnection.live[PostgreSQLConnection]\n\n  val program = run(query[Person])\n\n  def run(args: List[String]) = program.provideLayer(dependencies).exitCode\n}\n')),(0,i.kt)("h4",{id:"applicationproperties-24"},"application.properties"),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"#applicationproperties-5"},"common properties")),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"url")," property use ",(0,i.kt)("inlineCode",{parentName:"p"},"postgresql")," scheme:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.url=postgresql://host:5432/database?user=root&password=root\n")),(0,i.kt)("h2",{id:"quill-doobie"},"quill-doobie"),(0,i.kt)("p",null,"Quill 3.16.5 and above supports Doobie starting 1.0.0-RC1. You can use quill quotes to construct ",(0,i.kt)("inlineCode",{parentName:"p"},"ConnectionIO")," programs.\nQuill provides statement construction and type mapping, and doobie takes care of statement execution."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that if you are migrating from the original ",(0,i.kt)("inlineCode",{parentName:"p"},"doobie-quill")," integration (e.g. ",(0,i.kt)("a",{parentName:"p",href:"https://search.maven.org/search?q=a:doobie-quill_2.12"},"here"),")\njust add the below dependency and replace the ",(0,i.kt)("inlineCode",{parentName:"p"},"doobie.quill")," package with ",(0,i.kt)("inlineCode",{parentName:"p"},"io.getquill.doobie"),".\n(If you are using the package provided by kubukoz (i.e. ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/polyvariant/doobie-quill"},"here"),"), then replace ",(0,i.kt)("inlineCode",{parentName:"p"},"org.polyvariant")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"io.getquill.doobie"),".)")),(0,i.kt)("p",null,"In order to use this feature, add the following dependency."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies += "io.getquill" %% "quill-doobie" % "4.6.1-SNAPSHOT"\n')),(0,i.kt)("p",null,"The examples below require the following imports."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"import io.getquill.{ idiom => _, _ }\nimport io.getquill.DoobieContext\n")),(0,i.kt)("p",null,"We can now construct a ",(0,i.kt)("inlineCode",{parentName:"p"},"DoobieContext")," for our back-end database and import its members, as we would with a traditional Quill context. The options are ",(0,i.kt)("inlineCode",{parentName:"p"},"H2"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"MySQL"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Oracle"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Postgres"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"SQLite"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"SQLServer"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"val dc = new DoobieContext.Postgres(Literal) // Literal naming scheme\nimport dc.{ SqlInfixInterpolator => _, _ }   // Quill's `sql` interpolator conflicts with doobie so don't import it\nimport dc.compat._                           // Import the qsql interpolator instead\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Instead of using Quill's ",(0,i.kt)("inlineCode",{parentName:"p"},'sql"MyUDF(${something})"')," interpolator, use ",(0,i.kt)("inlineCode",{parentName:"p"},'qsql"MyUDF(${something})"')," since we have excluded it.")),(0,i.kt)("p",null,"We will be using the ",(0,i.kt)("inlineCode",{parentName:"p"},"country")," table from our test database, so we need a data type of that name, with fields whose names and types line up with the table definition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Country(code: String, name: String, population: Int)\n")),(0,i.kt)("p",null,"We're now ready to construct doobie programs using Quill quotes. Note the return types from ",(0,i.kt)("inlineCode",{parentName:"p"},"run"),", which are normal doobie types. You can freely mix Quill quotes into existing doobie programs."),(0,i.kt)("h4",{id:"running-and-streaming"},"running and streaming"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val q1 = quote { query[Country].filter(_.code == "GBR") }\n\n// Select all at once\nrun(q1)\n\n// Stream in chunks of 16\nstream(q1, 16)\n')),(0,i.kt)("h4",{id:"actions"},"actions"),(0,i.kt)("p",null,"A simple update."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val u1 = quote { query[Country].filter(_.name like "U%").update(_.name -> "foo") }\n\n// Update yielding count of affected rows\nrun(u1)\n')),(0,i.kt)("p",null,"A batch update."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val u2 = quote {\n  liftQuery(List("U%", "A%")).foreach { pat =>\n    query[Country].filter(_.name like pat).update(_.name -> "foo")\n  }\n}\n\n// Update yielding list of counts of affected rows\nrun(u2)\n')),(0,i.kt)("p",null,"Now we will look at batch updates with generated keys. For this we will create a new table."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE Foo (\n  id    SERIAL,\n  value VARCHAR(42)\n)\n")),(0,i.kt)("p",null,"And a related data type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Foo(id: Int, value: String)\n")),(0,i.kt)("p",null,"We can now write an update returning generated keys."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val u3 = quote {\n  query[Foo].insert(lift(Foo(0, "Joe"))).returning(_.id)\n}\n\n// Update yielding a single id\nrun(u3)\n')),(0,i.kt)("p",null,"And a batch update returning generated keys."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val u4 = quote {\n  liftQuery(List(Foo(0, "Joe"), Foo(0, "Bob"))).foreach { a =>\n    query[Foo].insert(a).returning(_.id)\n  }\n}\n\n// Update yielding a list of ids\nrun(u4)\n')),(0,i.kt)("h2",{id:"finagle-contexts"},"Finagle Contexts"),(0,i.kt)("p",null,"Support for the Twitter Finagle library is available with MySQL and Postgres databases."),(0,i.kt)("h3",{id:"quill-finagle-mysql"},"quill-finagle-mysql"),(0,i.kt)("h4",{id:"transactions-6"},"transactions"),(0,i.kt)("p",null,"The finagle context provides transaction support through a ",(0,i.kt)("inlineCode",{parentName:"p"},"Local")," value. See twitter util's ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/twitter/util/blob/ee8d3140ba0ecc16b54591bd9d8961c11b999c0d/util-core/src/main/scala/com/twitter/util/Local.scala#L96"},"scaladoc")," for more details."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.transaction {\n  ctx.run(query[Person].delete)\n  // other transactional code\n}\n")),(0,i.kt)("h4",{id:"streaming-2"},"streaming"),(0,i.kt)("p",null,"The finagle context allows streaming a query response, returning an ",(0,i.kt)("inlineCode",{parentName:"p"},"AsyncStream")," value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.stream(query[Person]) // returns: Future[AsyncStream[Person]]\n  .flatMap(_.toSeq())\n")),(0,i.kt)("p",null,"The body of ",(0,i.kt)("inlineCode",{parentName:"p"},"transaction")," can contain calls to other methods and multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," calls since the transaction is automatically propagated through the ",(0,i.kt)("inlineCode",{parentName:"p"},"Local")," value."),(0,i.kt)("h4",{id:"sbt-dependencies-24"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "io.getquill" %% "quill-finagle-mysql" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-24"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new FinagleMysqlContext(SnakeCase, "ctx")\n')),(0,i.kt)("h4",{id:"applicationproperties-25"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dest=localhost:3306\nctx.user=root\nctx.password=root\nctx.database=database\nctx.pool.watermark.low=0\nctx.pool.watermark.high=10\nctx.pool.idleTime=5 # seconds\nctx.pool.bufferSize=0\nctx.pool.maxWaiters=2147483647\n")),(0,i.kt)("h3",{id:"quill-finagle-postgres"},"quill-finagle-postgres"),(0,i.kt)("h4",{id:"transactions-7"},"transactions"),(0,i.kt)("p",null,"The finagle context provides transaction support through a ",(0,i.kt)("inlineCode",{parentName:"p"},"Local")," value. See twitter util's ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/twitter/util/blob/ee8d3140ba0ecc16b54591bd9d8961c11b999c0d/util-core/src/main/scala/com/twitter/util/Local.scala#L96"},"scaladoc")," for more details."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.transaction {\n  ctx.run(query[Person].delete)\n  // other transactional code\n}\n")),(0,i.kt)("p",null,"The body of ",(0,i.kt)("inlineCode",{parentName:"p"},"transaction")," can contain calls to other methods and multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," calls since the transaction is automatically propagated through the ",(0,i.kt)("inlineCode",{parentName:"p"},"Local")," value."),(0,i.kt)("h4",{id:"sbt-dependencies-25"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "io.getquill" %% "quill-finagle-postgres" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"context-definition-25"},"context definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new FinaglePostgresContext(SnakeCase, "ctx")\n')),(0,i.kt)("h4",{id:"applicationproperties-26"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.host=localhost:3306\nctx.user=root\nctx.password=root\nctx.database=database\nctx.useSsl=false\nctx.hostConnectionLimit=1\nctx.numRetries=4\nctx.binaryResults=false\nctx.binaryParams=false\n")),(0,i.kt)("h2",{id:"quill-cassandra"},"quill-cassandra"),(0,i.kt)("h4",{id:"sbt-dependencies-26"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "io.getquill" %% "quill-cassandra" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"synchronous-context"},"synchronous context"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new CassandraSyncContext(SnakeCase, "ctx")\n')),(0,i.kt)("h4",{id:"asynchronous-context"},"asynchronous context"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new CassandraAsyncContext(SnakeCase, "ctx")\n')),(0,i.kt)("p",null,"The configurations are set using runtime reflection on the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.datastax.com/en/drivers/java/2.1/com/datastax/driver/core/Cluster.Builder.html"},(0,i.kt)("inlineCode",{parentName:"a"},"Cluster.builder"))," instance. It is possible to set nested structures like ",(0,i.kt)("inlineCode",{parentName:"p"},"queryOptions.consistencyLevel"),", use enum values like ",(0,i.kt)("inlineCode",{parentName:"p"},"LOCAL_QUORUM"),", and set multiple parameters like in ",(0,i.kt)("inlineCode",{parentName:"p"},"credentials"),"."),(0,i.kt)("h4",{id:"applicationproperties-27"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.keyspace=quill_test\nctx.preparedStatementCacheSize=1000\nctx.session.contactPoint=127.0.0.1\nctx.session.withPort=9042\nctx.session.queryOptions.consistencyLevel=LOCAL_QUORUM\nctx.session.withoutMetrics=true\nctx.session.withoutJMXReporting=false\nctx.session.credentials.0=root\nctx.session.credentials.1=pass\nctx.session.maxSchemaAgreementWaitSeconds=1\nctx.session.addressTranslator=com.datastax.driver.core.policies.IdentityTranslator\n")),(0,i.kt)("h2",{id:"quill-cassandra-zio"},"quill-cassandra-zio"),(0,i.kt)("p",null,"Quill context that executes Cassandra queries inside of ZIO. Unlike most other contexts\nthat require passing in a Data Source, this context takes in a ",(0,i.kt)("inlineCode",{parentName:"p"},"CassandraZioSession"),"\nas a resource dependency which can be provided later (see the ",(0,i.kt)("inlineCode",{parentName:"p"},"CassandraZioSession")," object for helper methods\nthat assist in doing this)."),(0,i.kt)("p",null,"The resource dependency itself is just a ",(0,i.kt)("inlineCode",{parentName:"p"},"Has[CassandraZioSession]")," hence ",(0,i.kt)("inlineCode",{parentName:"p"},"run(qry)")," and other methods in this context will return\n",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO[Has[CassandraZioSession], Throwable, T]"),".  The type ",(0,i.kt)("inlineCode",{parentName:"p"},"CIO[T]")," i.e. Cassandra-IO is an alias for this.\nProviding a ",(0,i.kt)("inlineCode",{parentName:"p"},"CassandraZioSession")," dependency is now very simple:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val session: CassandraZioSession = _\nrun(people)\n  .provide(Has(session))\n")),(0,i.kt)("p",null,"Various methods in the ",(0,i.kt)("inlineCode",{parentName:"p"},"io.getquill.CassandraZioSession")," can assist in simplifying it's creation, for example, you can\nprovide a ",(0,i.kt)("inlineCode",{parentName:"p"},"Config")," object instead of a ",(0,i.kt)("inlineCode",{parentName:"p"},"CassandraZioSession")," like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},' val zioSessionLayer: ZLayer[Any, Throwable, Has[CassandraZioSession]] =\n   CassandraZioSession.fromPrefix("testStreamDB")\nrun(query[Person])\n  .provideCustomLayer(zioSessionLayer)\n')),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"(Note that the resulting CassandraZioSession has a closing bracket)")),(0,i.kt)("p",null,"If you are using a Plain Scala app, you will need to manually run it e.g. using zio.Runtime"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"}," Runtime.default.unsafeRun(MyZioContext.run(query[Person]).provideCustomLayer(zioSessionLayer))\n")),(0,i.kt)("h4",{id:"dao-helper-1"},"DAO helper"),(0,i.kt)("p",null,"One additional useful pattern is to use ",(0,i.kt)("inlineCode",{parentName:"p"},"import io.getquill.context.qzio.ImplicitSyntax.Implicit")," to provide\nan implicit CassandraZioSession to one or multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"run(qry)")," calls in a context. This is very useful when creating\nDAO patterns that will reuse a CassandraZioSession many times:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class MyQueryService(cs: CassandraZioSession) {\n  import Ctx._\n  implicit val env = Implicit(Has(cs))\n\n  def joes = Ctx.run { query[Person].filter(p => p.name == "Joe") }.implicitly\n  def jills = Ctx.run { query[Person].filter(p => p.name == "Jill") }.implicitly\n  def alexes = Ctx.run { query[Person].filter(p => p.name == "Alex") }.implicitly\n}\n')),(0,i.kt)("p",null,"More examples of a Quill-Cassandra-ZIO app ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/getquill/quill/tree/master/quill-cassandra-zio/src/test/scala/io/getquill/context/cassandra/zio/examples"},"quill-cassandra-zio/src/test/scala/io/getquill/context/cassandra/zio/examples"),"."),(0,i.kt)("h4",{id:"sbt-dependencies-27"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "io.getquill" %% "quill-cassandra-zio" % "4.6.1"\n)\n')),(0,i.kt)("h2",{id:"quill-cassandra-monix"},"quill-cassandra-monix"),(0,i.kt)("h4",{id:"sbt-dependencies-28"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "io.getquill" %% "quill-cassandra-monix" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"monix-context"},"monix context"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new CassandraMonixContext(SnakeCase, "ctx")\n')),(0,i.kt)("h4",{id:"stream-context"},"stream context"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new CassandraStreamContext(SnakeCase, "ctx")\n')),(0,i.kt)("h2",{id:"quill-cassandra-alpakka"},"quill-cassandra-alpakka"),(0,i.kt)("h4",{id:"sbt-dependencies-29"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "io.getquill" %% "quill-cassandra-alpakka" % "4.6.1"\n)\n')),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"https://doc.akka.io/docs/alpakka/current/cassandra.html"},"Alpakka Cassandra")," documentation page for more information."),(0,i.kt)("h4",{id:"context"},"context"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import akka.actor.ActorSystem\nimport akka.stream.alpakka.cassandra.CassandraSessionSettings\nimport akka.stream.alpakka.cassandra.scaladsl.{CassandraSession, CassandraSessionRegistry}\nimport io.getquill.CassandraAlpakkaContext\n\nval system: ActorSystem = ???\nval alpakkaSessionSettings = CassandraSessionSettings("quill-test.alpakka.cassandra")\nval alpakkaSession: CassandraSession = CassandraSessionRegistry.get(system).sessionFor(alpakkaSessionSettings)\n\nlazy val ctx = new CassandraAlpakkaContext(SnakeCase, alpakkaSession, preparedStatementCacheSize = 100)\n')),(0,i.kt)("h4",{id:"applicationproperties-28"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'// alpakka cassandra session with keyspace\nquill-test.alpakka.cassandra: ${alpakka.cassandra} { // inheritance of alpakka.cassandra session configuration\n  // custom datastax driver setup\n  datastax-java-driver-config = quill-test-datastax-java-driver\n}\n\nquill-test-datastax-java-driver {\n  basic {\n    // keyspace at datastax driver setup, as there is not different option now\n    session-keyspace = "quill_test"\n  }\n}\n')),(0,i.kt)("h2",{id:"orientdb-contexts"},"OrientDB Contexts"),(0,i.kt)("h4",{id:"sbt-dependencies-30"},"sbt dependencies"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'libraryDependencies ++= Seq(\n  "io.getquill" %% "quill-orientdb" % "4.6.1"\n)\n')),(0,i.kt)("h4",{id:"synchronous-context-1"},"synchronous context"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val ctx = new OrientDBSyncContext(SnakeCase, "ctx")\n')),(0,i.kt)("p",null,"The configurations are set using ",(0,i.kt)("a",{parentName:"p",href:"http://orientdb.com/javadoc/latest/com/orientechnologies/orient/core/db/OPartitionedDatabasePool.html"},(0,i.kt)("inlineCode",{parentName:"a"},"OPartitionedDatabasePool"))," which creates a pool of DB connections from which an instance of connection can be acquired. It is possible to set DB credentials using the parameter called ",(0,i.kt)("inlineCode",{parentName:"p"},"username")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"password"),"."),(0,i.kt)("h4",{id:"applicationproperties-29"},"application.properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ctx.dbUrl=remote:127.0.0.1:2424/GratefulDeadConcerts\nctx.username=root\nctx.password=root\n")))}u.isMDXComponent=!0}}]);