"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[31869],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>c});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},m="mdxType",k={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},s=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,o=e.parentName,u=d(e,["components","mdxType","originalType","parentName"]),m=p(n),s=l,c=m["".concat(o,".").concat(s)]||m[s]||k[s]||r;return n?a.createElement(c,i(i({ref:t},u),{},{components:n})):a.createElement(c,i({ref:t},u))}));function c(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=s;var d={};for(var o in t)hasOwnProperty.call(t,o)&&(d[o]=t[o]);d.originalType=e,d[m]="string"==typeof e?e:l,i[1]=d;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}s.displayName="MDXCreateElement"},74495:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>k,frontMatter:()=>r,metadata:()=>d,toc:()=>p});var a=n(87462),l=(n(67294),n(3905));const r={id:"combinators",title:"Schedule Combinators"},i=void 0,d={unversionedId:"reference/schedule/combinators",id:"reference/schedule/combinators",title:"Schedule Combinators",description:"Schedules define stateful, possibly effectful, recurring schedules of events, and compose in a variety of ways. Combinators allow us to take schedules and combine them together to get other schedules and if we have combinators with just the right properties. Then in theory we should be able to solve an infinite number of problems, with only a few combinators and few base schedules.",source:"@site/docs/reference/schedule/combinators.md",sourceDirName:"reference/schedule",slug:"/reference/schedule/combinators",permalink:"/reference/schedule/combinators",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/schedule/combinators.md",tags:[],version:"current",frontMatter:{id:"combinators",title:"Schedule Combinators"},sidebar:"reference-sidebar",previous:{title:"Built-in Schedules",permalink:"/reference/schedule/built-in-schedules"},next:{title:"Examples",permalink:"/reference/schedule/examples"}},o={},p=[{value:"Composition",id:"composition",level:2},{value:"Union",id:"union",level:3},{value:"Intersection",id:"intersection",level:3},{value:"Sequencing",id:"sequencing",level:3},{value:"Piping",id:"piping",level:2},{value:"Jittering",id:"jittering",level:2},{value:"Collecting",id:"collecting",level:2},{value:"Filtering",id:"filtering",level:2},{value:"Mapping",id:"mapping",level:2},{value:"Left/Right Ap",id:"leftright-ap",level:2},{value:"Modifying",id:"modifying",level:2},{value:"Tapping",id:"tapping",level:2}],u={toc:p},m="wrapper";function k(e){let{components:t,...n}=e;return(0,l.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Schedules define stateful, possibly effectful, recurring schedules of events, and compose in a variety of ways. Combinators allow us to take schedules and combine them together to get other schedules and if we have combinators with just the right properties. Then in theory we should be able to solve an infinite number of problems, with only a few combinators and few base schedules."),(0,l.kt)("h2",{id:"composition"},"Composition"),(0,l.kt)("p",null,"Schedules compose in the following primary ways:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Union"),". This performs the union of the intervals of two schedules."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Intersection"),". This performs the intersection of the intervals of two schedules."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Sequencing"),". This concatenates the intervals of one schedule onto another.")),(0,l.kt)("h3",{id:"union"},"Union"),(0,l.kt)("p",null,"Combines two schedules through union, by recurring if either schedule wants to\nrecur, using the minimum of the two delays between recurrences."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null}),(0,l.kt)("th",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"th"},"s1")),(0,l.kt)("th",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"th"},"s2")),(0,l.kt)("th",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"th"},"s1")," ","|"," ","|"," ",(0,l.kt)("inlineCode",{parentName:"th"},"s2")))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Type"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[R, A, B]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[R, A, C]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[R, A, (B, C)]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Continue: ",(0,l.kt)("inlineCode",{parentName:"td"},"Boolean")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"b1")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"b2")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"b1")," ","|"," ","|"," ",(0,l.kt)("inlineCode",{parentName:"td"},"b2"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Delay: ",(0,l.kt)("inlineCode",{parentName:"td"},"Duration")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"d1")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"d2")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"d1.min(d2)"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Emit: ",(0,l.kt)("inlineCode",{parentName:"td"},"(A, B)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"a")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"b")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(a, b)"))))),(0,l.kt)("p",null,"We can combine two schedule through union with ",(0,l.kt)("inlineCode",{parentName:"p"},"||")," operator:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val expCapped = Schedule.exponential(100.milliseconds) || Schedule.spaced(1.second)\n")),(0,l.kt)("h3",{id:"intersection"},"Intersection"),(0,l.kt)("p",null,"Combines two schedules through the intersection, by recurring only if both schedules want to recur, using the maximum of the two delays between recurrences."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null}),(0,l.kt)("th",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"th"},"s1")),(0,l.kt)("th",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"th"},"s2")),(0,l.kt)("th",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"th"},"s1 && s2")))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Type"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[R, A, B]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[R, A, C]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[R, A, (B, C)]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Continue: ",(0,l.kt)("inlineCode",{parentName:"td"},"Boolean")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"b1")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"b2")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"b1 && b2"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Delay: ",(0,l.kt)("inlineCode",{parentName:"td"},"Duration")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"d1")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"d2")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"d1.max(d2)"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Emit: ",(0,l.kt)("inlineCode",{parentName:"td"},"(A, B)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"a")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"b")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(a, b)"))))),(0,l.kt)("p",null,"We can intersect two schedule with ",(0,l.kt)("inlineCode",{parentName:"p"},"&&")," operator:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val expUpTo10 = Schedule.exponential(1.second) && Schedule.recurs(10)\n")),(0,l.kt)("h3",{id:"sequencing"},"Sequencing"),(0,l.kt)("p",null,"Combines two schedules sequentially, by following the first policy until it ends, and then following the second policy."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null}),(0,l.kt)("th",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"th"},"s1")),(0,l.kt)("th",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"th"},"s2")),(0,l.kt)("th",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"th"},"s1 andThen s2")))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Type"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[R, A, B]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[R, A, C]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[R, A, C]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Delay: ",(0,l.kt)("inlineCode",{parentName:"td"},"Duration")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"d1")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"d2")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"d1 + d2"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Emit: ",(0,l.kt)("inlineCode",{parentName:"td"},"B")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"a")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"b")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"b"))))),(0,l.kt)("p",null,"We can sequence two schedule by using ",(0,l.kt)("inlineCode",{parentName:"p"},"andThen"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val sequential = Schedule.recurs(10) andThen Schedule.spaced(1.second)\n")),(0,l.kt)("h2",{id:"piping"},"Piping"),(0,l.kt)("p",null,"Combine two schedules by piping the output of the first schedule to the input of the other. Effects described by the first schedule will always be executed before the effects described by the second schedule."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null}),(0,l.kt)("th",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"th"},"s1")),(0,l.kt)("th",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"th"},"s2")),(0,l.kt)("th",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"th"},"s1 >>> s2")))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Type"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[R, A, B]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[R, B, C]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[R, A, C]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Delay: ",(0,l.kt)("inlineCode",{parentName:"td"},"Duration")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"d1")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"d2")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"d1 + d2"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Emit: ",(0,l.kt)("inlineCode",{parentName:"td"},"B")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"a")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"b")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"b"))))),(0,l.kt)("p",null,"We can pipe two schedule by using ",(0,l.kt)("inlineCode",{parentName:"p"},">>>")," operator:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val totalElapsed = Schedule.spaced(1.second) <* Schedule.recurs(5) >>> Schedule.elapsed\n")),(0,l.kt)("h2",{id:"jittering"},"Jittering"),(0,l.kt)("p",null,"A ",(0,l.kt)("inlineCode",{parentName:"p"},"jittered")," is a combinator that takes one schedule and returns another schedule of the same type except for the delay which is applied randomly:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Function"),(0,l.kt)("th",{parentName:"tr",align:null},"Input Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Output Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"jittered")),(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[Env with Random, In, Out]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"jittered")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"min: Double, max: Double")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[Env with Random, In, Out]"))))),(0,l.kt)("p",null,"We can jitter any schedule by calling ",(0,l.kt)("inlineCode",{parentName:"p"},"jittered")," on it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val jitteredExp = Schedule.exponential(10.milliseconds).jittered\n")),(0,l.kt)("p",null,"When a resource is out of service due to overload or contention, retrying and backing off doesn't help us. If all failed API calls are backed off to the same point of time, they cause another overload or contention. Jitter adds some amount of randomness to the delay of the schedule. This helps us to avoid ending up accidentally synchronizing and taking the service down by accident."),(0,l.kt)("p",null,"The form with parameters ",(0,l.kt)("inlineCode",{parentName:"p"},"min")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"max")," creates a new schedule where the new interval size is randomly distributed between ",(0,l.kt)("inlineCode",{parentName:"p"},"min * old interval")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"max * old interval"),"."),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/"},"Research")," shows that ",(0,l.kt)("inlineCode",{parentName:"p"},"Schedule.jittered(0.0, 1.0)")," is very suitable for retrying."),(0,l.kt)("h2",{id:"collecting"},"Collecting"),(0,l.kt)("p",null,"A ",(0,l.kt)("inlineCode",{parentName:"p"},"collectAll")," is a combinator that when we call it on a schedule, produces a new schedule that collects the outputs of the first schedule into a chunk."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Function"),(0,l.kt)("th",{parentName:"tr",align:null},"Input Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Output Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"collectAll")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[Env, In, Out]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[Env, In, Chunk[Out]]"))))),(0,l.kt)("p",null,"In the following example, we are catching all recurrence of schedule into ",(0,l.kt)("inlineCode",{parentName:"p"},"Chunk"),", so at the end, it would contain ",(0,l.kt)("inlineCode",{parentName:"p"},"Chunk(0, 1, 2, 3, 4)"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val collect = Schedule.recurs(5).collectAll\n")),(0,l.kt)("h2",{id:"filtering"},"Filtering"),(0,l.kt)("p",null,"We can filter inputs or outputs of a schedule with ",(0,l.kt)("inlineCode",{parentName:"p"},"whileInput")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"whileOutput"),". Alse ZIO schedule has an effectful version of these two functions, ",(0,l.kt)("inlineCode",{parentName:"p"},"whileInputZIO")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"whileOutputZIO"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Function"),(0,l.kt)("th",{parentName:"tr",align:null},"Input Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Output Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"whileInput")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"In1 => Boolean")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[Env, In1, Out]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"whileOutput")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Out => Boolean")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[Env, In, Out]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"whileInputZIO")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"In1 => URIO[Env1, Boolean]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[Env1, In1, Out]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"whileOutputZIO")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Out => URIO[Env1, Boolean]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[Env1, In, Out]"))))),(0,l.kt)("p",null,"In following example we collect all emiting outputs before reaching the 5 output, so it would return ",(0,l.kt)("inlineCode",{parentName:"p"},"Chunk(0, 1, 2, 3, 4)"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val res = Schedule.unfold(0)(_ + 1).whileOutput(_ < 5).collectAll\n")),(0,l.kt)("h2",{id:"mapping"},"Mapping"),(0,l.kt)("p",null,"There are two versions for mapping schedules, ",(0,l.kt)("inlineCode",{parentName:"p"},"map")," and its effectful version ",(0,l.kt)("inlineCode",{parentName:"p"},"mapZIO"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Function"),(0,l.kt)("th",{parentName:"tr",align:null},"Input Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Output Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"map")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"f: Out => Out2")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[Env, In, Out2]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"mapZIO")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"f: Out => URIO[Env1, Out2]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Schedule[Env1, In, Out2]"))))),(0,l.kt)("h2",{id:"leftright-ap"},"Left/Right Ap"),(0,l.kt)("p",null,"Sometimes when we intersect two schedules with the ",(0,l.kt)("inlineCode",{parentName:"p"},"&&")," operator, we just need to ignore the left or the right output."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"*>")," ignore the left output"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"<*")," ignore the right output")))),(0,l.kt)("h2",{id:"modifying"},"Modifying"),(0,l.kt)("p",null,"Modifies the delay of a schedule:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val boosted = Schedule.spaced(1.second).delayed(_ => 100.milliseconds)\n")),(0,l.kt)("h2",{id:"tapping"},"Tapping"),(0,l.kt)("p",null,"Whenever we need to effectfully process each schedule input/output, we can use ",(0,l.kt)("inlineCode",{parentName:"p"},"tapInput")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"tapOutput"),"."),(0,l.kt)("p",null,"We can use these two functions for logging purposes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'val tappedSchedule = Schedule.count.whileOutput(_ < 5).tapOutput(o => Console.printLine(s"retrying $o").orDie)\n')))}k.isMDXComponent=!0}}]);