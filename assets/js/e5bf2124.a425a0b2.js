"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[66390],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>d});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=p(a),h=o,d=m["".concat(l,".").concat(h)]||m[h]||u[h]||s;return a?n.createElement(d,r(r({ref:t},c),{},{components:a})):n.createElement(d,r({ref:t},c))}));function d(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=a.length,r=new Array(s);r[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[m]="string"==typeof e?e:o,r[1]=i;for(var p=2;p<s;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},7883:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>p});var n=a(87462),o=(a(67294),a(3905));const s={id:"index",title:"Introduction to ZIO Constraintless",sidebar_label:"ZIO Constraintless"},r=void 0,i={unversionedId:"zio-constraintless/index",id:"zio-constraintless/index",title:"Introduction to ZIO Constraintless",description:"ZIO Constraintless allows you to build programs as mere descriptions with maximum polymorphism, maximum modularity, zero abstraction leakage, and zero casting.",source:"@site/docs/zio-constraintless/index.md",sourceDirName:"zio-constraintless",slug:"/zio-constraintless/",permalink:"/zio-constraintless/",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-constraintless/index.md",tags:[],version:"current",frontMatter:{id:"index",title:"Introduction to ZIO Constraintless",sidebar_label:"ZIO Constraintless"},sidebar:"ecosystem-sidebar",previous:{title:"S3 Connector",permalink:"/zio-connect/s3-connector"},next:{title:"ZIO Crypto",permalink:"/zio-crypto/"}},l={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Installation",id:"installation",level:2},{value:"Example",id:"example",level:2},{value:"Context",id:"context",level:2},{value:"Why not the Hughes schema?",id:"why-not-the-hughes-schema",level:2}],c={toc:p},m="wrapper";function u(e){let{components:t,...a}=e;return(0,o.kt)(m,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"ZIO Constraintless allows you to build programs as mere descriptions with maximum polymorphism, maximum modularity, zero abstraction leakage, and zero casting."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/zio/zio/wiki/Project-Stages"},(0,o.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/Project%20Stage-Development-green.svg",alt:"Development"}))," ",(0,o.kt)("img",{parentName:"p",src:"https://github.com/zio/zio-constraintless/workflows/Website/badge.svg",alt:"CI Badge"})," ",(0,o.kt)("a",{parentName:"p",href:"https://oss.sonatype.org/content/repositories/releases/dev/zio/zio-constraintless_2.13/"},(0,o.kt)("img",{parentName:"a",src:"https://img.shields.io/nexus/r/https/oss.sonatype.org/dev.zio/zio-constraintless_2.13.svg?label=Sonatype%20Release",alt:"Sonatype Releases"}))," ",(0,o.kt)("a",{parentName:"p",href:"https://oss.sonatype.org/content/repositories/snapshots/dev/zio/zio-constraintless_2.13/"},(0,o.kt)("img",{parentName:"a",src:"https://img.shields.io/nexus/s/https/oss.sonatype.org/dev.zio/zio-constraintless_2.13.svg?label=Sonatype%20Snapshot",alt:"Sonatype Snapshots"}))," ",(0,o.kt)("a",{parentName:"p",href:"https://javadoc.io/doc/dev.zio/zio-constraintless-docs_2.13"},(0,o.kt)("img",{parentName:"a",src:"https://javadoc.io/badge2/dev.zio/zio-constraintless-docs_2.13/javadoc.svg",alt:"javadoc"}))," ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/zio/zio-constraintless"},(0,o.kt)("img",{parentName:"a",src:"https://img.shields.io/github/stars/zio/zio-constraintless?style=social",alt:"ZIO Constraintless"}))),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"It is ",(0,o.kt)("strong",{parentName:"p"},"a Scala take on the following paper in Haskell, on parametrising the program with logical constraints at every node, without compromising modularity")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"http://www.doc.ic.ac.uk/~wlj05/files/Deconstraining.pdf"},"http://www.doc.ic.ac.uk/~wlj05/files/Deconstraining.pdf")),(0,o.kt)("p",null,"An excerpt from the paper:"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},'"The key principle that underpins our idea is that implementation- specific constraints should be imposed at the point of use of a data type, not at the point of definition, i.e. it embodies the established principle that an interface should be separated from its implementation(s)."')),(0,o.kt)("h2",{id:"installation"},"Installation"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sbt"},'libraryDependencies += "dev.zio" %% "constraintless" % "0.3.2"\n')),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("p",null,"Example: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/zio/zio-constraintless/blob/master/examples/src/main/scala/zio/constraintless/examples/Expr.scala"},"https://github.com/zio/zio-constraintless/blob/master/examples/src/main/scala/zio/constraintless/examples/Expr.scala")),(0,o.kt)("h2",{id:"context"},"Context"),(0,o.kt)("p",null,'The key to many inspectable programs such as an execution planner, a configuration DSL etc is the basic concept of "programs as descriptions", but this idea comes with limitations.'),(0,o.kt)("p",null,"This description (or data) can easily turn out to be a Generalised ADT that can be recursive, such that compiler has to traverse through the unknown types (existential) and for the compiler to do any advanced/useful stuff with it, it needs to know more about these types."),(0,o.kt)("p",null,'The obvious implication of having to handle "unknown" is that, the data should hold on to informations as constraints (that are relevant to implementation) on types at the definition site. A possible solution is to compromise on parametric polymorphism, or fall back to relying unsafe/safe (relative) casting (asInstanceOf).'),(0,o.kt)("p",null,"This naive approach imposes modularity issues, and possible runtime crashes. The reasonsing and solution is given in the above paper, and this project solves the exact problem in scala."),(0,o.kt)("h2",{id:"why-not-the-hughes-schema"},"Why not the Hughes schema?"),(0,o.kt)("p",null,"It doesn't allow you to have a compiler with multiple constraints."),(0,o.kt)("p",null,"A few excerpts from the paper on why it doesn't work:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"class Typeable p a valueP :: a \u2192 p a\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"newtype SM a = SM {fromSM :: Int}\n\ninstance IntBool a \u21d2 Typeable SM a where\n  valueP = SM \xb7 toInt\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"newtype Pretty a = Pretty {fromPretty :: String}\n\ninstance Show a \u21d2 Typeable Pretty a where valueP = Pretty \xb7 show\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"data Exp p a where\nValueE::Typeable p a \u21d2 a \u2192 Exp p a\n\nCondE ::Expp Bool\u2192Exp p a \u2192 Exp p a \u2192 Exp p a \n\nEqE :: Eq a \u21d2 Exp p a \u2192 Exp p a \u2192 Exp p Bool\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"pretty :: Exp Pretty a \u2192 String // works\ncompileSM :: Exp SM a \u2192 String // works\n")),(0,o.kt)("p",null,"However, now suppose that we wish to apply the two functions to the same expression, as in:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"f :: Exp p a \u2192 . . .\nf e = ...(compileSM e)...(pretty e)..\n")),(0,o.kt)("p",null,"and that's impossible"))}u.isMDXComponent=!0}}]);