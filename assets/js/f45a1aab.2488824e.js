"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[80447],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},f="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),f=p(n),u=i,h=f["".concat(s,".").concat(u)]||f[u]||c[u]||r;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[f]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},88297:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={id:"fiberref",title:"FiberRef: Introduction to Fiber-local Storage",sidebar_label:"FiberRef"},o=void 0,l={unversionedId:"reference/state-management/fiberref",id:"reference/state-management/fiberref",title:"FiberRef: Introduction to Fiber-local Storage",description:"FiberRef is a data structure for managing and accessing thread-local values within a ZIO fiber. Thread-local storage (TLS) is a mechanism that provides each fiber its own separate storage space. A FiberRef[A] is a specialized type of mutable reference (Ref[A]) that allows us to store and retrieve values of type A that are local to a specific fiber.",source:"@site/docs/reference/state-management/fiberref.md",sourceDirName:"reference/state-management",slug:"/reference/state-management/fiberref",permalink:"/reference/state-management/fiberref",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/state-management/fiberref.md",tags:[],version:"current",frontMatter:{id:"fiberref",title:"FiberRef: Introduction to Fiber-local Storage",sidebar_label:"FiberRef"},sidebar:"reference-sidebar",previous:{title:"Fiber-local State",permalink:"/reference/state-management/fiber-local-state"},next:{title:"ZState",permalink:"/reference/state-management/zstate"}},s={},p=[{value:"Motivation",id:"motivation",level:2},{value:"Solution",id:"solution",level:2},{value:"Solution 1: ZIO Environment",id:"solution-1-zio-environment",level:3},{value:"Solution 2: FiberRef",id:"solution-2-fiberref",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"Operations",id:"operations",level:2},{value:"<code>Ref</code> vs. <code>FiberRef</code>",id:"ref-vs-fiberref",level:2},{value:"Propagation",id:"propagation",level:2},{value:"Copy-on-Fork",id:"copy-on-fork",level:3},{value:"Merging FiberRefs",id:"merging-fiberrefs",level:2},{value:"join",id:"join",level:3},{value:"join with Custom Merge",id:"join-with-custom-merge",level:3},{value:"await",id:"await",level:3},{value:"inheritAll",id:"inheritall",level:3},{value:"Compositional Updates and Patch Theory",id:"compositional-updates-and-patch-theory",level:2},{value:"The Problem",id:"the-problem",level:3},{value:"Differ and Patch",id:"differ-and-patch",level:3},{value:"First Solution: Compositional Updates For <code>Map[String, Int]</code> Data Type",id:"first-solution-compositional-updates-for-mapstring-int-data-type",level:3},{value:"Second Solution: Compositional Updates For The <code>RetryConfig</code> Case Class",id:"second-solution-compositional-updates-for-the-retryconfig-case-class",level:3}],d={toc:p},f="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(f,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," is a data structure for managing and accessing thread-local values within a ZIO fiber. Thread-local storage (TLS) is a mechanism that provides each fiber its own separate storage space. A ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef[A]")," is a specialized type of mutable reference (",(0,i.kt)("inlineCode",{parentName:"p"},"Ref[A]"),") that allows us to store and retrieve values of type ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," that are local to a specific fiber.  "),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," data structure allows us to perform operations such as reading the current value, updating the value, or modifying the value atomically within a fiber. It ensures thread-safety and isolation between different fibers, allowing them to have their own independent values for the ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),". Each fiber maintains its own copy of the fiber-specific variable, and modifications to the variable made by one fiber do not affect the values seen by other fibers."),(0,i.kt)("p",null,"By using ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),", we can maintain per-fiber context or state information, which can be useful in various scenarios such as managing resources, tracking application-specific information, or carrying contextual data throughout the execution of a fiber."),(0,i.kt)("p",null,"We can think of ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," as Java's ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal")," on steroids. So, just like we have ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal")," in Java we have ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," in ZIO. So as different threads have different ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal"),"s, we can say different fibers have different ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),"s. They don't intersect or overlap in any way. ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," is the fiber version of ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal")," with significant improvements in its semantics. A ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal")," only has a mutable state in which each thread accesses its own copy, but threads don't propagate their state to their children's."),(0,i.kt)("p",null,"As opposed to ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref[A]"),", the value of a ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef[A]")," is bound to an executing fiber. Different fibers who hold the same ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef[A]")," can independently set and retrieve values of the reference, without collisions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nfor {\n  fiberRef <- FiberRef.make[Int](0)\n  _        <- fiberRef.set(10)\n  v        <- fiberRef.get\n} yield v == 10\n")),(0,i.kt)("h2",{id:"motivation"},"Motivation"),(0,i.kt)("p",null,"Whenever we have some kind of scoped information or context, and we don't want to use the ZIO environment to store it, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," to store it."),(0,i.kt)("p",null,"To illustrate this, let's try to find a solution to the ",(0,i.kt)("em",{parentName:"p"},"Structured Logging")," problem. In structured logging, we tend to attach contextual information to log messages, such as user id, correlation id, log level, and so on."),(0,i.kt)("p",null,"So assume we have written the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nfor {\n  _ <- Logging.log("Hello World!")\n  _ <- ZIO.foreachParDiscard(List("Jane", "John")) { name =>\n    Logging.logAnnotate("name", name) {\n      for {\n        _ <- Logging.log(s"Received request")\n        fiberId <- ZIO.fiberId.map(_.ids.head)\n        _ <- Logging.logAnnotate("fiber_id", s"$fiberId")(\n          Logging.log("Processing request")\n        )\n        _ <- Logging.log("Finished processing request")\n      } yield ()\n    }\n  }\n  _ <- Logging.log("All requests processed")\n} yield ()\n')),(0,i.kt)("p",null,"We would like to see the following log output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"Hello World!\n[name=Jane] Received request\n[name=John] Received request\n[name=Jane] [fiber_id=7] Processing request\n[name=John] [fiber_id=8] Processing request\n[name=John] Finished processing request\n[name=Jane] Finished processing request\nAll requests processed\n")),(0,i.kt)("p",null,"In the above code, we have two users, ",(0,i.kt)("inlineCode",{parentName:"p"},"Jane")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"John"),", and we want to handle some operations on each user, concurrently. When we perform concurrent operations, we would like to have a way to associate each concurrent operation with its corresponding user and fiber id. So when we log messages, we have all the information available for a specific event."),(0,i.kt)("p",null,"In order to do this, we need a context-aware logging service. This logging service needs to have a ",(0,i.kt)("strong",{parentName:"p"},"state")," that is a place to store annotations. This state can be accessed and modified ",(0,i.kt)("strong",{parentName:"p"},"concurrently")," by multiple fibers. And the important part is that each fiber should have its own isolated copy of the state, so when a fiber modifies the state, it doesn't clobber the state of other fibers."),(0,i.kt)("p",null,"Until now, we can categorize our requirements into two parts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We need a mechanism to carry some contextual information, without explicitly passing it around."),(0,i.kt)("li",{parentName:"ul"},"We need a mechanism to update the state in an isolated fashion, where each fiber can update the state without affecting the state of other fibers.")),(0,i.kt)("h2",{id:"solution"},"Solution"),(0,i.kt)("p",null,"In this section, we will look at two solutions to the problem of structured logging we have mentioned above. The first solution has some limitations and drawbacks, so we will choose the second solution as the final solution."),(0,i.kt)("h3",{id:"solution-1-zio-environment"},"Solution 1: ZIO Environment"),(0,i.kt)("p",null,"One solution is to use the ZIO environment to store the state. It addresses the first requirement, very well. ZIO environment is a nice place to store the contextual states. And to make the state isolated between fibers, we can reintroduce the new state to the environment instead of updating the environment globally:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// Solution 1: Using the ZIO environment to store the contextual state\nimport zio._\n\nobject Logging {\n  type Annotation = Map[String, String]\n\n  def logAnnotate[R, E, A](key: String, value: String)(\n    zio: ZIO[R with Annotation, E, A]\n  ): ZIO[R with Annotation, E, A] = {\n    for {\n      s <- ZIO.service[Annotation]\n      r <- zio.provideSomeLayer[R](ZLayer.succeed(s.updated(key, value)))\n    } yield (r)\n  }\n\n  def log(message: String): ZIO[Annotation, Nothing, Unit] = {\n    ZIO.service[Annotation].flatMap {\n      case annotation if annotation.isEmpty => \n        Console.printLine(message).orDie\n      case annotation =>\n        val line =\n          s"${annotation.map { case (k, v) => s"[$k=$v]" }.mkString(" ")} $message"\n        Console.printLine(line).orDie\n    }\n  }\n}\n')),(0,i.kt)("p",null,"The ZIO environment solution provides an explicit method for ensuring type-safety when dealing with contextual data types. However, this increased type-safety may limit flexibility in certain scenarios. For instance, consider a situation where our workflows require multiple cross-cutting services such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Logging"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Config"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Metrics"),". In this case, every instance of application logic would involve a workflow with a type signature like ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO[Logging & Config & Metrics & ..., IOException, Any]"),". This extensive type declaration restricts easy code refactoring and maintenance, while also distracts our attention from the core business logic. Any modification to the contextual data type necessitates modifying the entire program. "),(0,i.kt)("p",null,"Although we successfully utilized the ZIO environment in the previous example to store the state, it is not considered the idiomatic solution. It is preferable to avoid explicitly exposing the type of the state, in this case ",(0,i.kt)("inlineCode",{parentName:"p"},"Annotation"),", within the environment."),(0,i.kt)("p",null,"Anyway, despite these limitations, this solution proves especially beneficial when"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"When the contextual service holds a ",(0,i.kt)("strong",{parentName:"li"},"crucial role")," in the workflow logic"),(0,i.kt)("li",{parentName:"ul"},"When there is a requirement for ensuring *type-safety on the service type** within the ZIO environment"),(0,i.kt)("li",{parentName:"ul"},"When there is no sensible ",(0,i.kt)("strong",{parentName:"li"},"default value")," for such services")),(0,i.kt)("h3",{id:"solution-2-fiberref"},"Solution 2: FiberRef"),(0,i.kt)("p",null,"The other solution is to use ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),". FiberRef is a nice way to store the contextual states and make them isolated. Any state maintained by a ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," will be isolated between fibers. Also, a nice thing about ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," is that we do not require to place the state in the environment."),(0,i.kt)("p",null,"Let's see how to use ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," to implement the logging service:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'// Solution 2: Using the FiberRef to store the contextual state\nimport zio._\n\ntrait Logger {\n  def logAnnotate[R, E, A](key: String, value: String)(\n      zio: ZIO[R, E, A]\n  ): ZIO[R, E, A]\n  def log(message: String): UIO[Unit]\n}\n\nobject Logging extends Logger {\n  def logAnnotate[R, E, A](key: String, value: String)(\n      zio: ZIO[R, E, A]\n  ): ZIO[R, E, A] = currentAnnotations.locallyWith(_.updated(key, value))(zio)\n\n  def log(message: String): UIO[Unit] = {\n    currentAnnotations.get.flatMap {\n      case annotation if annotation.isEmpty =>\n        Console.printLine(message).orDie\n      case annotation =>\n        val line =\n          s"${annotation.map { case (k, v) => s"[$k=$v]" }.mkString(" ")} $message"\n        Console.printLine(line).orDie\n    }\n  }\n\n  val currentAnnotations: FiberRef[Map[String, String]] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.make(Map.empty[String, String])\n    }\n\n}\n')),(0,i.kt)("p",null,"Now we can write a program that logs some information:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject FiberRefLoggingExample extends ZIOAppDefault {\n  def run =\n    for {\n      _ <- Logging.log("Hello World!")\n      _ <- ZIO.foreachParDiscard(List("Jane", "John")) { name =>\n        Logging.logAnnotate("name", name) {\n          for {\n            _       <- Logging.log(s"Received request")\n            fiberId <- ZIO.fiberId.map(_.ids.head)\n            _ <- Logging.logAnnotate("fiber_id", s"$fiberId")(\n              Logging.log("Processing request")\n            )\n            _ <- Logging.log("Finished processing request")\n          } yield ()\n        }\n      }\n      _ <- Logging.log("All requests processed")\n    } yield ()\n}\n')),(0,i.kt)("p",null,"The output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"Hello World!\n[name=Jane] Received request\n[name=John] Received request\n[name=Jane] [fiber_id=5] Processing request\n[name=John] [fiber_id=6] Processing request\n[name=John] Finished processing request\n  [name=Jane] Finished processing request\nAll requests processed\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Note:")),(0,i.kt)("p",{parentName:"blockquote"},"In the above solution, if we replace the ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref"),", the program will not work properly, because the ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref")," is not isolated. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref")," will be shared between all fibers, so each fiber clobbers the other fibers' state.")),(0,i.kt)("p",null,"To take it a step further, let's modify the previous example to allow the user to change the underlying logging service:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ntrait Logger {\n  def logAnnotate[R, E, A](key: String, value: String)(\n    zio: ZIO[R, E, A]\n  ): ZIO[R, E, A]\n\n  def log(message: String): UIO[Unit]\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject Logging {\n\n  val defaultLogger: Logger = new Logger {\n    def logAnnotate[R, E, A](key: String, value: String)(\n      zio: ZIO[R, E, A]\n    ): ZIO[R, E, A] = currentAnnotations.locallyWith(_.updated(key, value))(zio)\n\n    def log(message: String): UIO[Unit] = {\n      currentAnnotations.get.flatMap {\n        case annotation if annotation.isEmpty =>\n          Console.printLine(message).orDie\n        case annotation =>\n          val line =\n            s"${annotation.map { case (k, v) => s"[$k=$v]" }.mkString(" ")} $message"\n          Console.printLine(line).orDie\n      }\n    }\n  }\n\n  val silentLogger: Logger = new Logger {\n    def logAnnotate[R, E, A](key: String, value: String)(\n      zio: ZIO[R, E, A]\n    ): ZIO[R, E, A] = currentAnnotations.locallyWith(_.updated(key, value))(zio)\n\n    def log(message: String): UIO[Unit] = ZIO.unit\n  }\n\n  def log(message: String): ZIO[Any, Nothing, Unit] =\n    currentLogger.get.flatMap(_.log(message))\n\n  def logAnnotate[R, E, A](key: String, value: String)(\n    zio: ZIO[R, E, A]\n  ): ZIO[R, E, A] = currentLogger.get.flatMap(_.logAnnotate(key, value)(zio))\n\n  def locallyWithLogger[R, E, A](newLogger: Logger)(zio: ZIO[R, E, A]) = {\n    currentLogger.locallyWith(_ => newLogger)(zio)\n  }\n\n  def updateLogger(logger: Logger => Logger): UIO[Unit] = currentLogger.update(logger)\n\n  val currentLogger: FiberRef[Logger] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.make(defaultLogger)\n    }\n\n  val currentAnnotations: FiberRef[Map[String, String]] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.make(Map.empty[String, String])\n    }\n\n}\n')),(0,i.kt)("p",null,"Now, changing the default logger is made easy with the Logging.withLogger function. Let's disable the default logger for a specific section of our example by utilizing Logging.silentLogger:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject FiberRefChangeDefaultLoggerExample extends ZIOAppDefault {\n  def run = for {\n    _ <- Logging.log("Hello World!")\n    _ <- ZIO.foreachParDiscard(List("Jane", "John")) { name =>\n      Logging.locallyWithLogger(Logging.silentLogger) {\n        Logging.logAnnotate("name", name) {\n          for {\n            _ <- Logging.log(s"Received request")\n            fiberId <- ZIO.fiberId.map(_.ids.head)\n            _ <- Logging.logAnnotate("fiber_id", s"$fiberId")(\n              Logging.log("Processing request")\n            )\n            _ <- Logging.log("Finished processing request")\n          } yield ()\n        }\n      }\n    }\n    _ <- Logging.log("All requests processed")\n  } yield ()\n}\n')),(0,i.kt)("p",null,"The output is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"Hello World!\nAll requests processed\n")),(0,i.kt)("p",null,"The solution provided by ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," offers an ",(0,i.kt)("strong",{parentName:"p"},"implicit")," method to store and propagate contextual data or service in an untyped manner. It helps us reduce redundancy in environment types. For instance, by encoding the ",(0,i.kt)("inlineCode",{parentName:"p"},"Logging")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Metrics")," services using ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),", we no longer need to include the ",(0,i.kt)("inlineCode",{parentName:"p"},"Logging")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Metrics")," service type in the environment type of ZIO workflows. As a result, we can simplify a ZIO effect from ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO[Logging & Metrics & UserRepo & DocsRepo, IOException, Unit]")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO[UserRepo & DocsRepo, IOException, Unit]"),". This significantly reduces boilerplate code in our workflows, which helps us to focus on maintaining application logic in a flexible manner."),(0,i.kt)("p",null,"Additionally, as demonstrated in the final example, ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," proves to be a valuable solution when we have a ",(0,i.kt)("strong",{parentName:"p"},"default value")," for a contextual service or data. We can start the application with default values and, whenever needed, locally or globally change the underlying service or data using ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef#locallyWith")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef#update"),"."),(0,i.kt)("p",null,"In summary, this solution is particularly advantageous in the following scenarios:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"When ",(0,i.kt)("strong",{parentName:"li"},"encoding cross-cutting services")," without the need to include them everywhere in the ZIO environment."),(0,i.kt)("li",{parentName:"ul"},"When requiring ",(0,i.kt)("strong",{parentName:"li"},"isolated states")," for different fibers."),(0,i.kt)("li",{parentName:"ul"},"When having a ",(0,i.kt)("strong",{parentName:"li"},"default value")," for contextual service or data.")),(0,i.kt)("h2",{id:"use-cases"},"Use Cases"),(0,i.kt)("p",null,"Whenever we have some kind of scoped information or context, we can think about ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," as a way to store that information. "),(0,i.kt)("p",null,"When developing applications, there are several use cases for ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),". Let's take a look at some of them:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Resource management"),": ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," can be utilized to manage resources that are specific to a particular fiber. For example, we can use it to store and access connections to a database or network resources. Each fiber can have its own dedicated resource, ensuring isolation and avoiding contention between different fibers.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Configuration Settings"),": It can be used to store configuration settings that are specific to a fiber. This allows different fibers to have their own configuration values, enabling fine-grained control and customization.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Avoiding Synchronization"),": By using ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),", we can eliminate the need for synchronization mechanisms, such as locks or atomic operations, when accessing fiber-specific data. Each fiber operates on its own private copy, avoiding contention with other fibers.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Distributed Tracing"),"\u2014 In an architecture, where we have highly concurrent workflows and distributed services, there is a need to trace requests as they propagate through the services. To be able to trace requests, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," to design the system to automatically propagate request-scoped information.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Contextual Logging"),"\u2014 In lot of cases, logs are not independent piece of information, but they are part of a larger context. So other than just logging the message, we also need to log some additional information such as the request ID, the user ID, the session id, and so on. So whe we collect these logs, we can correlate them based on a common data point. Instead of explicitly passing these contextual information, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Execution Scoped Configuration"),"\u2014 When we write applications, we would like to make them configurable. So we configure the application once and used it throughout the whole components. Not all configurations are global. There are certain kinds of configurations that are not global, or at least we have a default value for them globally, but we need to change them dynamically for certain regions. ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," is a nice tool to model these kind of configurations."))),(0,i.kt)("p",null,"In ZIO we have several use cases for ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),". Let's discuss some of them:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Whenever we use ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.withParallelism"),", we can specify the parallelism factor for a region of code. So this information will be stored inside a ",(0,i.kt)("inlineCode",{parentName:"li"},"FiberRef"),", without any need to pass it around all effects explicitly. When we exit the region, the parallelism factor will be restored to the original value:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nobject MainApp extends ZIOAppDefault {\n  def myJob(name: String) =\n    ZIO.foreachParDiscard(1 to 3)(i =>\n      ZIO.debug(s"The $name-$i job started") *> ZIO.sleep(2.second)\n    )\n\n  def run =\n    ZIO.withParallelismUnbounded(\n      for {\n        _ <- myJob("foo")\n        _ <- ZIO.debug("------------------")\n        _ <- ZIO.withParallelism(1)(myJob("bar"))\n        _ <- ZIO.debug("------------------")\n        _ <- myJob("baz")\n      } yield ()\n    )\n}\n')),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"Using ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIOAspect.annotated")," we can annotate the effect with some contextual information, e.g. the ",(0,i.kt)("inlineCode",{parentName:"li"},"correlation_id"),". This information will be stored inside a ",(0,i.kt)("inlineCode",{parentName:"li"},"FiberRef"),", which will be propagated to all fibers that are created from the same parent fiber. Each fiber will have its own set of annotations. When we log inside a fiber, the logging service will use the fiber's specific annotations to create the log message:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  def handleRequest(request: String) =\n    for {\n      _ <- ZIO.log(s"Received request.")\n      _ <- ZIO.unit // do something with the request\n      _ <- ZIO.log(s"Finished processing request")\n    } yield ()\n\n  def run =\n    for {\n      _ <- ZIO.log("Hello World!")\n      _ <- ZIO.foreachParDiscard(List(("req1", "1"), ("req2", "2"), ("req3", "3"))){ case (req, id) =>\n        handleRequest(req) @@ ZIOAspect.annotated("correlation_id", id)\n      }\n      _ <- ZIO.log("Goodbye!")\n    } yield ()\n\n}\n')),(0,i.kt)("p",null,"Here is the output (extra columns were removed for better readability):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'message="Hello World!"\nmessage="Received request." correlation_id=2\nmessage="Received request." correlation_id=1\nmessage="Received request." correlation_id=3\nmessage="Finished processing request." correlation_id=3\nmessage="Finished processing request." correlation_id=1\nmessage="Finished processing request." correlation_id=2\nmessage="Goodbye!"\n')),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},"Log levels are also maintained by using ",(0,i.kt)("inlineCode",{parentName:"li"},"FiberRef"),". They are stored inside a ",(0,i.kt)("inlineCode",{parentName:"li"},"FiberRef"),", and whenever we want, we can change the log level using the ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.logLevel")," operator:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nfor {\n  _ <- ZIO.log("Application started!")\n  _ <- ZIO.logLevel(LogLevel.Trace) {\n    for {\n      _ <- ZIO.log("Entering trace log level region")\n      _ <- ZIO.log("Doing something")\n      _ <- ZIO.log("Leaving trace log level region")\n    } yield ()\n  }\n  _ <- ZIO.log("Application ended!")\n} yield ()\n')),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},"The same goes for when we access the environment (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO.service"),"), or when we provide a layer to a ZIO effect (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIO#provide"),"). ZIO uses ",(0,i.kt)("inlineCode",{parentName:"li"},"FiberRef")," under the hood to store the environment:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  private val fooLayer = ZLayer.succeed("foo")\n  private val barLayer = ZLayer.succeed("bar") \n  \n  def run =\n    (for {\n      _ <- ZIO.service[String].debug("context")\n      _ <- ZIO.service[String].debug("context").provide(barLayer)\n      _ <- ZIO.service[String].debug("context")\n    } yield ()).provide(fooLayer)\n}\n')),(0,i.kt)("p",null,"There are several other use cases for ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," in ZIO itself. We just covered some of them to get you some ideas on how they are used in the real world."),(0,i.kt)("h2",{id:"operations"},"Operations"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef[A]")," has an API almost identical to ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref[A]"),". It includes well-known methods such as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"FiberRef#get"),". Returns the current value of the reference."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"FiberRef#set"),". Sets the current value of the reference."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"FiberRef#update")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"FiberRef#updateSome")," updates the value with the specified function."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"FiberRef#modify"),"/ ",(0,i.kt)("inlineCode",{parentName:"li"},"FiberRef#modifySome")," modifies the value with the specified function, computing a return value for the operation.")),(0,i.kt)("p",null,"You can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"locally")," to scope ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," value only for a given effect:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nfor {\n  correlationId <- FiberRef.make[String]("")\n  v1            <- correlationId.locally("my-correlation-id")(correlationId.get)\n  v2            <- correlationId.get\n} yield v1 == "my-correlation-id" && v2 == ""\n')),(0,i.kt)("h2",{id:"ref-vs-fiberref"},(0,i.kt)("inlineCode",{parentName:"h2"},"Ref")," vs. ",(0,i.kt)("inlineCode",{parentName:"h2"},"FiberRef")),(0,i.kt)("p",null,"Let's explore the distinction between ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," through two practical examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject RefExample extends ZIOAppDefault {\n\n  def run =\n    for {\n      ref <- Ref.make(0)\n      left = ref.updateAndGet(_ + 1).debug("left1") *>\n        ref.updateAndGet(_ + 1).debug("left2")\n      right = ref.updateAndGet(_ + 1).debug("right1") *>\n        ref.updateAndGet(_ + 1).debug("right2")\n      _ <- left <&> right\n    } yield ()\n}\n')),(0,i.kt)("p",null,"One potential result of running this program is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"left1: 1\nright1: 2\nleft2: 3\nright2: 6\n")),(0,i.kt)("p",null,"It is apparent that the ",(0,i.kt)("inlineCode",{parentName:"p"},"ref")," is shared between the ",(0,i.kt)("inlineCode",{parentName:"p"},"left")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"right")," fibers. However, when using FiberRef, each fiber has its own separate storage, isolating them from one another:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject FiberRefExample extends ZIOAppDefault {\n  def run =\n    for {\n      ref <- FiberRef.make(0)\n      left = ref.updateAndGet(_ + 1).debug("left1") *>\n        ref.updateAndGet(_ + 1).debug("left2")\n      right = ref.updateAndGet(_ + 1).debug("right1") *>\n        ref.updateAndGet(_ + 3).debug("right2")\n      _ <- left <&> right\n    } yield ()\n}\n')),(0,i.kt)("p",null,"One possible output of this program is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"left1: 1\nright1: 1\nleft2: 2\nright2: 4\n")),(0,i.kt)("p",null,"We can observe that each fiber has its own storage without interfering with the value of another fiber."),(0,i.kt)("h2",{id:"propagation"},"Propagation"),(0,i.kt)("p",null,"Let's go back to the ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),"s analog called ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal")," and see how it works. If we have thread ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," with its ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal")," and thread ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," creates a new thread, let's call it thread ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),". When thread ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," sends thread ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," the same ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal")," then what value does thread ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," see inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal"),"? Well, it sees the default value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal"),". It does not see ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),"s value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal"),". So in other words, ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal"),"s do not propagate their values across the sort of graph of threads so when one thread creates another, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal")," value is not propagated from parent to child."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),"s improve on that model quite dramatically. Basically, whenever a child's fiber is created from its parent, the ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," value of parent fiber propagated to its child fiber."),(0,i.kt)("h3",{id:"copy-on-fork"},"Copy-on-Fork"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef[A]")," has ",(0,i.kt)("em",{parentName:"p"},"copy-on-fork")," semantics for ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO#fork"),". This essentially means that a child ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber")," starts with ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," values of its parent. When the child sets a new value of ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),", the change is visible only to the child itself. The parent fiber still has its own value."),(0,i.kt)("p",null,"So if we create a ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," and set its value to ",(0,i.kt)("inlineCode",{parentName:"p"},"5"),", and we pass this ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," to a child fiber, it sees the value ",(0,i.kt)("inlineCode",{parentName:"p"},"5"),". If the child fiber modifies the value from ",(0,i.kt)("inlineCode",{parentName:"p"},"5")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"6"),", the parent fiber can't see that change. So the child fiber gets its own copy of the ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),", and it can modify it locally. Those changes will not affect the parent fiber:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nfor {\n  fiberRef <- FiberRef.make(5)\n  promise <- Promise.make[Nothing, Int]\n  _ <- fiberRef\n    .updateAndGet(_ => 6)\n    .flatMap(promise.succeed).fork\n  childValue <- promise.await\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 5 && childValue == 6)\n")),(0,i.kt)("h2",{id:"merging-fiberrefs"},"Merging FiberRefs"),(0,i.kt)("p",null,"ZIO does not only support to propagate ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," values from parents to childs, but also to merge back these values into the current fiber. This section describes multiple variants for doing so."),(0,i.kt)("h3",{id:"join"},"join"),(0,i.kt)("p",null,"If we ",(0,i.kt)("inlineCode",{parentName:"p"},"join")," a fiber then the value of its ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," is merged back into the parent fiber. The default strategy for merging back, is ",(0,i.kt)("strong",{parentName:"p"},"replacement"),". This means whenever a forked fiber joined to its parent fiber, the value of its parent will be replaced with the value of its child ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nfor {\n  fiberRef <- FiberRef.make(5)\n  child <- fiberRef.set(6).fork\n  _ <- child.join\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 6)\n")),(0,i.kt)("p",null,"So if we ",(0,i.kt)("inlineCode",{parentName:"p"},"fork")," a fiber and that child fiber modifies a bunch of ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),"s and then later we ",(0,i.kt)("inlineCode",{parentName:"p"},"join")," it, we get those modifications merged back into the parent fiber. So that's the semantic model of ZIO on ",(0,i.kt)("inlineCode",{parentName:"p"},"join"),". "),(0,i.kt)("p",null,"Each fiber has its own ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," and can modify it independently. Therefore, when multiple child fibers ",(0,i.kt)("inlineCode",{parentName:"p"},"join")," their parent, the last child fiber will override the parent's ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," value, replacing it with its own."),(0,i.kt)("p",null,"As we can see, ",(0,i.kt)("inlineCode",{parentName:"p"},"child1")," is the last fiber, so its value, which is ",(0,i.kt)("inlineCode",{parentName:"p"},"6"),", gets merged back into its parent:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nfor {\n  fiberRef <- FiberRef.make(5)\n  child1 <- fiberRef.set(6).fork\n  child2 <- fiberRef.set(7).fork\n  _ <- child2.join\n  _ <- child1.join\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 6)\n")),(0,i.kt)("h3",{id:"join-with-custom-merge"},"join with Custom Merge"),(0,i.kt)("p",null,"Furthermore, we have the ability to customize the initialization of a value when a fiber is forked, as well as the method of value combination when merging back the values. To achieve this, you can specify the desired behavior when making the ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," using ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef#make"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nfor {\n  fiberRef <- FiberRef.make(initial = 0, join = math.max)\n  child    <- fiberRef.update(_ + 1).fork\n  _        <- fiberRef.update(_ + 2)\n  _        <- child.join\n  value    <- fiberRef.get\n} yield assert(value == 2)\n")),(0,i.kt)("p",null,"In this example, when the child fiber joins its parent, it employs the max function to determine how to merge the values. It compares the child's FiberRef value (1) with the parent's FiberRef value (2) and selects the higher value as the merged result, which in this case is 2."),(0,i.kt)("h3",{id:"await"},"await"),(0,i.kt)("p",null,"It is important to note that ",(0,i.kt)("inlineCode",{parentName:"p"},"await")," has no such merge behavior. So ",(0,i.kt)("inlineCode",{parentName:"p"},"await")," waits for the child fiber to finish and gives us its value as an ",(0,i.kt)("inlineCode",{parentName:"p"},"Exit"),", without ever merging any ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," values back into the parent:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nfor {\n  fiberRef <- FiberRef.make(5)\n  child <- fiberRef.set(6).fork\n  _ <- child.await\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 5)\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"join")," has higher-level semantics than ",(0,i.kt)("inlineCode",{parentName:"p"},"await")," because it will fail if the child fiber failed, it will interrupt if the child is interrupted, and it will also merge back its value to its parent."),(0,i.kt)("h3",{id:"inheritall"},"inheritAll"),(0,i.kt)("p",null,"We can inherit the values from all ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),"s from an existing ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber")," using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber#inheritAll")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nfor {\n  fiberRef <- FiberRef.make[Int](0)\n  latch    <- Promise.make[Nothing, Unit]\n  fiber    <- (fiberRef.set(10) *> latch.succeed(())).fork\n  _        <- latch.await\n  _        <- fiber.inheritAll\n  v        <- fiberRef.get\n} yield v == 10\n")),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"inheritAll")," is automatically called on ",(0,i.kt)("inlineCode",{parentName:"p"},"join"),". However, ",(0,i.kt)("inlineCode",{parentName:"p"},"join")," will wait for merging the ",(0,i.kt)("strong",{parentName:"p"},"final")," values, while ",(0,i.kt)("inlineCode",{parentName:"p"},"inheritAll")," will merge the ",(0,i.kt)("strong",{parentName:"p"},"current")," values and then continue:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval withJoin =\n    for {\n        fiberRef <- FiberRef.make[Int](0)\n        fiber    <- (fiberRef.set(10) *> fiberRef.set(20).delay(2.seconds)).fork\n        _        <- fiber.join  // wait for fiber's end and copy final result 20 into fiberRef\n        v        <- fiberRef.get\n    } yield assert(v == 20)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval withoutJoin =\n    for {\n        fiberRef <- FiberRef.make[Int](0)\n        fiber    <- (fiberRef.set(10) *> fiberRef.set(20).delay(2.seconds)).fork\n        _        <- fiber.inheritAll.delay(1.second) // copy intermediate result 10 into fiberRef and continue\n        v        <- fiberRef.get\n    } yield assert(v == 10)\n")),(0,i.kt)("h2",{id:"compositional-updates-and-patch-theory"},"Compositional Updates and Patch Theory"),(0,i.kt)("p",null,"In the previous section, we learned the following:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Whenever a child fiber merges back into its parent, the value of the child fiber is, by default, replaced with the parent's value."),(0,i.kt)("li",{parentName:"ol"},"When we have multiple child fibers, and all of them join their parent, the value of the last child to join will prevail, replacing the parent's value.")),(0,i.kt)("p",null,"Let's examine these two rules with a simple example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject Main extends ZIOAppDefault {\n  val retries: FiberRef[Int] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.make(3)\n    }\n\n  def run =\n    for {\n      _ <- ZIO.unit\n      f1 = retries.set(10).debug("set 10").delay(2.seconds)\n      f2 = retries.set(5).debug("set 5")\n      _ <- f1 <&> f2\n      _ <- retries.get.debug("final retries value")\n    } yield ()\n\n}\n')),(0,i.kt)("p",null,"The output of this program is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"set 5: ()\nset 10: ()\nfinal retries value: 10\n")),(0,i.kt)("p",null,"As we can see from the program's output, when we delayed the ",(0,i.kt)("inlineCode",{parentName:"p"},"f1")," workflow, it became the last child fiber to join its parent. And guess what? Its value of 10 ended up being the winner! Why? Well, it's because the default rule is that the child's value takes over the parent's value during the merge."),(0,i.kt)("h3",{id:"the-problem"},"The Problem"),(0,i.kt)("p",null,"While developing the program, we might want to add additional configurations, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"intervals"),". In this case, we can easily include another ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," that holds the ",(0,i.kt)("inlineCode",{parentName:"p"},"intervals")," config:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject Main extends ZIOAppDefault {\n\n  val retries: FiberRef[Int] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.make(2)\n    }\n\n  val intervals: FiberRef[Int] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.make(3)\n    }\n\n  def run =\n    for {\n      _ <- retries.set(5) <&> intervals.set(3)\n      _ <- retries.get.debug("final retries value")\n      _ <- intervals.get.debug("final intervals value")\n    } yield ()\n\n}\n')),(0,i.kt)("p",null,"The output of this program is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"final retries value: 5\nfinal intervals value: 3\n")),(0,i.kt)("p",null,"This illustrates that by incorporating more ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),"s, we can concurrently update the underlying configuration values without any problems."),(0,i.kt)("p",null,"Since the two configurations are interconnected, it might be beneficial to create a new data type utilizing ",(0,i.kt)("inlineCode",{parentName:"p"},"Map[String, Int]"),". This approach eliminates the necessity of encoding retry configurations in two distinct ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef"),"s:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject Main extends ZIOAppDefault {\n  val retryConfig: FiberRef[Map[String, Int]] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.make(\n        Map(\n          "retries" -> 3,\n          "intervals" -> 2\n        )\n      )\n    }\n\n  def withRetry(n: Int) = retryConfig.update(_.updated("retries", n))\n\n  def withIntervals(n: Int) = retryConfig.update(_.updated("intervals", n))\n\n  def run =\n    for {\n      - <- withRetry(5) <&> withIntervals(3)\n      _ <- retryConfig.get.debug("retryConfig")\n    } yield ()\n\n}\n')),(0,i.kt)("p",null,"Unfortunately, with this change, the output does not align with our intended outcome:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"retryConfig: Map(retries -> 3, intervals -> 3)\n")),(0,i.kt)("p",null,"The intervals have been successfully updated, but the retries remain unchanged. Why is this the case? It's because both fibers are overwriting the same state, resulting in the corruption of the final value. In the previous scenario, the updates are as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"Parent fiber: Map(retries -> 3, intervals -> 2)\nLeft fiber:   Map(retries -> 5, intervals -> 2)\nright fiber:  Map(retries -> 3, intervals -> 3)\n\nParent fiber joins the left fiber:  Map(retries -> 5, intervals -> 2)\nParent fiber joins the right fiber: Map(retries -> 3, intervals -> 3)\n")),(0,i.kt)("p",null,"So, this is the reason why the retries value is not updated and ends up with the wrong value. The retries value is clobbered by the right fiber when it joins the parent fiber."),(0,i.kt)("p",null,"To solve this problem, we need a way to compose the updates. We need to be able to say, 'update the retries to 5 and then update the intervals to 3' or, conversely, 'update the intervals to 3 and then update the retries to 5'. We need to be able to compose updates. This is where compositional updates and the patch theory come into play."),(0,i.kt)("h3",{id:"differ-and-patch"},"Differ and Patch"),(0,i.kt)("p",null,"Before we dive into the code, let's try to understand some terminology:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait Differ[Value, Patch] {\n  def combine(first: Patch, second: Patch): Patch\n  def diff(oldValue: Value, newValue: Value): Patch\n  def empty: Patch\n  def patch(patch: Patch)(oldValue: Value): Value\n}\n")),(0,i.kt)("p",null,"By having an instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"Differ[Value, Patch]"),", we have the ability to do the following:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"We can ",(0,i.kt)("strong",{parentName:"li"},"diff")," two values of type ",(0,i.kt)("inlineCode",{parentName:"li"},"Value")," to generate a ",(0,i.kt)("inlineCode",{parentName:"li"},"Patch"),". What does ",(0,i.kt)("inlineCode",{parentName:"li"},"Patch")," mean? ",(0,i.kt)("inlineCode",{parentName:"li"},"Patch"),' is a data type that signifies the modifications made from one value to another. We can envision a patch as a "diff" between two values.'),(0,i.kt)("li",{parentName:"ol"},"With ",(0,i.kt)("strong",{parentName:"li"},"combine")," function we can provide two ",(0,i.kt)("inlineCode",{parentName:"li"},"Patch"),"s and combines them into a single ",(0,i.kt)("inlineCode",{parentName:"li"},"Patch"),". This is useful for composing updates. For example, if we have a ",(0,i.kt)("inlineCode",{parentName:"li"},"Patch")," that updates the ",(0,i.kt)("inlineCode",{parentName:"li"},"retries")," to 5 and another ",(0,i.kt)("inlineCode",{parentName:"li"},"Patch")," that updates the ",(0,i.kt)("inlineCode",{parentName:"li"},"intervals")," to 3, we can combine them into a single ",(0,i.kt)("inlineCode",{parentName:"li"},"Patch")," that updates both the ",(0,i.kt)("inlineCode",{parentName:"li"},"retries")," and the ",(0,i.kt)("inlineCode",{parentName:"li"},"intervals"),"."),(0,i.kt)("li",{parentName:"ol"},"Using the ",(0,i.kt)("strong",{parentName:"li"},"patch")," function we can apply a ",(0,i.kt)("inlineCode",{parentName:"li"},"Patch")," to a value to produce a new value."),(0,i.kt)("li",{parentName:"ol"},"The ",(0,i.kt)("strong",{parentName:"li"},"empty")," function gives us a ",(0,i.kt)("inlineCode",{parentName:"li"},"Patch")," that represents no changes.")),(0,i.kt)("p",null,"To implement a ",(0,i.kt)("inlineCode",{parentName:"p"},"Differ")," for a data type, we need to implement these 4 functions. We have four laws associated with any ",(0,i.kt)("inlineCode",{parentName:"p"},"Differ")," value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Differ[Value, Patch]"),":"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"combine")," function is associative, which means that combining two patches and then combining the result with a third patch is the same as combining the first patch with the combination of the second and third patches."),(0,i.kt)("li",{parentName:"ol"},"Combining a patch with an empty patch is the same as the patch itself."),(0,i.kt)("li",{parentName:"ol"},"Diffing a value with itself produces an empty patch."),(0,i.kt)("li",{parentName:"ol"},"Diffing two values and then patching the first value with the resulting patch results in the second value."),(0,i.kt)("li",{parentName:"ol"},"Patching a value with an empty patch results in the original value.")),(0,i.kt)("p",null,"ZIO includes some utilities which helps us to create ",(0,i.kt)("inlineCode",{parentName:"p"},"Differ")," instances for more complex data types:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Instances of ",(0,i.kt)("inlineCode",{parentName:"li"},"Differ")," for common data types, such as ",(0,i.kt)("inlineCode",{parentName:"li"},"Map"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Set"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"Chunk"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Differ.update[A]"),", which constructs a differ that diffs two values by returning a function that sets the value to the new value."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Differ.map"),", which constructs a map differ from a differ which knows how to diff the values of the map."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Differ#zip"),", is used to combine two differs into a single differ that works on a tuple of values."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Differ#orElseEither"),", is used to combine two differs into a single differ that works on an ",(0,i.kt)("inlineCode",{parentName:"li"},"Either")," of two values."),(0,i.kt)("li",{parentName:"ul"},"Using ",(0,i.kt)("inlineCode",{parentName:"li"},"Differ#transform"),", we can convert a differ of one type (Value1) to a differ of another type (Value2) by providing two functions: one to convert the Value1 to Value2 and another to convert the Value2 to Value1.")),(0,i.kt)("p",null,"Let's implement a ",(0,i.kt)("inlineCode",{parentName:"p"},"Differ")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"retryConfig")," which is a FiberRef of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Map[String, Int]"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval differ   = Differ.map[String, Int, Int => Int](Differ.update[Int])\nval patch1   = differ.diff(Map("retries" -> 3), Map("retries" -> 5))\nval patch2   = differ.diff(Map("intervals" -> 2), Map("intervals" -> 3))\nval combined = differ.combine(patch1, patch2)\nval result   = differ.patch(combined)(Map("retries" -> 3, "intervals" -> 2))\nprintln(result)\n')),(0,i.kt)("p",null,"The output is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"Map(retries -> 5, intervals -> 3)\n")),(0,i.kt)("h3",{id:"first-solution-compositional-updates-for-mapstring-int-data-type"},"First Solution: Compositional Updates For ",(0,i.kt)("inlineCode",{parentName:"h3"},"Map[String, Int]")," Data Type"),(0,i.kt)("p",null,"In previous section, we have successfully updated the ",(0,i.kt)("inlineCode",{parentName:"p"},"retries")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"intervals")," values using compositional updates. Now we can use this differ to make the updates of our ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," composable:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject Main extends ZIOAppDefault {\n\n  val differ = Differ.map[String, Int, Int => Int](Differ.update[Int])\n\n  val retryConfig: FiberRef[Map[String, Int]] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.makePatch[Map[String, Int], Differ.MapPatch[\n        String,\n        Int,\n        Int => Int\n      ]](\n        Map(\n          "retries" -> 3,\n          "intervals" -> 2\n        ),\n        differ = differ,\n        fork0 = differ.empty\n      )\n    }\n\n  def withRetry(n: Int): UIO[Unit] =\n    retryConfig.update(_.updated("retries", n))\n\n  def withIntervals(n: Int): UIO[Unit] =\n    retryConfig.update(_.updated("intervals", n))\n\n  def run = {\n    for {\n      _ <- withRetry(5) <&> withIntervals(3)\n      _ <- retryConfig.get.debug("retryConfig")\n    } yield ()\n\n  }\n}\n')),(0,i.kt)("p",null,"The output is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"retryConfig: Map(retries -> 5, intervals -> 3)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Please note that as the ",(0,i.kt)("inlineCode",{parentName:"p"},"combine")," operation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Differ")," is associative, the order of the updates does not change the result. This is a very important property of compositional updates in concurrent environments where multiple fibers updating the same value when they join, but the order of the joins is not deterministic.")),(0,i.kt)("h3",{id:"second-solution-compositional-updates-for-the-retryconfig-case-class"},"Second Solution: Compositional Updates For The ",(0,i.kt)("inlineCode",{parentName:"h3"},"RetryConfig")," Case Class"),(0,i.kt)("p",null,"We can take this example one step further and create a type-safe configuration data type for ",(0,i.kt)("inlineCode",{parentName:"p"},"RetryConfig")," using scala case classes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class RetryConfig(\n    retries: Int,\n    intervals: Int\n)\n")),(0,i.kt)("p",null,"We can create a ",(0,i.kt)("inlineCode",{parentName:"p"},"Differ")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"RetryConfig")," using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Differ#transform")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nval differ: Differ[RetryConfig, (Int => Int, Int => Int)] =\n  Differ\n    .update[Int]\n    .zip(Differ.update[Int])\n    .transform(\n      { case (x, y) => RetryConfig.apply(x, y) },\n      retryConfig => (retryConfig.retries, retryConfig.intervals)\n    )\n")),(0,i.kt)("p",null,"Now, as same as before, we can use this ",(0,i.kt)("inlineCode",{parentName:"p"},"differ")," to make the updates of our new ",(0,i.kt)("inlineCode",{parentName:"p"},"FiberRef")," composable:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nobject Main extends ZIOAppDefault {\n\n  val retryConfig: FiberRef[RetryConfig] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.makePatch[RetryConfig, (Int => Int, Int => Int)](\n        initialValue0 = RetryConfig(\n          retries = 3,\n          intervals = 2\n        ),\n        differ = differ,\n        fork0 = differ.empty\n      )\n    }\n\n  def withRetry(n: Int) = retryConfig.update(_.copy(retries = n))\n\n  def withIntervals(n: Int) = retryConfig.update(_.copy(intervals = n))\n\n  def run =\n    for {\n      _ <- withRetry(5) <&> withIntervals(3)\n      _ <- retryConfig.get.debug("retryConfig")\n    } yield ()\n    \n}\n')))}c.isMDXComponent=!0}}]);