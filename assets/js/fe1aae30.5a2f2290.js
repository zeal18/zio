"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[14034],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},h=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),d=p(n),u=i,m=d["".concat(s,".").concat(u)]||d[u]||c[u]||r;return n?a.createElement(m,o(o({ref:t},h),{},{components:n})):a.createElement(m,o({ref:t},h))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},68946:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={id:"associativeeither",title:"AssociativeEither"},o=void 0,l={unversionedId:"zio-prelude/functional-abstractions/parameterized-types/associativeeither",id:"zio-prelude/functional-abstractions/parameterized-types/associativeeither",title:"AssociativeEither",description:"AssociativeEither describes a way of combining two values F[A] and F[B] into a value F[Either[A, B]] that is associative.",source:"@site/docs/zio-prelude/functional-abstractions/parameterized-types/associativeeither.md",sourceDirName:"zio-prelude/functional-abstractions/parameterized-types",slug:"/zio-prelude/functional-abstractions/parameterized-types/associativeeither",permalink:"/zio-prelude/functional-abstractions/parameterized-types/associativeeither",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/parameterized-types/associativeeither.md",tags:[],version:"current",frontMatter:{id:"associativeeither",title:"AssociativeEither"},sidebar:"ecosystem-sidebar",previous:{title:"AssociativeBoth",permalink:"/zio-prelude/functional-abstractions/parameterized-types/associativeboth"},next:{title:"AssociativeFlatten",permalink:"/zio-prelude/functional-abstractions/parameterized-types/associativeflatten"}},s={},p=[],h={toc:p},d="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"AssociativeEither")," describes a way of combining two values ",(0,i.kt)("inlineCode",{parentName:"p"},"F[A]")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"F[B]")," into a value ",(0,i.kt)("inlineCode",{parentName:"p"},"F[Either[A, B]]")," that is associative."),(0,i.kt)("p",null,"Its signature is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait AssociativeEither[F[_]] {\n  def either[A, B](fa: => F[A], fb: => F[B]): F[Either[A, B]]\n}\n")),(0,i.kt)("p",null,"If we import ",(0,i.kt)("inlineCode",{parentName:"p"},"zio.prelude._")," we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"orElseEither")," operator or its symbolic alias ",(0,i.kt)("inlineCode",{parentName:"p"},"<+>")," to combine any two values of a parameterized type ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," that have an ",(0,i.kt)("inlineCode",{parentName:"p"},"AssociativeEither")," instance defined for them."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"either")," operator must be associative, so if we combine two values ",(0,i.kt)("inlineCode",{parentName:"p"},"fa")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fb")," and then combine the result with ",(0,i.kt)("inlineCode",{parentName:"p"},"fc"),", that must be the same as combining ",(0,i.kt)("inlineCode",{parentName:"p"},"fb")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"fc")," and then combining ",(0,i.kt)("inlineCode",{parentName:"p"},"fa")," with the result. That is, after reassociating ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," values the following property must hold:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"(fa <+> fb) <+> fc === fa <+> (fb <+> fc)\n")),(0,i.kt)("p",null,"This is the same associative law we saw for concrete types described by the ",(0,i.kt)("inlineCode",{parentName:"p"},"Associative")," abstraction, but lifted to the context of parameterized types."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"either")," operator corresponds to running the left value and if that fails running the right value."),(0,i.kt)("p",null,"To see this, we can observe that since the ",(0,i.kt)("inlineCode",{parentName:"p"},"either")," operator must return an ",(0,i.kt)("inlineCode",{parentName:"p"},"Either[A, B]")," we must choose on some basis whether to return the left value or the right value. Furthermore, we must choose on some consistent basis so that the order of operations does not matter."),(0,i.kt)("p",null,"There are a couple of trivial ways we could do this, like always running the left value or always running the right value. However, the way we can do this that preserves information is to run the right value and then if it fails in some way to run the right value."),(0,i.kt)("p",null,"What it means to run the left value and then if it fails run the right value depends on the parameterized type."),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," the meaning is quite straightforward. The ",(0,i.kt)("inlineCode",{parentName:"p"},"orElseEither")," operator runs the left ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," workflow and returns its result if it succeeds, otherwise it runs the right ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," workflow and returns its result."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\ndef orElseEither[R, E, A, B](left: => ZIO[R, E, A], right: => ZIO[R, E, B]): ZIO[R, E, Either[A, B]] =\n  left.foldZIO(_ => right.map(b => Right(b)), a => ZIO.succeed(Left(a)))\n")),(0,i.kt)("p",null,"Here we run the ",(0,i.kt)("inlineCode",{parentName:"p"},"left")," workflow and if it is successful we just wrap it up in a ",(0,i.kt)("inlineCode",{parentName:"p"},"Left"),". If the ",(0,i.kt)("inlineCode",{parentName:"p"},"left")," workflow fails we recover from its failure and run the ",(0,i.kt)("inlineCode",{parentName:"p"},"Right")," effect, packaging its result up in a ",(0,i.kt)("inlineCode",{parentName:"p"},"Right"),"."),(0,i.kt)("p",null,"We can see that this is associative because no matter how many ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO")," workflows we combine with ",(0,i.kt)("inlineCode",{parentName:"p"},"orElseEither")," the result will always be the first one from left to right to successfully complete execution."),(0,i.kt)("p",null,"Notice here that if the ",(0,i.kt)("inlineCode",{parentName:"p"},"left")," workflow succeeds we never run the right workflow at all or even need to construct it. The fact that ",(0,i.kt)("inlineCode",{parentName:"p"},"either")," and the other binary operators in ZIO Prelude are by name gives us the freedom to model that instead of having to introduce additional interfaces."),(0,i.kt)("p",null,"Other data types that model failure have similar implementations of the ",(0,i.kt)("inlineCode",{parentName:"p"},"orElseEither")," operator. For example, here are the implementations of ",(0,i.kt)("inlineCode",{parentName:"p"},"orElseEither")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Option"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def orElseEither[E, A, B](left: => Either[E, A], => right: Either[E, B])]): Either[E, Either[A, B]] =\n  left match {\n    case Left(e) =>\n      that match {\n        case Left(e)  => Left(e)\n        case Right(b) => Right(Right(b))\n      }\n    case Right(a) => Right(Left(a))\n  }\n\ndef orElseEither[A, B](left: => Option[A], => right: Option[B])]): Option[Either[A, B]] =\n  left match {\n    case None =>\n      that match {\n        case None     => None\n        case Right(b) => Some(Right(b))\n      }\n    case Some(a) => Some(Left(a))\n  }\n")),(0,i.kt)("p",null,"In both cases if the ",(0,i.kt)("inlineCode",{parentName:"p"},"left")," value is a success we return its result in a ",(0,i.kt)("inlineCode",{parentName:"p"},"Left"),". Otherwise if the ",(0,i.kt)("inlineCode",{parentName:"p"},"right")," value is a success we return its result in a ",(0,i.kt)("inlineCode",{parentName:"p"},"Right")," and if it is a failure we fail with that error."),(0,i.kt)("p",null,"Notice in both cases we did not need to evaluate the ",(0,i.kt)("inlineCode",{parentName:"p"},"right")," value if the ",(0,i.kt)("inlineCode",{parentName:"p"},"left")," value was a success. We could have just made the ",(0,i.kt)("inlineCode",{parentName:"p"},"right")," parameter lazy but we could flip any of these binary operators so for correctness it is important that both arguments be lazy."),(0,i.kt)("p",null,"Another interpretation of ",(0,i.kt)("inlineCode",{parentName:"p"},"orElseEither")," comes from collections. Consider the following implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"orElseEither")," operator for ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import zio.prelude._\n\nimplicit val ChunkAssociativeEither: AssociativeEither[Chunk] =\n  new AssociativeEither[Chunk] {\n    def either[A, B](as: => Chunk[A], bs: => Chunk[B]): Chunk[Either[A, B]] =\n      as.map(Left(_)) ++ bs.map(Right(_))\n  }\n// ChunkAssociativeEither: AssociativeEither[Chunk] = repl.MdocSession$MdocApp0$$anon$1@2f19e8c\n")),(0,i.kt)("p",null,"Here we are concatenating the two ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk")," values, putting the elements from the left ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk")," in a ",(0,i.kt)("inlineCode",{parentName:"p"},"Left")," and the elements from the right ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk")," in a ",(0,i.kt)("inlineCode",{parentName:"p"},"Right"),". We can think of this as running the left ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk")," until it fails by running out of elements and then running the right ",(0,i.kt)("inlineCode",{parentName:"p"},"Chunk"),"."),(0,i.kt)("p",null,"We can see a similar interpretation in the implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"orElseEither")," operator for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Schedule")," data type from ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIO"),". It runs the left schedule while it wants to continue and when it stops runs the right schedule, emitting either a ",(0,i.kt)("inlineCode",{parentName:"p"},"Left")," with the output of the left schedule or a ",(0,i.kt)("inlineCode",{parentName:"p"},"Right")," with the output of the right schedule each time."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"AssociativeEither")," abstraction isn't limited to covariant data types."),(0,i.kt)("p",null,"Let's see how we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"orElseEither")," operator to combine values of a contravariant type."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Predicate")," type knows how to evaluate a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," to return a ",(0,i.kt)("inlineCode",{parentName:"p"},"Boolean"),". This ",(0,i.kt)("inlineCode",{parentName:"p"},"Boolean")," could describe whether the value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," is valid data for example, or whether we should take some further action."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait Predicate[-A] {\n  def run(a: A): Boolean\n}\n")),(0,i.kt)("p",null,"We could implement an instance of the ",(0,i.kt)("inlineCode",{parentName:"p"},"AssociativeEither")," abstraction for ",(0,i.kt)("inlineCode",{parentName:"p"},"Predicate")," like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object Predicate {\n  implicit val PredicateAssociativeEither: AssociativeEither[Predicate] =\n    new AssociativeEither[Predicate] {\n      def either[A, B](left: => Predicate[A], right: => Predicate[B]): Predicate[Either[A, B]] =\n        new Predicate[Either[A, B]] {\n          def run(either: Either[A, B]): Boolean =\n            either match {\n              case Left(a) => left.run(a)\n              case Right(b) => right.run(b)\n            }\n        }\n    }\n}\n")),(0,i.kt)("p",null,"The interpretation is slightly different here. Now failing means not being able to handle a value at all."),(0,i.kt)("p",null,"The left ",(0,i.kt)("inlineCode",{parentName:"p"},"Predicate")," knows how to determine whether ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," values satisfy the condition and the right ",(0,i.kt)("inlineCode",{parentName:"p"},"Predicate")," knows how to determine whether ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," values satisfy the condition. So when we get an ",(0,i.kt)("inlineCode",{parentName:"p"},"Either[A, B]")," we have to match on it to determine whether it is an ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," that the left ",(0,i.kt)("inlineCode",{parentName:"p"},"Predicate")," can handle at all."),(0,i.kt)("p",null,"If so, we send it to the left ",(0,i.kt)("inlineCode",{parentName:"p"},"Predicate")," and return its result. Otherwise we send it to the right ",(0,i.kt)("inlineCode",{parentName:"p"},"Predicate")," and return its result."),(0,i.kt)("p",null,"Just like the ",(0,i.kt)("inlineCode",{parentName:"p"},"AssociativeBoth")," abstraction, if a data type with an ",(0,i.kt)("inlineCode",{parentName:"p"},"AssociativeEither")," instance is covariant there are additional operators we can define on it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def orElse[F[+_]: AssociativeEither : Covariant, A](fa: => F[A], fb: => F[A]): F[A] =\n  fa.orElseEither(fb).map(_.merge)\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"orElse")," operator just combines two ",(0,i.kt)("inlineCode",{parentName:"p"},"F[A]")," values with ",(0,i.kt)("inlineCode",{parentName:"p"},"orElseEither")," and then maps the result to merge the left and right sides of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),". This is probably the version of the ",(0,i.kt)("inlineCode",{parentName:"p"},"orElse")," operator we are most familiar with."),(0,i.kt)("p",null,"We can also define additional operators if a data type that has a ",(0,i.kt)("inlineCode",{parentName:"p"},"AssociativeEither")," instance defined for it is contravariant."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def eitherWith[F[-_]: AssociativeEither : Contravariant, A, B, C](fa: F[A], fb: F[B])(\n  f: C => Either[A, B]\n): F[C] =\n  fa.orElseEither(fb).contramap(f)\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"eitherWith")," operator first converts input of type ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," into ",(0,i.kt)("inlineCode",{parentName:"p"},"Either[A, B]")," values with ",(0,i.kt)("inlineCode",{parentName:"p"},"contramap")," and the function ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", then runs the ",(0,i.kt)("inlineCode",{parentName:"p"},"fa")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fb")," values using that input and the ",(0,i.kt)("inlineCode",{parentName:"p"},"orElseEither")," operator."),(0,i.kt)("p",null,"For example, if our data type was a ",(0,i.kt)("inlineCode",{parentName:"p"},"Predicate")," the ",(0,i.kt)("inlineCode",{parentName:"p"},"eitherWith")," operator could split incoming payloads into one of two types, sending them to the appropriate predicate for evaluation and then returning the results. Of course, if we can handle a payload with two types in this way we can also handle payloads with any number of cases by repeatedly applying the ",(0,i.kt)("inlineCode",{parentName:"p"},"eitherWith")," operator."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"AssociativeEither")," functional abstraction represents the second fundamental way of combining two values of a parameterized type. Whereas ",(0,i.kt)("inlineCode",{parentName:"p"},"AssociativeBoth")," combines the ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," values into the sum type represented by ",(0,i.kt)("inlineCode",{parentName:"p"},"(A, B)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"AssociativeEither")," combines them into the product type represented by ",(0,i.kt)("inlineCode",{parentName:"p"},"Either[A, B]"),"."),(0,i.kt)("p",null,"For existing data types the ",(0,i.kt)("inlineCode",{parentName:"p"},"orElseEither")," operator and its variants tend to already be implemented, often with more domain specific names, so there isn't necessarily an immediate benefit if you are working with existing data types from ZIO or the Scala standard library."),(0,i.kt)("p",null,"However, if you are defining your own parameterized types it can be helpful to think about what it would mean for running a value to fail and what it would mean to run another value instead. There are also operators in ZIO Prelude that are defined on types with an ",(0,i.kt)("inlineCode",{parentName:"p"},"AssociativeEither")," instance, so implementing an instance for your own data type can let you take advantage of that functionality and test your implementation with the laws in ZIO Prelude."),(0,i.kt)("p",null,"Finally, the ",(0,i.kt)("inlineCode",{parentName:"p"},"AssociativeEither")," abstraction can be quite helpful in some cases for writing generic code in terms of the abstractions in ZIO Prelude."),(0,i.kt)("p",null,"The combination of the ability to express running the left value and then running the right value with ",(0,i.kt)("inlineCode",{parentName:"p"},"AssociativeBoth")," and running the left value and if it fails running the right value with ",(0,i.kt)("inlineCode",{parentName:"p"},"AssociativeEither")," can be quite powerful. For example, we can define many parsers in this way."))}c.isMDXComponent=!0}}]);